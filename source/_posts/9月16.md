---
title: 9月16
date: 2021-09-16 10:03:32
categories:
tags:
thumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gui97vocthj618z0u0tp702.jpg
---
maven install 是先进行打包，在target目录下生成新jar，同时将打包结果放到本地仓库的相应目录中，供其他项目或模块引用。

---

=====================================

9月17日

因为Map这个类没有继承Iterable接口所以不能直接通过map.iterator来遍历，<span style=color:red>所以就只能先转化为set类型</span>，用entrySet()方法，**其中set中的每一个元素值就是map中的一个键值对**，也就是Map.Entry<K,V>了，然后就可以遍历了。

也就是说：每个entry就是一个键值对，存在set里面



xcode-select –-install 解决mac没有编译器的问题

# Java中正则表达式

[]代表匹配中括号中其中任一个字符，如[abc]匹配a或b或c。

-在中括号里面和外面代表含义不同，如在外时，就匹配-，如果在中括号内[a-b]表示匹配26个小写字母中的任一个；[a-zA-Z]匹配大小写共52个字母中任一个；[0-9]匹配十个数字中任一个。

^在中括号里面和外面含义不同，如在外时，就表示开头，如^7[0-9]表示匹配开头是7的，且第二位是任一数字的字符串；如果在中括号里面，表示除了这个字符之外的任意字符(包括数字，特殊字符)，如[^abc]表示匹配出去abc之外的其他任一字符。

.表示匹配任意的字符。

+表示出现1次或多次。



为了防止别人拿到链接，重复调用接口的问题（重放问题），我们需要**保证请求的唯一性**，也就是保证这条请求只能调用一次，不能被重复调用。怎么做呢？ ==》 在请求参数中加入时间戳 timestamp（yyyyMMddHHmmss），并一起进行MD5加密签名，

考虑到客户端与服务端之间的网络延迟问题，我们不能保证客户端与服务端的时间完全一致，所以我们可以折中一下：只要满足客户端请求的时间 timestamp 与服务端接收到请求的当前时间 currentTime 之间相差的绝对值在60s以内，我们就算是一次唯一不重发的请求。

这种靠添加时间戳 timestamp 保证请求唯一性的方式可以说已经很好地防止了重发问题的发生；***但是假如有高手能够在1分钟之内获取到完整链接***，那么他就能够再次利用相同的链接进行重发操作，获取服务端返回的数据！！！



---

=================================

9月20日



![image-20210920164831409](/Users/wuzhenren/myblog/source/_posts/9月16.assets/image-20210920164831409.png)





当i=4,j=3时，此时combination有了变化，、

即值为7的时候，j遍历到4的位置，有了另一种组合

所以在7的位置上，有combination+=combination[j]种组合



![image-20210920165241256](/Users/wuzhenren/myblog/source/_posts/9月16.assets/image-20210920165241256.png)



---

![image-20210920174622708](/Users/wuzhenren/myblog/source/_posts/9月16.assets/image-20210920174622708.png)





#### CyclicBarrier 与 CountDownLatch 区别

- CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的
- CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。
- CyclicBarrier 参与的线程职责是一样的

```java
public CyclicBarrier(int parties)
public CyclicBarrier(int parties, Runnable barrierAction)

// -构造方法
//parties 是参与线程的个数
//第二个构造方法有一个 Runnable 参数，这个参数的意思是最后一个到达线程要做的任务

public int await() throws InterruptedException, BrokenBarrierException
public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException

  //- 函数
//线程调用 await() 表示自己已经到达栅栏
//BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时
//调用await方法的线程告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞。直到parties个参与线程调用了await方法


```

Executors.newSingleThreadExecutor()这种的实现方式，看名字我们就应该知道是使用单线程重来支持的



### JAVA栅栏和闭锁的区别

闭锁： 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。即一组线程在等待某一事件的发生或者得到某些线程的资源。事件没有发生前，所有线程将阻塞等待，而事件发生后，所有线程将开始执行；闭锁最初处于封闭状态，

闭锁CountDownLatch唯一的构造方法CountDownLatch(int count)，当在闭锁上调用countDown()方法时，闭锁计数器-1，当闭锁计数器为0时，闭锁将打开，所有线程将通过闭锁开始执行

**栅栏：**一个同步辅助类，允许一组线程互相等待，知道到达某个公共屏障点。利用栅栏，可以使线程相互等待，直到所有线程到达某一点，然后将栅栏打开，CyclicBarrier支持一个可选的Runnable参数。当线程通过栅栏时，runnable对象将被调用。构造函数CyclicBarrier(int parties, Runnable barrierAction)

当线程在cyclicBarrier对象上调用await()方法时，栅栏的计数器将增加1，当计数器的值为parties时，栅栏将打开。

　　**区别：**闭锁用于所有线程等待一个外部事件的发生；栅栏则是所有线程相互等待，直到所有线程都到达某一点时才打开栅栏，然后线程可以继续执行。

闭锁在等别人完成才能冲，栅栏是等其他人到了在一起冲。

