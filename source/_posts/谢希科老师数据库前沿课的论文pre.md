---
title: 谢希科老师数据库前沿课的论文pre
date: 2021-07-31 18:40:08
categories:
- ustc
- 个人生活
tags:
thumbnail: https://picjumbo.com/wp-content/uploads/website-programming-code-free-photo-2210x1473.jpg
---
之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好

## pre要求
全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。

要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。

ppt的讲诉，不能太长，要突出重点，

讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。

## 论文选题
相比研究之前的skyline，我更希望看点对我有用的东西，

所以我准备选取数据库方向的文章。

SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020

离谱，wps新版的划词翻译的地方还不好找，
![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg)

如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。

短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法
复杂OLAP查询的快速n元连接查询处理方法

##### 超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键

##### 候选键(candidate key):不含有多余属性的超键称为候选键

##### 主键(primary key):用户选作元组标识的一个候选键程序主键

**外键 (FK)** 是用于建立和加强两个表数据之间的链接的**一列**或**多列**

通过将保存表中主键值的一列或多列添加到另一个表中，可创建两个表之间的链接。这个列就成为第二个表的外键。

**一张表外键的值一般来说是另一张表主键的值。因此，外键的存在使得表与表之间可以联系起来**

FOREIGN KEY 约束防止这种情况的发生。如果主键表中数据的更改使之与外键表中数据的链接失效，则这种更改是不能实现的，从而确保了引用完整性。如果试图删除主键表中的行或更改主键值，而该主键值与另一个表的 FOREIGN KEY 约束值相关，则该操作不可实现。若要成功更改或删除FOREIGN KEY 约束的行，可以先在外键表中删除外键数据或更改外键数据，然后将外键链接到不同的主键数据上去。

**OLAP**联机分析处理是一种软件技术，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。

随着市场竞争的日趋激烈，企业更加强调决策的及时性和准确性，这使得以**支持决策管理分析**为主要目的的应用迅速崛起，这类应用被称为联机分析处理，它所存储的数据被称为信息数据。

数据仓库：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。

基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。

- 电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。
- 第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成**多台服务器**和多个业务数据库（**量大+分库分表**），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。
- 第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到**非常精细化**和**具体的用户的集群分析**，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。

这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：

1. 业务数据库中的数据结构是**为了完成交易而设计**的，不是为了而查询和分析的便利设计的。
2. 业务数据库大多是**读写优化的**，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。

而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：

1. 数据结构为了分析和查询的便利；
2. 只读优化的数据库，即**不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。**

数据库 比较流行的有：MySQL, Oracle, SqlServer等

数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等

**本OLAP查询**，基于成本模型 生成包含 **n 元连接运算符**的 查询计划。

**+：a+b所以‘+’就是二元运算符。
++：a++所以++就是一元运算符。**

n元就是n个元素，n个表做连接运算

### 本文结论：SPRINTER 的性能优于最先进的 OLAP 系统。

keywords: n元连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理

现有系统利用了各种技术，例如中间结果的流水线

OLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学

In particular, the number of queries which

contain join operations between a pair of foreign (or non

unique) keys rather than a conventional pair of primary and

foreign keys increases in the applications. 

尤其是，查询的数量包括了外键之间的连接操作，而不是增加在应用程序的传统主键和外键

本文将这种连接操作表示为FK-FK连接，一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。

**流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。**

它可能对PK-FK连接的查询有效，但对于**事实表中包含FK-FK连接的复杂查询**可能无效

**因为存在以下两个问题：**许多key比较 以及大量的内存使用量。

首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。

n元连接操作和二元连接操作相比，可以减少中间结果数量，大多数情况下更有效，

多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 ，**因为在内存内的处理环境中，哈希连接通常优于归并排序连接**，并且不同于OLAY图形模式查询，OLAY查询是ad-hoc(点对点)和acyclic(无环)；

我们提出了一种方法，可以生成n元连接的查询，而不是传统的二元操作，

生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，相比较二元 搜索空间变得更大，

我们**提出了所使用的成本模型**和一种**查询优化方法 t**允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树

单向连接啥基于最坏情况最优连接算法， the worst case optimal join algorithm，

we have demonstrated that SPRINTER significantly outperforms the state-of-the-art OLAP query processing systems in terms of both processing speed and data size that can be **processed without our of memory**.

我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以在内存不溢出的情况下处理

本文贡献如下：

- 我们提出了一种查询方法，可以生成复杂的OLAY查询的n元连接树包含FK-FK
- 我们提出了成本模型和查询优化n路连接树的方法
- n元n路处理方法：基于最坏情况最优连接算法
- 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。
- 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。



### 2.2 sprinter 中使用最坏情况下最优连接算法

当n-ary连接操作符的输入大小非常大时，使用**GPU进行排序**可以进一步提高查询性能。因此，SPRINTER使用不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。

**表1中基于比较的算法**意味着，它们需要在排序的key值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n。它们不需要这样的比较来进行排序（例如，radix排序。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.logN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。



**在那个case，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。**

we assume that *X* is too large to fit in GPU memory, and so, we need to split it into six subar rays {*X*1, · · · ,*X*6}. 

虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。

异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本。 y尽可能通过重叠**三种低级GPU操作**，**H2D拷贝**、**radix排序**和**D2H拷贝**。

两两合并成一个新的这下一个x2

![image-20210805223429708](/Users/wuzhenren/myblog/source/_posts/谢希科老师数据库前沿课的论文pre.assets/image-20210805223429708.png)



#### 最坏情况最优连接算法

通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询），一些算法[1,31,44]**需要对输入关系和存储进行预处理，预处理作为数据结构的结果，如B+-tree，**

![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)

当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二分查找，因此，单个搜索的成本是O(logN),如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。 虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优。因此，TJ估计每个可能顺序的连接处理成本，并选择最好的顺序。

### 3 一个激励例子

在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS(?)基准数据库[30]上的一个查询，**广泛用于t 测试OLAP系统[18]的查询性能**。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点**关注连接**操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有**2个FK-FK连接**操作，**绿线有5个PK-FK连接**操作。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg)











图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。 

系统-x是一个功能齐全的最先进的商业化的内存数据库系统,支持索引驱动的查询执行和查询优化技术，如bloom过滤器和自适应连接。

在图4(a)中，它为查询计划生成一个**左深连接树**，并以操作员一次**操作的方式**执行该计划。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)



**C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。**【？】

2.23B就是22.3亿

图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数

因为连接操作是FK-FK连接，并且在哈希表中有许多**重复的键值**，所以num 在**探测连接**过程中，哈希表中的key值被访问，我们称之为**探测成本**，这是巨大的，特别是160.9B倍。

OmniSci[33]是一个开源的**协同处理数据库系统**，其中协同处理意味着**同时**利用**cpu**和**gpu**进行查询处理。

如图b,它生成了一个左深连接的查询计划 和a一样。

但是是以**非阻塞**和**流水线的方式**执行计划，它**不会生成和存储**要连接的**中间结果**。

详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。

图b中SS和SR的第一个连接 ，**对SS的每一个元祖依次探测SR的29M元祖，即暴力遍历**、，哪个探测成本变成了4.1亿美元。

然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B.

我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.

SPRINTER是系统原型，即我们提出的一种集成了跨所有相关层和模块无缝集成到OmniSci中的方法。

我们选择OmniSci作为SPRINTER的基础系统，因为它是最先进的开源现代数据库系统

虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。

如图c，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。

它分别执行三个连接子树，

- S1={SS、C1、D， I}
- S2={SR、C2}
- S3={CS、C3}

像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。

当我们计算时 S1、S2、S3的探针总成本仅为758M

此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.

总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。

图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。

性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，

SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。通过管道化消除大的中间结果，通过将单个大的连接树分割成多个较小的连接子树，并对连接子树的结果执行n个连接。



### 4 n个连接树的查询规划方法

我们首先将在第4.1节中介绍用于生成包含**单个n-ary连接操作符**的查询计划的查询规划方法。然后，我们将该方法**推广**到更复杂的查询中，这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。

我们考虑一个来自给定查询Q的连接图

查询Q的连接图G=(V、E、f(v∈V)、g(e∈E)、h(e∈E))是一个无向多重图。

顶点v∈V表示Q中连接的关系，

边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。

有三个标记功能f(v)、g(e)和h(e)。

函数f(v)返回 关系v的类型，即事实或维数，

函数g(e）连接操作的类型，即PK-FK或FK-FK，

以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).

在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图**表示为核心子图**

连接图G的核心子图，即核心=(Vc，Ec)⊆G，**s.t.是subject to 的缩写，表示约束条件。在。。。的情况下**。

其中任何两个顶点X和Y在X∈Vc和Y∈Vc的情况下，通过as连接 *E**X*,*Y* ⊆ *E**c**E**c* s.t. *g*(*e* ∈ *E**X*,*Y* )

= FK-FK, *f* (*X*) = *f act* and *f* (*Y*) = *f act*.

在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，

事实数据表是包含描述业务内特定事件的数据。是发生在现实世界中的操作型事件所产生的可度量数据，**通常包含大量的行。**日常查询请求的主要目标就是基于事实表展开计算和聚合操作。
从最低粒度级别来看，事实表行对应一个度量事件，也可以说，一个度量事件必然对应一个最低粒度的事实行为。

我们认为的一行数据是什么样的，粒度。

事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与维度表中对应项的相关索引字段除外的任何数据。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)



​											图5：激励性查询的分解。

如果一个连接图G只有**一个**核心子图**核心**，那么我们可以将G分解为核心子图核心和一组彼此在**边不相交的非核心子图**。

我们就可以使用r 将上述两种分解方法分别表示为D1={core、G1、G2、G3}和D2={core、G1}。

算法1提供了仅包含单个核心子图的查询的基本查询规划方法。

这种方法背后的直觉是使一个**核心子图**成为一个**查询计划**和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。



### 5 自动连接处理方法和优化方法，提供查询性能









### 6 odel









### 7 介绍了实验评价的结果









### 总结全文

