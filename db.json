{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/ustc/sprinter-快速n元连接处理.pdf","path":"ustc/sprinter-快速n元连接处理.pdf","modified":0,"renderable":0},{"_id":"themes/miccall/source/css/backcss.css","path":"css/backcss.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/demo.css","path":"css/demo.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/dropdownMenu.css","path":"css/dropdownMenu.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/gallery.css","path":"css/gallery.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/item.css","path":"css/item.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/mic_gallery.css","path":"css/mic_gallery.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/mic_main.css","path":"css/mic_main.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/my_link.css","path":"css/my_link.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/normalize.css","path":"css/normalize.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/noscript.css","path":"css/noscript.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/ok_prism.css","path":"css/ok_prism.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism.css","path":"css/prism.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_coy.css","path":"css/prism_coy.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_dark.css","path":"css/prism_dark.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_default.css","path":"css/prism_default.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_funky.css","path":"css/prism_funky.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_okaidia.css","path":"css/prism_okaidia.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_solarized.css","path":"css/prism_solarized.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_twilight.css","path":"css/prism_twilight.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/typo.css","path":"css/typo.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/FZLT.ttf","path":"fonts/FZLT.ttf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/12.jpg","path":"images/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/21.jpg","path":"images/21.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/3123.jpg","path":"images/3123.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/WechatIMG501.jpeg","path":"images/WechatIMG501.jpeg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/me.jpg","path":"images/me.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/overlay.png","path":"images/overlay.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","path":"images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic01.jpg","path":"images/pic01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic02.jpg","path":"images/pic02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic03.jpg","path":"images/pic03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic04.jpg","path":"images/pic04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic05.jpg","path":"images/pic05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic06.jpg","path":"images/pic06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic07.jpg","path":"images/pic07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic08.jpg","path":"images/pic08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic09.jpg","path":"images/pic09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic10.jpg","path":"images/pic10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic11.jpg","path":"images/pic11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic12.jpg","path":"images/pic12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/picx03.jpg","path":"images/picx03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/logo_miccall.png","path":"img/logo_miccall.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/sunset.jpg","path":"img/sunset.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery_skel.min.js","path":"js/gallery_skel.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrollex.min.js","path":"js/jquery.scrollex.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrolly.min.js","path":"js/jquery.scrolly.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/mic_gallery.js","path":"js/mic_gallery.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/prism.js","path":"js/prism.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/skel.min.js","path":"js/skel.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/arrow-small.svg","path":"css/images/arrow-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/arrow.svg","path":"css/images/arrow.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close-small-alt.svg","path":"css/images/close-small-alt.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close-small.svg","path":"css/images/close-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close.svg","path":"css/images/close.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/open-small.svg","path":"css/images/open-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/open.svg","path":"css/images/open.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/spinner.svg","path":"css/images/spinner.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/01.jpg","path":"images/fulls/01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/02.jpg","path":"images/fulls/02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/03.jpg","path":"images/fulls/03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/04.jpg","path":"images/fulls/04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/05.jpg","path":"images/fulls/05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/06.jpg","path":"images/fulls/06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/07.jpg","path":"images/fulls/07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/08.jpg","path":"images/fulls/08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/09.jpg","path":"images/fulls/09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/10.jpg","path":"images/fulls/10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/11.jpg","path":"images/fulls/11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/12.jpg","path":"images/fulls/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/01.jpg","path":"images/thumbs/01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/02.jpg","path":"images/thumbs/02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/03.jpg","path":"images/thumbs/03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/04.jpg","path":"images/thumbs/04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/05.jpg","path":"images/thumbs/05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/06.jpg","path":"images/thumbs/06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/07.jpg","path":"images/thumbs/07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/08.jpg","path":"images/thumbs/08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/09.jpg","path":"images/thumbs/09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/10.jpg","path":"images/thumbs/10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/11.jpg","path":"images/thumbs/11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/12.jpg","path":"images/thumbs/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/libs/codeBlock/codeBLang.js","path":"libs/codeBlock/codeBLang.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/libs/codeBlock/codeBlockFiction.js","path":"libs/codeBlock/codeBlockFiction.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/miccall/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1540215856000},{"_id":"themes/miccall/readme.md","hash":"ee36b0cb76c688ed9fa8990eee5c49d5f2b53525","modified":1540215856000},{"_id":"themes/miccall/layout/layout.ejs","hash":"41bd4dce5bebc122b09908c8336f404dca9db9ab","modified":1540215856000},{"_id":"themes/miccall/layout/post.ejs","hash":"d3c06743dfd9c137b8953e927d80d0099f169034","modified":1540215856000},{"_id":"themes/miccall/source/.DS_Store","hash":"d41550088a3524607dec4b4cb67815d86dea551a","modified":1627712980562},{"_id":"themes/miccall/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/copyright.ejs","hash":"03f20eb5997f7132c232393b203fbca6eaec5205","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/footer.ejs","hash":"003361014b1467ce8062557c6c5952abaa9f00aa","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/gallery_head.ejs","hash":"4bd6fb2bdf51a21b7c5b4e95b0575f7e6ac3dcd1","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/gallery_js.ejs","hash":"2d4bf4e503f72f50e61fba396386dc7d57d3165f","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/head.ejs","hash":"de0a31f65a5efe69ffb04511c18b23c0c94f653a","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/headerlogo.ejs","hash":"e9ba05cce80d7f93ba11a9ef5c8a12e958f996f2","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/importJS.ejs","hash":"31d45544f38d8016351f95f9ab5a2486c17a3acc","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/intro.ejs","hash":"f1e136f0e6ede50d5ce5a3abbc14db63a92c04d3","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/mainfirst.ejs","hash":"ea4fc5b7083f655aaf850e24bad811f5f98f6506","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/mathjax.ejs","hash":"f98a7f202cc7645e42991c5ca75a791890160986","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/nav.ejs","hash":"05a44ee21f99b2ae8b99d924db6f1a2aa3e1e393","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/page-gallery.ejs","hash":"7d89025675f7f59395a888577e248f394f72c03c","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/page-links.ejs","hash":"bfe157e5e9f534cc40475b0470888d251fcc6f44","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/page-tagcloud.ejs","hash":"bdd2cca14c209462c2b894de2563be5a2c6c5599","modified":1540215856000},{"_id":"themes/miccall/source/css/backcss.css","hash":"65db154a14ccb0e773a14e1d1262553e6f30aec5","modified":1540215856000},{"_id":"themes/miccall/source/css/demo.css","hash":"99b020fe28a276c2b128a5048ab1325fc3303b96","modified":1540215856000},{"_id":"themes/miccall/source/css/dropdownMenu.css","hash":"3e44ce25f19c28dcf2c12db1938ccce7a081c10f","modified":1540215856000},{"_id":"themes/miccall/source/css/font-awesome.min.css","hash":"03eb0a6b53db2655f3ded9bb1a4e4af07cc1efa6","modified":1540215856000},{"_id":"themes/miccall/source/css/gallery.css","hash":"4c0178ea898cdc5e010346b56d1c9845fe8da53e","modified":1540215856000},{"_id":"themes/miccall/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1540215856000},{"_id":"themes/miccall/source/css/item.css","hash":"da1277164b611ccba56beda47960f9075c61dbab","modified":1540215856000},{"_id":"themes/miccall/source/css/mic_gallery.css","hash":"5c75b8ab2670599538a1250957cf7c44d0e4cbec","modified":1540215856000},{"_id":"themes/miccall/source/css/my_link.css","hash":"c9535592792f2271df88c39e4baf8c849e23db17","modified":1540215856000},{"_id":"themes/miccall/source/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1540215856000},{"_id":"themes/miccall/source/css/noscript.css","hash":"5579ccdecc63139609db824704331d8d4af61538","modified":1540215856000},{"_id":"themes/miccall/source/css/ok_prism.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1540215856000},{"_id":"themes/miccall/source/css/prism.css","hash":"b39768264f9923a770bcc3f289be0a2bd8e64268","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_coy.css","hash":"24ebf5f3e5f68341522204dcaaf33f429d3c3718","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_dark.css","hash":"8085542cdb4583ffb78b2edd146ebe9511bf668c","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_default.css","hash":"3600bee175b309662e306b50e494ac73495619c2","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_funky.css","hash":"aa0e3a37fb8ccce44457d7805a13d7c6094d1f5e","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_okaidia.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_solarized.css","hash":"73759f72dc43870aaf76dca7ef4e61a142b6b4f0","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_twilight.css","hash":"17498435f6d964243c1a50deb563e6003aebe0e6","modified":1540215856000},{"_id":"themes/miccall/source/css/typo.css","hash":"768004dae4204dfbda865d412229feaa618ec3b7","modified":1540215856000},{"_id":"themes/miccall/source/images/.DS_Store","hash":"73967c1ad3c674ada67ab12705793a1a13250de8","modified":1628840950346},{"_id":"themes/miccall/source/images/12.jpg","hash":"88d68b169744a76ca7b21a258fc0812bc03ee701","modified":1540215856000},{"_id":"themes/miccall/source/images/3123.jpg","hash":"fc005184ff616231647c5dc85c63167040d810ba","modified":1540215856000},{"_id":"themes/miccall/source/images/me.jpg","hash":"b520aa4d797fc0794d93104f260d18a523b67522","modified":1540215856000},{"_id":"themes/miccall/source/images/overlay.png","hash":"e978d81201508e6fcbe0fe95485dae1a4b983a8d","modified":1540215856000},{"_id":"themes/miccall/source/images/pic01.jpg","hash":"774db644cdac607e0d9d72ca65a4961f9a250c11","modified":1540215856000},{"_id":"themes/miccall/source/images/pic02.jpg","hash":"ab77495fef5102f94e36b71d4308cd682dd4b1a8","modified":1540215856000},{"_id":"themes/miccall/source/images/pic03.jpg","hash":"ec46b8b1490a794ea5d4c61058959b9a52ac262f","modified":1540215856000},{"_id":"themes/miccall/source/images/pic04.jpg","hash":"ee299cd40108e50d7151333de525049f8ec4f150","modified":1540215856000},{"_id":"themes/miccall/source/images/pic05.jpg","hash":"b74d638c0aa9e90f94b056db4c0a886e382973f1","modified":1540215856000},{"_id":"themes/miccall/source/images/pic06.jpg","hash":"3d8572663edf8a77b99bdfd93491d4f6a7298aaf","modified":1540215856000},{"_id":"themes/miccall/source/images/pic07.jpg","hash":"de06b4eee3d0e42ddcac415adc8c83466f430253","modified":1540215856000},{"_id":"themes/miccall/source/images/pic08.jpg","hash":"993e8ff91c20b6d28b6302d3a18367547610c58a","modified":1540215856000},{"_id":"themes/miccall/source/images/pic09.jpg","hash":"6aae76e8215e3a6e785ce2a65484e4df03ed5fe9","modified":1540215856000},{"_id":"themes/miccall/source/images/pic10.jpg","hash":"814a661f2966a3c8fe2c89034f62e828f291d770","modified":1540215856000},{"_id":"themes/miccall/source/images/pic11.jpg","hash":"a034beb80041d238f36685706a019a269f159ac1","modified":1540215856000},{"_id":"themes/miccall/source/images/pic12.jpg","hash":"ae93f2674a3b1f1dcbfe9692f2e172e106c02d96","modified":1540215856000},{"_id":"themes/miccall/source/images/picx03.jpg","hash":"cffaa38c9489f131f6f37763b37b937811b316df","modified":1540215856000},{"_id":"themes/miccall/source/js/gallery_skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1540215856000},{"_id":"themes/miccall/source/js/jquery.scrollex.min.js","hash":"57fa1d1de2eca4fabbe75d6d160edc45cc398075","modified":1540215856000},{"_id":"themes/miccall/source/js/jquery.scrolly.min.js","hash":"6807fda8e44d95117e7007563a4db951818df82b","modified":1540215856000},{"_id":"themes/miccall/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1540215856000},{"_id":"themes/miccall/source/js/main.js","hash":"509935fbbf5896ee1e8f2047e961dd58894ae74d","modified":1540215856000},{"_id":"themes/miccall/source/js/mic_gallery.js","hash":"9f5d540f90fcef501df7a9f8272203d1604cd507","modified":1540215856000},{"_id":"themes/miccall/source/js/skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1540215856000},{"_id":"themes/miccall/source/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1540215856000},{"_id":"themes/miccall/source/css/images/arrow-small.svg","hash":"f00360be7c8c06c0ab9d008b3485429cd07b8621","modified":1540215856000},{"_id":"themes/miccall/source/css/images/arrow.svg","hash":"84ad7a183fce70ac31766748919292d9db68c3c8","modified":1540215856000},{"_id":"themes/miccall/source/css/images/close-small-alt.svg","hash":"6b0204bb16fc15963977c3921d631209afff8180","modified":1540215856000},{"_id":"themes/miccall/source/css/images/close-small.svg","hash":"23e81571a4e597278e80a593c9e82a0f03d9d167","modified":1540215856000},{"_id":"themes/miccall/source/css/images/close.svg","hash":"7e524252c4610461102bf6da4b41eaa60845b642","modified":1540215856000},{"_id":"themes/miccall/source/css/images/open-small.svg","hash":"7ee24df085722b308c03d3b827fd0769a63e49f2","modified":1540215856000},{"_id":"themes/miccall/source/css/images/open.svg","hash":"f376adaf38d3fc3a2a0209e560a7d181105c75a6","modified":1540215856000},{"_id":"themes/miccall/source/css/images/spinner.svg","hash":"7ef1bb9afa8be7be3509ba644c990b23f5876863","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/01.jpg","hash":"cfc928948301b97ab2873e837284cd83cc3c6cff","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/02.jpg","hash":"1a729f597316a7483ebcf39b5984ced1612a0410","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/03.jpg","hash":"0f8c8109f8b605aa46ef571df1d16e8bdd43d090","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/04.jpg","hash":"806679d4c4398335413b6b53941709a4aef7c3cd","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/05.jpg","hash":"232b0b9e3b6e751ebb2e6c4284651639526200e3","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/06.jpg","hash":"e97b29127a50c69cf445d0591cd94daab0f50e33","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/07.jpg","hash":"eb41675450650b613195806b154c6badbb7eca4d","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/08.jpg","hash":"d31c389218f04bc7ec510ac236fbe343048e3cfc","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/09.jpg","hash":"61fab3aa8ceee938efb4965042ce2b5f51d3a584","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/10.jpg","hash":"9a284568752a54ab9e8e9cd19c41750e05975d2a","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/11.jpg","hash":"cff6219163e3154c1263ee1d7f924c0ae3ccc9e7","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/12.jpg","hash":"a631491537584e2e23926d9d6f50ce60bb884b18","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/01.jpg","hash":"4f5a2b9fdf44146d60f8dd3a32c81a8419b9148f","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/02.jpg","hash":"396a422cbc1b94b6c9b00f6a34c02b05913230ba","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/03.jpg","hash":"e3915b1cc3283b5ec33f49e2591ebf2e6be2362e","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/04.jpg","hash":"3c60445217b1b52b1fd6cae4578356c564d7624d","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/05.jpg","hash":"3e28c2253db93ba42d16ba9a1f451dbc452fd947","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/06.jpg","hash":"ffc80bb5fe28626d9462e06d9f01d2a5f99b0ae9","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/07.jpg","hash":"45194a98089345e4f135c0f0bfffeee7ccdd9c99","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/08.jpg","hash":"e0384120f6acfa64ad0b5bd0d7e114e9f239294e","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/09.jpg","hash":"bc8a02decf65e44657f02dcc11c7395bfa41ffdb","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/10.jpg","hash":"ccfee49fbca187bad971336cb8fda7dec05ab01e","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/11.jpg","hash":"66a7fb237824b1b2fd550a068bb6a32f5031ab8f","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/12.jpg","hash":"17ab685447ed06b6c12e4d42f38111c684221bc7","modified":1540215856000},{"_id":"themes/miccall/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1540215856000},{"_id":"themes/miccall/source/libs/codeBlock/clipboard.min.js","hash":"db6ad2a5c5ec85622a255e96821f398247aeccb8","modified":1627796723846},{"_id":"themes/miccall/source/libs/codeBlock/codeBLang.js","hash":"77c50c8b48ebe54e5d0c2dde30df2d9cd33d603c","modified":1627796665852},{"_id":"themes/miccall/source/libs/codeBlock/codeBlockFiction.js","hash":"06c7e13d32620cf0ca363dc5687141038befd4e3","modified":1627796634992},{"_id":"themes/miccall/source/libs/codeBlock/codeCopy.js","hash":"9825bcc7e38cf1f2ad334afcaf6953720b8170d2","modified":1627796691571},{"_id":"themes/miccall/source/libs/codeBlock/codeShrink.js","hash":"077800987c360c0bddaa816ecef94af7e2c38a11","modified":1627796819703},{"_id":"themes/miccall/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus/enter.ejs","hash":"ecde1e8e072cd6ec5b69287186c3551d246feb78","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus/main.ejs","hash":"e545ec7bab21e2d345e058ed438e2031e3e1f353","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/main.ejs","hash":"afc734b693b98128f0c45e70b4ecb5702b482829","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/valine/enter.ejs","hash":"0f1c274517b7d9008adbafdf456bbd24a615ffd3","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/valine/main.ejs","hash":"5f026c923ed86a46fd87086deff2ee2a9d13a8f5","modified":1540215856000},{"_id":"themes/miccall/source/css/mic_main.css","hash":"152cca3d857f0184a99d1e8ac54dcb1d19945b3e","modified":1627796904578},{"_id":"themes/miccall/source/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1540215856000},{"_id":"themes/miccall/source/images/WechatIMG501.jpeg","hash":"14a43a6c89875e65e2ee2bf3fb2a2bbdb2bb1b3e","modified":1627708307457},{"_id":"themes/miccall/source/images/logo.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1540215856000},{"_id":"themes/miccall/source/img/logo_miccall.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1540215856000},{"_id":"themes/miccall/source/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1540215856000},{"_id":"source/.DS_Store","hash":"bfd5b955b3d5111a9bbbdc8bf93427c567d6487e","modified":1629269349432},{"_id":"source/Java/index.md","hash":"14e376b465c1c78ea1ea7084ba350b79252b6fc8","modified":1627711294152},{"_id":"source/ustc/index.md","hash":"6d860b6bf398e5f7120c1835fbb64325bbcab175","modified":1627789600476},{"_id":"source/个人生活/index.md","hash":"372542fd39d43ce02c2ac6ee917b78d8b769fd37","modified":1627789548366},{"_id":"source/_posts/.DS_Store","hash":"d58767d5391afdfda1b7c164a86046ff88c8975d","modified":1629339124699},{"_id":"source/_posts/7月29日.md","hash":"1fdad322c292255e5b8140d93a410584ca651c24","modified":1627871826172},{"_id":"themes/miccall/_config.yml","hash":"77c824f558fc4354fed3baac6ecb112631dcffa4","modified":1627882328720},{"_id":"themes/miccall/layout/index.ejs","hash":"5c30b6c5881ca01a6733c02a001f17ec9a15f65a","modified":1628150102770},{"_id":"themes/miccall/.DS_Store","hash":"5b1f36d9077eacd91efac40b500ea41ad56483d3","modified":1627712989325},{"_id":"source/_posts/7月30日.md","hash":"9b83f881eceb2956d894257d1cd5f1d6ce9943b2","modified":1627871892367},{"_id":"source/_posts/8月11日.md","hash":"0e39eb39496b90b3252e6c1287777d44effcc07a","modified":1628665001299},{"_id":"source/_posts/8月10日.md","hash":"067773e09d8e711f5c378991fd0e8a594eb54206","modified":1628590557879},{"_id":"source/_posts/7月31号.md","hash":"e199866c012edac10c58dd8ee8d362b222bff2d7","modified":1627958294448},{"_id":"source/_posts/8月16-周二-天气晴.md","hash":"fb75f0b37206b785671a455b76c34af872b057b3","modified":1629251984798},{"_id":"source/_posts/8月19日.md","hash":"589f1cf67ac5577101ff58b0ea2d3d4904f28888","modified":1629444056915},{"_id":"source/_posts/8月13日.md","hash":"924f84b13baa62d74d91ad0b4735418648f69c08","modified":1629092748677},{"_id":"source/_posts/8月14.md","hash":"67a6f2218ac1d32fc3be5bf33cdcabb2815d6e17","modified":1629188210884},{"_id":"source/_posts/8月2日.md","hash":"6f195187796f3a9ba22095f82594a5be6e3fd735","modified":1627906124490},{"_id":"source/_posts/8月17日.md","hash":"65cb2e624289eba58909b51c2d289f5a3ce50206","modified":1629278797017},{"_id":"source/_posts/8月3日.md","hash":"10c826cbd2485b97ab83658a1a9ecff808b3c74f","modified":1628127288850},{"_id":"source/_posts/8月5日.md","hash":"0aef839876c92fd6c2a63abb8db70211c2cd7f35","modified":1628164136833},{"_id":"source/_posts/8月4日.md","hash":"90a445557d33f378d74fb52d056cc20d017382a0","modified":1628091983926},{"_id":"source/_posts/8月9日.md","hash":"51dfb964cb1a871fafdc53a7384cd894e31d871b","modified":1628513357368},{"_id":"source/_posts/8月7日.md","hash":"c19ee612f737a6a2b0e426859abacb37555a2006","modified":1628489860378},{"_id":"source/_posts/8月6日.md","hash":"c35c27ee0a4f486a4c12450c7c12641effcb2b6b","modified":1628417265757},{"_id":"source/_posts/元连接查询处理.md","hash":"4ee092acf3f8466e678d5f1519a0a2d151b4c842","modified":1629248579370},{"_id":"source/_posts/谢希科老师数据库前沿课的论文pre.md","hash":"f1217d4a9abef5e7190bdeddc74a2346897691f6","modified":1629248579360},{"_id":"source/about/index.md","hash":"9a8cf8854a38e7858cb871b7e369972a8ca97183","modified":1627791750140},{"_id":"source/group/index.md","hash":"9c1f9b0d6c173d9e152dfc42fddda9fec5d11e89","modified":1627709182916},{"_id":"source/_posts/周末的上海.md","hash":"32c2318aedd03c57710109481194f0a04c23d6da","modified":1627954248543},{"_id":"source/_posts/盘点我从无到有搭建一个Springboot遇到的坑.md","hash":"6f9758b76ac1dd3407de86afba578d65266d27e1","modified":1628416942231},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1540215856000},{"_id":"themes/miccall/source/images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","hash":"06177cb664fe001b2a23e8c90a8b0c183e49ad03","modified":1627710679412},{"_id":"themes/miccall/source/img/avatar.png","hash":"41e4190dab86b5ccdf79880b87536a301938d5a0","modified":1627455295608},{"_id":"source/_posts/谢希科老师数据库前沿课的论文pre/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg","hash":"af13154cabfdb1535dba68758ead59d30771bde0","modified":1629248579303},{"_id":"themes/miccall/source/js/prism.js","hash":"0868d642f4661649a37dfb45b93fa30b4d92d4e4","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1540215856000},{"_id":"source/_posts/img.png","hash":"d80c5d3efa16b8c0e3e4c69bdcc24030f6782310","modified":1627709792150},{"_id":"themes/miccall/source/fonts/FZLT.ttf","hash":"24dfab81236612d596c97eb38b3adf5de99f669c","modified":1540215856000},{"_id":"source/ustc/sprinter-快速n元连接处理.pdf","hash":"54d976db568a5346b4cc19f7fee43b13f5b3e0ee","modified":1628418893398},{"_id":"themes/miccall/source/img/sunset.jpg","hash":"6269f3b31fa709eec3430686e72ecde461e231ca","modified":1627710472313},{"_id":"themes/miccall/source/images/21.jpg","hash":"0b2570df0e6d9b79a0c50d0b4ce8799bd40ea421","modified":1540215856000},{"_id":"themes/miccall/source/img/bg.jpg","hash":"af7fe6067d0c21f558502613eed86d8246000bba","modified":1540215856000},{"_id":"public/Java/index.html","hash":"467c56d3a7d1fafe49be749be56b44e5b001ffeb","modified":1629339431758},{"_id":"public/ustc/index.html","hash":"abe5a49a0de71e8a94f7d92e14868454720aa5d3","modified":1629339431758},{"_id":"public/个人生活/index.html","hash":"e683454a98c3a1b1515bd61ef71473bda5d0ba06","modified":1629339431758},{"_id":"public/group/index.html","hash":"33548683d4fb1fb442de196900db4c250a10e23a","modified":1629339431758},{"_id":"public/about/index.html","hash":"24bdc2a13a5562a5365e358619d0db4460015c0c","modified":1629339431758},{"_id":"public/2021/08/19/8月19日/index.html","hash":"84a0946a35a3a61ee6648c2d308b6434a5219346","modified":1629774061071},{"_id":"public/2021/08/18/8月17日/index.html","hash":"07ec890dd4f502deb322e78d161ceca500aff7c5","modified":1629339431758},{"_id":"public/2021/08/17/8月16-周二-天气晴/index.html","hash":"0761be9b1504cd22ae94a99087a6f57e2d197196","modified":1629339431758},{"_id":"public/2021/08/14/8月14/index.html","hash":"6dc6ee969ebdef3bbf6680548628e2f14cbd6fda","modified":1629339431758},{"_id":"public/2021/08/13/8月13日/index.html","hash":"9a921f43fa7d226385bb0a792576ebbdb4ed7218","modified":1629339431758},{"_id":"public/2021/08/11/8月11日/index.html","hash":"5dd6b1b455f35ee8263d1959991780890ccb398a","modified":1629339431758},{"_id":"public/2021/08/10/8月10日/index.html","hash":"c56dbd737795235bc0d48aa5191a9709858241d2","modified":1629339431758},{"_id":"public/2021/08/09/8月9日/index.html","hash":"7231745145eebed29a21b18344748ab1503c7bd3","modified":1629339431758},{"_id":"public/2021/08/07/8月7日/index.html","hash":"e5cb34f95ab7eb984ac5152b7f9350d053dd179b","modified":1629339431758},{"_id":"public/2021/08/05/8月5日/index.html","hash":"ce62f4b8913ab246e1d7181a1502139b5aecc338","modified":1629339431758},{"_id":"public/2021/08/03/8月3日/index.html","hash":"a546db15d3db01eee6e046ec9a2e9a61e44b86eb","modified":1629339431758},{"_id":"public/2021/08/01/周末的上海/index.html","hash":"d8052f9630edf3eb9b9cda65ccaf949af5250d68","modified":1629339431758},{"_id":"public/2021/07/30/7月30日/index.html","hash":"48a65afec58281ca48b1ecf3ac24b38c068fc7b3","modified":1629339431758},{"_id":"public/archives/page/3/index.html","hash":"2cbc58fc2580d4078b1ecb2089d74fb7257bb4ee","modified":1630167052335},{"_id":"public/archives/2021/page/3/index.html","hash":"fe38808b5237f313abf80cf9e6ac9610dd56b1b7","modified":1630167052335},{"_id":"public/archives/2021/08/page/2/index.html","hash":"6962131b4e1c9a1878741fb0280cdc919ef00f13","modified":1630167052335},{"_id":"public/page/3/index.html","hash":"0e1803d1e97eda0221ab8175d13ed88ec713c7e5","modified":1630167052335},{"_id":"public/categories/Spring-Boot/index.html","hash":"9ab11d1eeedb9a2aa18391aac4973b3e24b5a44e","modified":1629339431758},{"_id":"public/categories/工作日志/index.html","hash":"726797e45db5b098d33eadc1f5c9dd6281360a65","modified":1629339431758},{"_id":"public/categories/Spring-Boot/工作日志/index.html","hash":"13107926ec538856a84936adc1288f505662a308","modified":1629339431758},{"_id":"public/categories/个人生活/index.html","hash":"f1ec6da550f8d96e26d7869b35174e0704e8a342","modified":1629339431758},{"_id":"public/categories/ustc/index.html","hash":"c5d865f54f9328801f40a9c88fa7d10eeb03bf30","modified":1629339431758},{"_id":"public/categories/ustc/个人生活/index.html","hash":"ff25a04533754a6ae034aa79974f9e7315fd4f09","modified":1629339431758},{"_id":"public/tags/java/index.html","hash":"3ae5503ce684081acb566270dbf3664489b4cff7","modified":1629339431758},{"_id":"public/tags/框架/index.html","hash":"3ae5503ce684081acb566270dbf3664489b4cff7","modified":1629339431758},{"_id":"public/2021/08/06/8月6日/index.html","hash":"f16e18e16ad2cf403556db245fbeffd1412175d2","modified":1629339431758},{"_id":"public/2021/08/04/8月4日/index.html","hash":"6b776b3d1a868e7effbf16cc084e6a5c7a0c89e8","modified":1629339431758},{"_id":"public/2021/08/02/8月2日/index.html","hash":"26463e4fd2ce8d7d24da15c1dff301f314cfca84","modified":1629339431758},{"_id":"public/2021/07/31/元连接查询处理/index.html","hash":"402d502cbd5cd563b95d4a8058acd529beb35d42","modified":1629339431758},{"_id":"public/2021/07/31/谢希科老师数据库前沿课的论文pre/index.html","hash":"b72cb620408869eeffba7d8461373ce38eaa322b","modified":1629339431758},{"_id":"public/2021/07/31/盘点我从无到有搭建一个Springboot遇到的坑/index.html","hash":"21ad9b5b40be3fab617ee573d42719324c7a3616","modified":1629339431758},{"_id":"public/2021/07/31/7月31号/index.html","hash":"a523ea11ab8ba3c3b862b232f3182a697786f529","modified":1629339431758},{"_id":"public/2021/07/29/7月29日/index.html","hash":"3037c51db9f1912f17b3cbcb1147c604090e98ca","modified":1629339431758},{"_id":"public/archives/index.html","hash":"2e46f083a8aa755fa302d3b5c7ac2040e400cff3","modified":1630167052335},{"_id":"public/archives/page/2/index.html","hash":"3f0753104e16dfbf8421056e0c1154872201efe4","modified":1630167052335},{"_id":"public/archives/2021/index.html","hash":"0d00fa1f684a54b64dc26d86c3cec279d3487567","modified":1630167052335},{"_id":"public/archives/2021/page/2/index.html","hash":"69a335e760038f9291ee0f44f29b8e9f684f1067","modified":1630167052335},{"_id":"public/archives/2021/07/index.html","hash":"86ff4c048562d510284ac0d3fac0ef61ae4583fb","modified":1629339431758},{"_id":"public/archives/2021/08/index.html","hash":"3e96e04c9dfd234181e0ecea6014e79ef0abf932","modified":1630167052335},{"_id":"public/index.html","hash":"afec4afa1f2ed2ae6827af894bc0a858459abe61","modified":1630167052335},{"_id":"public/page/2/index.html","hash":"331d0ceeb47b2b7bf5634bc3b23aad444897d180","modified":1630167052335},{"_id":"public/images/12.jpg","hash":"88d68b169744a76ca7b21a258fc0812bc03ee701","modified":1629339431758},{"_id":"public/images/3123.jpg","hash":"fc005184ff616231647c5dc85c63167040d810ba","modified":1629339431758},{"_id":"public/images/me.jpg","hash":"b520aa4d797fc0794d93104f260d18a523b67522","modified":1629339431758},{"_id":"public/images/overlay.png","hash":"e978d81201508e6fcbe0fe95485dae1a4b983a8d","modified":1629339431758},{"_id":"public/images/pic01.jpg","hash":"774db644cdac607e0d9d72ca65a4961f9a250c11","modified":1629339431758},{"_id":"public/images/pic02.jpg","hash":"ab77495fef5102f94e36b71d4308cd682dd4b1a8","modified":1629339431758},{"_id":"public/images/pic03.jpg","hash":"ec46b8b1490a794ea5d4c61058959b9a52ac262f","modified":1629339431758},{"_id":"public/images/pic04.jpg","hash":"ee299cd40108e50d7151333de525049f8ec4f150","modified":1629339431758},{"_id":"public/images/pic05.jpg","hash":"b74d638c0aa9e90f94b056db4c0a886e382973f1","modified":1629339431758},{"_id":"public/images/pic06.jpg","hash":"3d8572663edf8a77b99bdfd93491d4f6a7298aaf","modified":1629339431758},{"_id":"public/images/pic07.jpg","hash":"de06b4eee3d0e42ddcac415adc8c83466f430253","modified":1629339431758},{"_id":"public/images/pic08.jpg","hash":"993e8ff91c20b6d28b6302d3a18367547610c58a","modified":1629339431758},{"_id":"public/images/pic09.jpg","hash":"6aae76e8215e3a6e785ce2a65484e4df03ed5fe9","modified":1629339431758},{"_id":"public/images/pic10.jpg","hash":"814a661f2966a3c8fe2c89034f62e828f291d770","modified":1629339431758},{"_id":"public/images/pic11.jpg","hash":"a034beb80041d238f36685706a019a269f159ac1","modified":1629339431758},{"_id":"public/images/pic12.jpg","hash":"ae93f2674a3b1f1dcbfe9692f2e172e106c02d96","modified":1629339431758},{"_id":"public/images/picx03.jpg","hash":"cffaa38c9489f131f6f37763b37b937811b316df","modified":1629339431758},{"_id":"public/css/images/arrow-small.svg","hash":"f00360be7c8c06c0ab9d008b3485429cd07b8621","modified":1629339431758},{"_id":"public/css/images/arrow.svg","hash":"84ad7a183fce70ac31766748919292d9db68c3c8","modified":1629339431758},{"_id":"public/css/images/close-small-alt.svg","hash":"6b0204bb16fc15963977c3921d631209afff8180","modified":1629339431758},{"_id":"public/css/images/close-small.svg","hash":"23e81571a4e597278e80a593c9e82a0f03d9d167","modified":1629339431758},{"_id":"public/css/images/close.svg","hash":"7e524252c4610461102bf6da4b41eaa60845b642","modified":1629339431758},{"_id":"public/css/images/open-small.svg","hash":"7ee24df085722b308c03d3b827fd0769a63e49f2","modified":1629339431758},{"_id":"public/css/images/open.svg","hash":"f376adaf38d3fc3a2a0209e560a7d181105c75a6","modified":1629339431758},{"_id":"public/css/images/spinner.svg","hash":"7ef1bb9afa8be7be3509ba644c990b23f5876863","modified":1629339431758},{"_id":"public/images/fulls/01.jpg","hash":"cfc928948301b97ab2873e837284cd83cc3c6cff","modified":1629339431758},{"_id":"public/images/fulls/02.jpg","hash":"1a729f597316a7483ebcf39b5984ced1612a0410","modified":1629339431758},{"_id":"public/images/fulls/03.jpg","hash":"0f8c8109f8b605aa46ef571df1d16e8bdd43d090","modified":1629339431758},{"_id":"public/images/fulls/04.jpg","hash":"806679d4c4398335413b6b53941709a4aef7c3cd","modified":1629339431758},{"_id":"public/images/fulls/05.jpg","hash":"232b0b9e3b6e751ebb2e6c4284651639526200e3","modified":1629339431758},{"_id":"public/images/fulls/06.jpg","hash":"e97b29127a50c69cf445d0591cd94daab0f50e33","modified":1629339431758},{"_id":"public/images/fulls/07.jpg","hash":"eb41675450650b613195806b154c6badbb7eca4d","modified":1629339431758},{"_id":"public/images/fulls/08.jpg","hash":"d31c389218f04bc7ec510ac236fbe343048e3cfc","modified":1629339431758},{"_id":"public/images/fulls/09.jpg","hash":"61fab3aa8ceee938efb4965042ce2b5f51d3a584","modified":1629339431758},{"_id":"public/images/fulls/10.jpg","hash":"9a284568752a54ab9e8e9cd19c41750e05975d2a","modified":1629339431758},{"_id":"public/images/fulls/11.jpg","hash":"cff6219163e3154c1263ee1d7f924c0ae3ccc9e7","modified":1629339431758},{"_id":"public/images/fulls/12.jpg","hash":"a631491537584e2e23926d9d6f50ce60bb884b18","modified":1629339431758},{"_id":"public/images/thumbs/01.jpg","hash":"4f5a2b9fdf44146d60f8dd3a32c81a8419b9148f","modified":1629339431758},{"_id":"public/images/thumbs/02.jpg","hash":"396a422cbc1b94b6c9b00f6a34c02b05913230ba","modified":1629339431758},{"_id":"public/images/thumbs/03.jpg","hash":"e3915b1cc3283b5ec33f49e2591ebf2e6be2362e","modified":1629339431758},{"_id":"public/images/thumbs/04.jpg","hash":"3c60445217b1b52b1fd6cae4578356c564d7624d","modified":1629339431758},{"_id":"public/images/thumbs/05.jpg","hash":"3e28c2253db93ba42d16ba9a1f451dbc452fd947","modified":1629339431758},{"_id":"public/images/thumbs/06.jpg","hash":"ffc80bb5fe28626d9462e06d9f01d2a5f99b0ae9","modified":1629339431758},{"_id":"public/images/thumbs/07.jpg","hash":"45194a98089345e4f135c0f0bfffeee7ccdd9c99","modified":1629339431758},{"_id":"public/images/thumbs/08.jpg","hash":"e0384120f6acfa64ad0b5bd0d7e114e9f239294e","modified":1629339431758},{"_id":"public/images/thumbs/09.jpg","hash":"bc8a02decf65e44657f02dcc11c7395bfa41ffdb","modified":1629339431758},{"_id":"public/images/thumbs/10.jpg","hash":"ccfee49fbca187bad971336cb8fda7dec05ab01e","modified":1629339431758},{"_id":"public/images/thumbs/11.jpg","hash":"66a7fb237824b1b2fd550a068bb6a32f5031ab8f","modified":1629339431758},{"_id":"public/images/thumbs/12.jpg","hash":"17ab685447ed06b6c12e4d42f38111c684221bc7","modified":1629339431758},{"_id":"public/2021/07/31/谢希科老师数据库前沿课的论文pre/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg","hash":"af13154cabfdb1535dba68758ead59d30771bde0","modified":1629339431758},{"_id":"public/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1629339431758},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1629339431758},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1629339431758},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1629339431758},{"_id":"public/images/WechatIMG501.jpeg","hash":"14a43a6c89875e65e2ee2bf3fb2a2bbdb2bb1b3e","modified":1629339431758},{"_id":"public/images/logo.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1629339431758},{"_id":"public/img/logo_miccall.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1629339431758},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1629339431758},{"_id":"public/images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","hash":"06177cb664fe001b2a23e8c90a8b0c183e49ad03","modified":1629339431758},{"_id":"public/img/avatar.png","hash":"41e4190dab86b5ccdf79880b87536a301938d5a0","modified":1629339431758},{"_id":"public/css/backcss.css","hash":"65db154a14ccb0e773a14e1d1262553e6f30aec5","modified":1629339431758},{"_id":"public/css/demo.css","hash":"99b020fe28a276c2b128a5048ab1325fc3303b96","modified":1629339431758},{"_id":"public/css/dropdownMenu.css","hash":"3e44ce25f19c28dcf2c12db1938ccce7a081c10f","modified":1629339431758},{"_id":"public/css/my_link.css","hash":"c9535592792f2271df88c39e4baf8c849e23db17","modified":1629339431758},{"_id":"public/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1629339431758},{"_id":"public/css/noscript.css","hash":"5579ccdecc63139609db824704331d8d4af61538","modified":1629339431758},{"_id":"public/css/ok_prism.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1629339431758},{"_id":"public/css/prism.css","hash":"b39768264f9923a770bcc3f289be0a2bd8e64268","modified":1629339431758},{"_id":"public/css/prism_coy.css","hash":"24ebf5f3e5f68341522204dcaaf33f429d3c3718","modified":1629339431758},{"_id":"public/css/prism_dark.css","hash":"8085542cdb4583ffb78b2edd146ebe9511bf668c","modified":1629339431758},{"_id":"public/css/prism_default.css","hash":"3600bee175b309662e306b50e494ac73495619c2","modified":1629339431758},{"_id":"public/css/prism_okaidia.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1629339431758},{"_id":"public/css/prism_funky.css","hash":"aa0e3a37fb8ccce44457d7805a13d7c6094d1f5e","modified":1629339431758},{"_id":"public/css/prism_solarized.css","hash":"73759f72dc43870aaf76dca7ef4e61a142b6b4f0","modified":1629339431758},{"_id":"public/css/prism_twilight.css","hash":"17498435f6d964243c1a50deb563e6003aebe0e6","modified":1629339431758},{"_id":"public/css/typo.css","hash":"768004dae4204dfbda865d412229feaa618ec3b7","modified":1629339431758},{"_id":"public/js/gallery_skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1629339431758},{"_id":"public/js/jquery.scrollex.min.js","hash":"57fa1d1de2eca4fabbe75d6d160edc45cc398075","modified":1629339431758},{"_id":"public/js/jquery.scrolly.min.js","hash":"6807fda8e44d95117e7007563a4db951818df82b","modified":1629339431758},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1629339431758},{"_id":"public/js/main.js","hash":"509935fbbf5896ee1e8f2047e961dd58894ae74d","modified":1629339431758},{"_id":"public/js/mic_gallery.js","hash":"9f5d540f90fcef501df7a9f8272203d1604cd507","modified":1629339431758},{"_id":"public/js/skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1629339431758},{"_id":"public/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1629339431758},{"_id":"public/libs/codeBlock/codeBLang.js","hash":"77c50c8b48ebe54e5d0c2dde30df2d9cd33d603c","modified":1629339431758},{"_id":"public/libs/codeBlock/codeBlockFiction.js","hash":"06c7e13d32620cf0ca363dc5687141038befd4e3","modified":1629339431758},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"9825bcc7e38cf1f2ad334afcaf6953720b8170d2","modified":1629339431758},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"077800987c360c0bddaa816ecef94af7e2c38a11","modified":1629339431758},{"_id":"public/css/gallery.css","hash":"4c0178ea898cdc5e010346b56d1c9845fe8da53e","modified":1629339431758},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1629339431758},{"_id":"public/css/item.css","hash":"da1277164b611ccba56beda47960f9075c61dbab","modified":1629339431758},{"_id":"public/css/mic_gallery.css","hash":"5c75b8ab2670599538a1250957cf7c44d0e4cbec","modified":1629339431758},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1629339431758},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"db6ad2a5c5ec85622a255e96821f398247aeccb8","modified":1629339431758},{"_id":"public/css/font-awesome.min.css","hash":"03eb0a6b53db2655f3ded9bb1a4e4af07cc1efa6","modified":1629339431758},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1629339431758},{"_id":"public/img/sunset.jpg","hash":"6269f3b31fa709eec3430686e72ecde461e231ca","modified":1629339431758},{"_id":"public/images/21.jpg","hash":"0b2570df0e6d9b79a0c50d0b4ce8799bd40ea421","modified":1629339431758},{"_id":"public/css/mic_main.css","hash":"152cca3d857f0184a99d1e8ac54dcb1d19945b3e","modified":1629339431758},{"_id":"public/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1629339431758},{"_id":"public/img/bg.jpg","hash":"af7fe6067d0c21f558502613eed86d8246000bba","modified":1629339431758},{"_id":"public/js/prism.js","hash":"0868d642f4661649a37dfb45b93fa30b4d92d4e4","modified":1629339431758},{"_id":"public/ustc/sprinter-快速n元连接处理.pdf","hash":"54d976db568a5346b4cc19f7fee43b13f5b3e0ee","modified":1629339431758},{"_id":"public/fonts/FZLT.ttf","hash":"24dfab81236612d596c97eb38b3adf5de99f669c","modified":1629339431758},{"_id":"source/_posts/8月20日.md","hash":"2bed21e6a253eb2ff9b4f7b7f1f646f79c32bf86","modified":1629722727372},{"_id":"public/2021/08/20/8月20日/index.html","hash":"721a194b71e19a330a9d6d72993af3e17bb27a45","modified":1629774061071},{"_id":"source/_posts/8月21日.md","hash":"45ac03804137aca03939f6826af550c9027cf80e","modified":1629526108160},{"_id":"source/_posts/8月24日.md","hash":"b48f6ceb4dfe901426e1c91bf1c487a027fc0ff6","modified":1629819178344},{"_id":"public/2021/08/24/8月24日/index.html","hash":"9d121d3abcbcd8f8d33631f1c5c55ecd40e2acfc","modified":1629972165395},{"_id":"public/2021/08/21/8月21日/index.html","hash":"2959dc2268f02728fce604da70f257e5991bb5a8","modified":1629774061071},{"_id":"source/_posts/8月26日.md","hash":"4880200d5c8d308aaaf6b4daa6afe025579729ee","modified":1629979657563},{"_id":"source/_posts/8月25日.md","hash":"f01733e03dc6fb09e87190b36c6fa3c489d064fc","modified":1629899123098},{"_id":"public/2021/08/26/8月26日/index.html","hash":"047d395cc42b64e2c89b9b096d01aac5f37ad07a","modified":1630035990416},{"_id":"public/2021/08/25/8月25日/index.html","hash":"202d3ea694c016277e8f0a1dfd7dbb55b5d5b11f","modified":1629972165395},{"_id":"source/_posts/数据库调查报告.md","hash":"2b58576fad19ddf0329ad236f3c641d36700b9fe","modified":1630164697277},{"_id":"source/_posts/8月27.md","hash":"eae35c07332aabe0d410861c3aecd93786d18115","modified":1630064819015},{"_id":"public/2021/08/28/数据库调查报告/index.html","hash":"799cef32f6401b24db4526312ff8ae1b1d1273e1","modified":1630167052335},{"_id":"public/2021/08/27/8月27/index.html","hash":"b90c15b7f96d0c25db5a2ed2b780dadb0e134d84","modified":1630167052335},{"_id":"public/archives/2021/08/page/3/index.html","hash":"01b2d64ca04e71fa666d6b06c1445b49865423e3","modified":1630167052335}],"Category":[{"name":"Spring Boot","_id":"cksiamo7v0004c376eucweamp"},{"name":"工作日志","_id":"cksiamo8m000lc376cbknfz6a"},{"name":"工作日志","parent":"cksiamo7v0004c376eucweamp","_id":"cksiamo8o000qc3766vfx401m"},{"name":"个人生活","_id":"cksiamo8z001dc3764uo1ae18"},{"name":"ustc","_id":"cksiamo9c001mc376d9sc535y"},{"name":"个人生活","parent":"cksiamo9c001mc376d9sc535y","_id":"cksiamo9c001nc3765lbvetkk"}],"Data":[],"Page":[{"title":"categories","date":"2021-07-31T06:01:34.000Z","_content":"","source":"Java/index.md","raw":"---\ntitle: categories\ndate: 2021-07-31 14:01:34\n---\n","updated":"2021-07-31T06:01:34.152Z","path":"Java/index.html","comments":1,"layout":"page","_id":"cksiamo7h0000c376d98j6qw7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"ustc","date":"2021-08-01T03:46:40.000Z","_content":"","source":"ustc/index.md","raw":"---\ntitle: ustc\ndate: 2021-08-01 11:46:40\n---\n","updated":"2021-08-01T03:46:40.476Z","path":"ustc/index.html","comments":1,"layout":"page","_id":"cksiamo7p0002c3761bn6f0j8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"个人生活","date":"2021-08-01T03:45:48.000Z","_content":"","source":"个人生活/index.md","raw":"---\ntitle: 个人生活\ndate: 2021-08-01 11:45:48\n---\n","updated":"2021-08-01T03:45:48.366Z","path":"个人生活/index.html","comments":1,"layout":"page","_id":"cksiamo830006c3764scmcz12","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"7月30日","date":"2021-07-30T01:17:39.000Z","tags":null,"thumbnail":"https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg","_content":"","source":"group/index.md","raw":"---\ntitle: 7月30日\ndate: 2021-07-30 09:17:39\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg # 略缩图\n---\n","updated":"2021-07-31T05:26:22.916Z","path":"group/index.html","comments":1,"layout":"page","_id":"cksiamo8c0008c3765i575zj1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"8月1号","date":"2021-07-31T01:26:11.000Z","tags":null,"thumbnail":"https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg","_content":"wzr","source":"about/index.md","raw":"---\ntitle: 8月1号\ndate: 2021-07-31 09:26:11\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg\n---\nwzr","updated":"2021-08-01T04:22:30.140Z","path":"about/index.html","comments":1,"layout":"page","_id":"cksiamo8e000ac376af8ib94b","content":"<p>wzr</p>\n","site":{"data":{}},"excerpt":"","more":"<p>wzr</p>\n"}],"Post":[{"title":"7月29日","date":"2021-07-29T01:46:17.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/mountains-sticking-out-of-inverse-in-a-beautiful-sunrise-light-2210x1243.jpg","_content":"\nhexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同\n\nHero g -d 别忘了\n\n![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe)\n\nAtomicLong是作用是对长整形进行原子操作。\n在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。\n\n首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。\n\nalias 别名\n\ngit绑定仓库的命令\n\n\n\n```shell\ngit init //第一次要先初始化一个git目录\ngit remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）\ngit pull origin master\ngit push -u origin master\n```\n\n\n\nwarning: adding embedded git repository: .deploy_git\n\n当前目录下面有.git文件夹------默认是隐藏的，直接将.git文件夹掉，再重新git add .\n\n\n\n### …or create a new repository on the command line\n\n\n\n```\necho \"# myBlog\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit push -u origin main\n```\n\n### …or push an existing repository from the command line\n\n\n\n```\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit branch -M main\ngit push -u origin main\n```\n\n\n\nFielding将他对互联网软件的架构原则，定名为**REST**，即**Representational State Transfer**的缩写。我对这个词组的翻译是\"表现层状态转化\"。\n\n如果一个架构符合REST原则，就称它为RESTful架构。\n\n**要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。**如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n**三、资源（Resources）**\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。**我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。**\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\n**五、状态转化（State Transfer）**\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：**GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。**\n\n\n\nLog注解\n\n\n\n1. 打开访达,切到应用程序,找到`Pycharm.app`,右键->显示包内容,打开`Contents/MacOS/`\n2. 打开终端,cd 到`Contents/MacOS/`目录,直接将`MacOS`文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.\n3. 执行该文件夹下的`pycharm`文件,即:`./pycharm`,之后可以在终端看到输出的信息, 如果没问题会直接打开 `Pycharm`\n\n解决方法:\n\n1. 在终端cd 到`/Users/{替换成自己的用户名}/Library/Application Support/JetBrains/PyCharm2020.1/`,这个文件夹下有一个`pycharm.vmoptions`的文件,我们需要将这个文件删除.\n2. 终端执行 `rm -f pycharm.vmoptions`\n3. 重新打开即可.\n\n说明：\n `cd 到Application Support时 提示找不到路径的问题`\n 原因：`/Application Support/` 这个地方`Application` 和 `Support` 中间有一个空格，需要转义。\n\n正确的为：\n `cd /Users/{替换成自己的用户名}/Library/Application\\ Support/JetBrains/PyCharm2020.1/`\n\n`/PyCharm2020.1/` 这个路径根据安装版本的不同路径会有所不同。\n\n\n\n安装py3 直接去官网就可以，安装了之后，需要重启pycharm\n\n更新pip3\n\nsudo pip3 install --upgrade pip\n\npylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。\n\n%matplotlib inline。可以注释掉\n\nlambda表达式的语法格式如下：\n\n(parameters) -> expression 或 (parameters) ->{ statements; }\n\n```Java\nhomeApiTotalMapper.toDto(homeApiTotalRepository\n        .findAll((root, criteriaQuery, criteriaBuilder) -> QueryHelp.getPredicate(root, criteria, criteriaBuilder)));\n```\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc)\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc)\n\n\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc)\n\n这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。**而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式**。\n\n但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？\n\n在Java 8里面，**所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。**这是我认为理解Lambda的一个关键所在，简而言之就是，**Lambda表达式本身就是一个接口的实现**。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc)\n\n这种只有**一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。**为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成\"非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc)\n\n这样，我们就得到了一个完整的Lambda表达式声明：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc)\n\n\n\n这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，**我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：**\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc)\n\n","source":"_posts/7月29日.md","raw":"---\ntitle: 7月29日\ndate: 2021-07-29 09:46:17\ncategories: \n- Spring Boot\n- 工作日志\ntags:\n- java\n- 框架\nthumbnail: https://picjumbo.com/wp-content/uploads/mountains-sticking-out-of-inverse-in-a-beautiful-sunrise-light-2210x1243.jpg\n---\n\nhexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同\n\nHero g -d 别忘了\n\n![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe)\n\nAtomicLong是作用是对长整形进行原子操作。\n在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。\n\n首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。\n\nalias 别名\n\ngit绑定仓库的命令\n\n\n\n```shell\ngit init //第一次要先初始化一个git目录\ngit remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）\ngit pull origin master\ngit push -u origin master\n```\n\n\n\nwarning: adding embedded git repository: .deploy_git\n\n当前目录下面有.git文件夹------默认是隐藏的，直接将.git文件夹掉，再重新git add .\n\n\n\n### …or create a new repository on the command line\n\n\n\n```\necho \"# myBlog\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit push -u origin main\n```\n\n### …or push an existing repository from the command line\n\n\n\n```\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit branch -M main\ngit push -u origin main\n```\n\n\n\nFielding将他对互联网软件的架构原则，定名为**REST**，即**Representational State Transfer**的缩写。我对这个词组的翻译是\"表现层状态转化\"。\n\n如果一个架构符合REST原则，就称它为RESTful架构。\n\n**要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。**如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n**三、资源（Resources）**\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。**我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。**\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\n**五、状态转化（State Transfer）**\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：**GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。**\n\n\n\nLog注解\n\n\n\n1. 打开访达,切到应用程序,找到`Pycharm.app`,右键->显示包内容,打开`Contents/MacOS/`\n2. 打开终端,cd 到`Contents/MacOS/`目录,直接将`MacOS`文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.\n3. 执行该文件夹下的`pycharm`文件,即:`./pycharm`,之后可以在终端看到输出的信息, 如果没问题会直接打开 `Pycharm`\n\n解决方法:\n\n1. 在终端cd 到`/Users/{替换成自己的用户名}/Library/Application Support/JetBrains/PyCharm2020.1/`,这个文件夹下有一个`pycharm.vmoptions`的文件,我们需要将这个文件删除.\n2. 终端执行 `rm -f pycharm.vmoptions`\n3. 重新打开即可.\n\n说明：\n `cd 到Application Support时 提示找不到路径的问题`\n 原因：`/Application Support/` 这个地方`Application` 和 `Support` 中间有一个空格，需要转义。\n\n正确的为：\n `cd /Users/{替换成自己的用户名}/Library/Application\\ Support/JetBrains/PyCharm2020.1/`\n\n`/PyCharm2020.1/` 这个路径根据安装版本的不同路径会有所不同。\n\n\n\n安装py3 直接去官网就可以，安装了之后，需要重启pycharm\n\n更新pip3\n\nsudo pip3 install --upgrade pip\n\npylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。\n\n%matplotlib inline。可以注释掉\n\nlambda表达式的语法格式如下：\n\n(parameters) -> expression 或 (parameters) ->{ statements; }\n\n```Java\nhomeApiTotalMapper.toDto(homeApiTotalRepository\n        .findAll((root, criteriaQuery, criteriaBuilder) -> QueryHelp.getPredicate(root, criteria, criteriaBuilder)));\n```\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc)\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc)\n\n\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc)\n\n这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。**而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式**。\n\n但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？\n\n在Java 8里面，**所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。**这是我认为理解Lambda的一个关键所在，简而言之就是，**Lambda表达式本身就是一个接口的实现**。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc)\n\n这种只有**一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。**为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成\"非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc)\n\n这样，我们就得到了一个完整的Lambda表达式声明：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc)\n\n\n\n这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，**我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：**\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc)\n\n","slug":"7月29日","published":1,"updated":"2021-08-02T02:37:06.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo7l0001c376aarfec7b","content":"<p>hexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同</p>\n<p>Hero g -d 别忘了</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe\" alt=\"img\"></p>\n<p>AtomicLong是作用是对长整形进行原子操作。<br>在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。</p>\n<p>首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。</p>\n<p>alias 别名</p>\n<p>git绑定仓库的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init //第一次要先初始化一个git目录</span><br><span class=\"line\">git remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>warning: adding embedded git repository: .deploy_git</p>\n<p>当前目录下面有.git文件夹——默认是隐藏的，直接将.git文件夹掉，再重新git add .</p>\n<h3 id=\"…or-create-a-new-repository-on-the-command-line\"><a href=\"#…or-create-a-new-repository-on-the-command-line\" class=\"headerlink\" title=\"…or create a new repository on the command line\"></a>…or create a new repository on the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;# myBlog&quot; &gt;&gt; README.md</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"…or-push-an-existing-repository-from-the-command-line\"><a href=\"#…or-push-an-existing-repository-from-the-command-line\" class=\"headerlink\" title=\"…or push an existing repository from the command line\"></a>…or push an existing repository from the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Fielding将他对互联网软件的架构原则，定名为<strong>REST</strong>，即<strong>Representational State Transfer</strong>的缩写。我对这个词组的翻译是”表现层状态转化”。</p>\n<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>\n<p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p><strong>三、资源（Resources）</strong></p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p><strong>五、状态转化（State Transfer）</strong></p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>\n<p>Log注解</p>\n<ol>\n<li>打开访达,切到应用程序,找到<code>Pycharm.app</code>,右键-&gt;显示包内容,打开<code>Contents/MacOS/</code></li>\n<li>打开终端,cd 到<code>Contents/MacOS/</code>目录,直接将<code>MacOS</code>文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.</li>\n<li>执行该文件夹下的<code>pycharm</code>文件,即:<code>./pycharm</code>,之后可以在终端看到输出的信息, 如果没问题会直接打开 <code>Pycharm</code></li>\n</ol>\n<p>解决方法:</p>\n<ol>\n<li>在终端cd 到<code>/Users/&#123;替换成自己的用户名&#125;/Library/Application Support/JetBrains/PyCharm2020.1/</code>,这个文件夹下有一个<code>pycharm.vmoptions</code>的文件,我们需要将这个文件删除.</li>\n<li>终端执行 <code>rm -f pycharm.vmoptions</code></li>\n<li>重新打开即可.</li>\n</ol>\n<p>说明：<br> <code>cd 到Application Support时 提示找不到路径的问题</code><br> 原因：<code>/Application Support/</code> 这个地方<code>Application</code> 和 <code>Support</code> 中间有一个空格，需要转义。</p>\n<p>正确的为：<br> <code>cd /Users/&#123;替换成自己的用户名&#125;/Library/Application\\ Support/JetBrains/PyCharm2020.1/</code></p>\n<p><code>/PyCharm2020.1/</code> 这个路径根据安装版本的不同路径会有所不同。</p>\n<p>安装py3 直接去官网就可以，安装了之后，需要重启pycharm</p>\n<p>更新pip3</p>\n<p>sudo pip3 install –upgrade pip</p>\n<p>pylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。</p>\n<p>%matplotlib inline。可以注释掉</p>\n<p>lambda表达式的语法格式如下：</p>\n<p>(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">homeApiTotalMapper.toDto(homeApiTotalRepository</span><br><span class=\"line\">        .findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria, criteriaBuilder)));</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。</p>\n<p>但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？</p>\n<p>在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。</strong>这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc\" alt=\"img\"></p>\n<p>这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。</strong>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就得到了一个完整的Lambda表达式声明：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc\" alt=\"img\"></p>\n<p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>hexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同</p>\n<p>Hero g -d 别忘了</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe\" alt=\"img\"></p>\n<p>AtomicLong是作用是对长整形进行原子操作。<br>在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。</p>\n<p>首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。</p>\n<p>alias 别名</p>\n<p>git绑定仓库的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init //第一次要先初始化一个git目录</span><br><span class=\"line\">git remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>warning: adding embedded git repository: .deploy_git</p>\n<p>当前目录下面有.git文件夹——默认是隐藏的，直接将.git文件夹掉，再重新git add .</p>\n<h3 id=\"…or-create-a-new-repository-on-the-command-line\"><a href=\"#…or-create-a-new-repository-on-the-command-line\" class=\"headerlink\" title=\"…or create a new repository on the command line\"></a>…or create a new repository on the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;# myBlog&quot; &gt;&gt; README.md</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"…or-push-an-existing-repository-from-the-command-line\"><a href=\"#…or-push-an-existing-repository-from-the-command-line\" class=\"headerlink\" title=\"…or push an existing repository from the command line\"></a>…or push an existing repository from the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Fielding将他对互联网软件的架构原则，定名为<strong>REST</strong>，即<strong>Representational State Transfer</strong>的缩写。我对这个词组的翻译是”表现层状态转化”。</p>\n<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>\n<p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p><strong>三、资源（Resources）</strong></p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p><strong>五、状态转化（State Transfer）</strong></p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>\n<p>Log注解</p>\n<ol>\n<li>打开访达,切到应用程序,找到<code>Pycharm.app</code>,右键-&gt;显示包内容,打开<code>Contents/MacOS/</code></li>\n<li>打开终端,cd 到<code>Contents/MacOS/</code>目录,直接将<code>MacOS</code>文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.</li>\n<li>执行该文件夹下的<code>pycharm</code>文件,即:<code>./pycharm</code>,之后可以在终端看到输出的信息, 如果没问题会直接打开 <code>Pycharm</code></li>\n</ol>\n<p>解决方法:</p>\n<ol>\n<li>在终端cd 到<code>/Users/&#123;替换成自己的用户名&#125;/Library/Application Support/JetBrains/PyCharm2020.1/</code>,这个文件夹下有一个<code>pycharm.vmoptions</code>的文件,我们需要将这个文件删除.</li>\n<li>终端执行 <code>rm -f pycharm.vmoptions</code></li>\n<li>重新打开即可.</li>\n</ol>\n<p>说明：<br> <code>cd 到Application Support时 提示找不到路径的问题</code><br> 原因：<code>/Application Support/</code> 这个地方<code>Application</code> 和 <code>Support</code> 中间有一个空格，需要转义。</p>\n<p>正确的为：<br> <code>cd /Users/&#123;替换成自己的用户名&#125;/Library/Application\\ Support/JetBrains/PyCharm2020.1/</code></p>\n<p><code>/PyCharm2020.1/</code> 这个路径根据安装版本的不同路径会有所不同。</p>\n<p>安装py3 直接去官网就可以，安装了之后，需要重启pycharm</p>\n<p>更新pip3</p>\n<p>sudo pip3 install –upgrade pip</p>\n<p>pylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。</p>\n<p>%matplotlib inline。可以注释掉</p>\n<p>lambda表达式的语法格式如下：</p>\n<p>(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">homeApiTotalMapper.toDto(homeApiTotalRepository</span><br><span class=\"line\">        .findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria, criteriaBuilder)));</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。</p>\n<p>但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？</p>\n<p>在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。</strong>这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc\" alt=\"img\"></p>\n<p>这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。</strong>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就得到了一个完整的Lambda表达式声明：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc\" alt=\"img\"></p>\n<p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc\" alt=\"img\"></p>\n"},{"title":"7月30日","date":"2021-07-30T01:17:39.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg","_content":"\n今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。\n\n\n\nJPA写个功能\n\n刚刚写了一个基于JPA的deleteTest，接口的\n\n添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面\n\n```shell\ncd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git\nssh-keygen -t rsa -C 邮件地址\n---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -> New SSH key\n将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功\nssh -T git@github.com # 注意邮箱地址不用改\n如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：\nYou've successfully authenticated, but GitHub does not provide shell access.\n\n\n看到这个信息说明SSH已配置成功！\n此时你还需要配置：\n$ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称 $ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱\n```\n\n接口类创建的对象需要autowire注入\n\n查看Mac是x86还是arm，在终端中输入\n\n```shell\nuname -an\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg)\n\n\n\nspring中注解@Resource 与@Autowire 区别\n@Resource与@Autowired的区别?\n1.@Autowired按byType自动注入。\n\n2.@Resource默认按byName自动注入。\n\n但是@Resource有两个属性是比较重要的，分是name和type；\n\n如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;\n\n3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。\n\nPS：个人建议用@Resource，不为什么，减少与spring的耦合。\n\n**创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。**\n\nTest 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n\n再加上@Test注解，可以在不需要main函数下执行测试类\n\n创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql\n\n\n\n/Users/wuzhenren/Downloads\n\n~/Users/wuzhenren/Downloads/cmake-3.21.1.tar\n\n~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar\n\n\n\nmac的mysql下载好之后，设置环境变量\n\n```shell\ncd /usr/local/mysql/bin\nvim ~/.bash_profile\n保存\nexport PATH=$PATH:/usr/local/mysql/bin\n:wq\n随时可以跑mysql命令\n```\n\n\n\n接下来要重置密码：\n\nmysqladmin -u root -p password ____\n\n\n\n\n\nHero 环境出问题，\n\n```shell\nsudo npm install -g hexo-cli\n\n```\n\n解决。\n\nhexo在添加新文章的时候怎么默认在md文件中添加categories 以及 tags 标签？\n\n在博客的 scaffolds 里有个post.md 添加上需要的配置就行了， 这里是创建post的模板。\n\n分类，直接在categories: -fenleimingcheng\n\n\n\n","source":"_posts/7月30日.md","raw":"---\ntitle: 7月30日\ndate: 2021-07-30 09:17:39\ncategories: \n- Spring Boot\n- 工作日志\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg # 略缩图\n---\n\n今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。\n\n\n\nJPA写个功能\n\n刚刚写了一个基于JPA的deleteTest，接口的\n\n添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面\n\n```shell\ncd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git\nssh-keygen -t rsa -C 邮件地址\n---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -> New SSH key\n将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功\nssh -T git@github.com # 注意邮箱地址不用改\n如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：\nYou've successfully authenticated, but GitHub does not provide shell access.\n\n\n看到这个信息说明SSH已配置成功！\n此时你还需要配置：\n$ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称 $ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱\n```\n\n接口类创建的对象需要autowire注入\n\n查看Mac是x86还是arm，在终端中输入\n\n```shell\nuname -an\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg)\n\n\n\nspring中注解@Resource 与@Autowire 区别\n@Resource与@Autowired的区别?\n1.@Autowired按byType自动注入。\n\n2.@Resource默认按byName自动注入。\n\n但是@Resource有两个属性是比较重要的，分是name和type；\n\n如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;\n\n3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。\n\nPS：个人建议用@Resource，不为什么，减少与spring的耦合。\n\n**创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。**\n\nTest 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n\n再加上@Test注解，可以在不需要main函数下执行测试类\n\n创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql\n\n\n\n/Users/wuzhenren/Downloads\n\n~/Users/wuzhenren/Downloads/cmake-3.21.1.tar\n\n~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar\n\n\n\nmac的mysql下载好之后，设置环境变量\n\n```shell\ncd /usr/local/mysql/bin\nvim ~/.bash_profile\n保存\nexport PATH=$PATH:/usr/local/mysql/bin\n:wq\n随时可以跑mysql命令\n```\n\n\n\n接下来要重置密码：\n\nmysqladmin -u root -p password ____\n\n\n\n\n\nHero 环境出问题，\n\n```shell\nsudo npm install -g hexo-cli\n\n```\n\n解决。\n\nhexo在添加新文章的时候怎么默认在md文件中添加categories 以及 tags 标签？\n\n在博客的 scaffolds 里有个post.md 添加上需要的配置就行了， 这里是创建post的模板。\n\n分类，直接在categories: -fenleimingcheng\n\n\n\n","slug":"7月30日","published":1,"updated":"2021-08-02T02:38:12.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo7q0003c376bam8bwcb","content":"<p>今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。</p>\n<p>JPA写个功能</p>\n<p>刚刚写了一个基于JPA的deleteTest，接口的</p>\n<p>添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git</span><br><span class=\"line\">ssh-keygen -t rsa -C 邮件地址</span><br><span class=\"line\">---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -&gt; New SSH key</span><br><span class=\"line\">将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功</span><br><span class=\"line\">ssh -T git@github.com # 注意邮箱地址不用改</span><br><span class=\"line\">如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</span><br><span class=\"line\">You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">看到这个信息说明SSH已配置成功！</span><br><span class=\"line\">此时你还需要配置：</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git config --global user.name <span class=\"string\">&quot;liuxianan&quot;</span>// 你的github用户名，非昵称 $ git config --global user.email <span class=\"string\">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure>\n\n<p>接口类创建的对象需要autowire注入</p>\n<p>查看Mac是x86还是arm，在终端中输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -an</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg\"></p>\n<p>spring中注解@Resource 与@Autowire 区别<br>@Resource与@Autowired的区别?<br>1.@Autowired按byType自动注入。</p>\n<p>2.@Resource默认按byName自动注入。</p>\n<p>但是@Resource有两个属性是比较重要的，分是name和type；</p>\n<p>如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;</p>\n<p>3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。</p>\n<p>PS：个人建议用@Resource，不为什么，减少与spring的耦合。</p>\n<p><strong>创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。</strong></p>\n<p>Test 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</p>\n<p>再加上@Test注解，可以在不需要main函数下执行测试类</p>\n<p>创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql</p>\n<p>/Users/wuzhenren/Downloads</p>\n<p>~/Users/wuzhenren/Downloads/cmake-3.21.1.tar</p>\n<p>~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar</p>\n<p>mac的mysql下载好之后，设置环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/mysql/bin</span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\">保存</span><br><span class=\"line\">export PATH=$PATH:/usr/local/mysql/bin</span><br><span class=\"line\">:wq</span><br><span class=\"line\">随时可以跑mysql命令</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来要重置密码：</p>\n<p>mysqladmin -u root -p password ____</p>\n<p>Hero 环境出问题，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决。</p>\n<p>hexo在添加新文章的时候怎么默认在md文件中添加categories 以及 tags 标签？</p>\n<p>在博客的 scaffolds 里有个post.md 添加上需要的配置就行了， 这里是创建post的模板。</p>\n<p>分类，直接在categories: -fenleimingcheng</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。</p>\n<p>JPA写个功能</p>\n<p>刚刚写了一个基于JPA的deleteTest，接口的</p>\n<p>添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git</span><br><span class=\"line\">ssh-keygen -t rsa -C 邮件地址</span><br><span class=\"line\">---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -&gt; New SSH key</span><br><span class=\"line\">将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功</span><br><span class=\"line\">ssh -T git@github.com # 注意邮箱地址不用改</span><br><span class=\"line\">如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</span><br><span class=\"line\">You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">看到这个信息说明SSH已配置成功！</span><br><span class=\"line\">此时你还需要配置：</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git config --global user.name <span class=\"string\">&quot;liuxianan&quot;</span>// 你的github用户名，非昵称 $ git config --global user.email <span class=\"string\">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure>\n\n<p>接口类创建的对象需要autowire注入</p>\n<p>查看Mac是x86还是arm，在终端中输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -an</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg\"></p>\n<p>spring中注解@Resource 与@Autowire 区别<br>@Resource与@Autowired的区别?<br>1.@Autowired按byType自动注入。</p>\n<p>2.@Resource默认按byName自动注入。</p>\n<p>但是@Resource有两个属性是比较重要的，分是name和type；</p>\n<p>如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;</p>\n<p>3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。</p>\n<p>PS：个人建议用@Resource，不为什么，减少与spring的耦合。</p>\n<p><strong>创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。</strong></p>\n<p>Test 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</p>\n<p>再加上@Test注解，可以在不需要main函数下执行测试类</p>\n<p>创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql</p>\n<p>/Users/wuzhenren/Downloads</p>\n<p>~/Users/wuzhenren/Downloads/cmake-3.21.1.tar</p>\n<p>~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar</p>\n<p>mac的mysql下载好之后，设置环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/mysql/bin</span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\">保存</span><br><span class=\"line\">export PATH=$PATH:/usr/local/mysql/bin</span><br><span class=\"line\">:wq</span><br><span class=\"line\">随时可以跑mysql命令</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来要重置密码：</p>\n<p>mysqladmin -u root -p password ____</p>\n<p>Hero 环境出问题，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决。</p>\n<p>hexo在添加新文章的时候怎么默认在md文件中添加categories 以及 tags 标签？</p>\n<p>在博客的 scaffolds 里有个post.md 添加上需要的配置就行了， 这里是创建post的模板。</p>\n<p>分类，直接在categories: -fenleimingcheng</p>\n"},{"title":"7月31号","date":"2021-07-31T01:26:11.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg","_content":"\n昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg)\n\n\n\n## 视图\n\n- 建立视图，主键 主表选择，数据库脚本，\n\n表关联，一对一关联 一对多关联。增加字段\n\n- 界面视图，\n- 智能搜索app\n- 数据库对接 mongdb\n\n## 开发手册\n\nDO / BO / DTO / VO / AO / PO / UID\n\n- DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\n\n- BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。\n- DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于**展示层与服务层之间的数据传输对象**。\n- VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。\n- \n\n\n\n### log4jdbc\n\nSpring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成\n\n**JDBC**：Java Database Connectivity， 有四种连接的方式\n\n主要用途是与数据库建立连接，发送sql语句，处理结果\n\n可以直接调用sql命令，并与其他的数据库连接API易于使用，**低级接口**\n\n公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg)\n\n\n\nlog4jdbc是一个**JDBC驱动器**，能够记录**SQL日志**和**SQL执行时间**等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。\n\n 特性\n\n- 完全支持JDBC3和JDBC4\n- 配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4\n- 自动将占位符(?)替换为实际的参数\n- 能够及时方便地显示SQL的实际执行时间\n- 显示SQL Connection的数量的信息\n- 能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作\n- 支持现有大部分JDBC驱动。\n- 能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。\n- 能够**快速标识出应用程序中执行比较慢的SQL语句**。\n- 能够生成SQL连接数信息帮助识别连接池/线程问题。\n- open source\n\n\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.4</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.googlecode.log4jdbc</groupId>\n            <artifactId>log4jdbc</artifactId>\n            <version>1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.35</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.16</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.6.0</version>\n        </dependency>\n    </dependencies>\n```\n\n## Jpa\n\njpa拥有哪些注解\n\n```java\n\t@Entity  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描\n\t@Table 声明表名字\n\t@Id \t\t指定的类的属性，用于识别一个表中的主键\n  @Transient 指定的属性 它是不持久的，即该值永远不会存储在数据库中\n  @Column\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字\n  \n    \n```\n\n\n\n### 配置\n\n#### 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n```\n\n#### 配置文件yml\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mytest\n    type: com.alibaba.druid.pool.DruidDataSource\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver //驱动\n  jpa:\n    hibernate:\n      ddl-auto: update //自动更新\n    show-sql: true  //日志中显示sql语句\n\n```\n\nHibernate是一个[开放源代码](https://baike.baidu.com/item/开放源代码/114160)的[对象关系映射](https://baike.baidu.com/item/对象关系映射/311152)框架（**不需要写SQL**），它对[JDBC](https://baike.baidu.com/item/JDBC/485214)进行了非常轻量级的对象封装，它将**POJO与数据库表建立映射关系**，是一个全自动的orm框架，**hibernate可以自动生成SQL语句**，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。\n\n既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是**我们MVC中的数据持久层->在编写程序中的DAO层...**\n\n首先，我们来回顾一下我们在DAO层写程序的历程吧：\n\n1. **在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD**\n2. **在DAO层使用原生JDBC连接数据库，实现CRUD**\n3. **嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件-->DbUtils组件**\n\n\n\n## Controller注解\n\n@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，\n\n并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。\n\n```java\n@Controller\n　　@RequestMapping(\"/user\")\n　　public class UserController{\n\n    　　@RequestMapping(\"/users\")\n    　　public String users() {\n        　　return \"users\";\n    　　}\n　　}\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg)\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg)\n\n\n\n\n\n此时请求users方法的URL方法的URL路径就是.../user/users\n\n@PreAuthorize 注解 方法前拦截判断是否有权限\n\n@OrderBy \n```java\n@Table(name = \"MAPKEY_PERSON\")\n    public class Person {\n \n    @OneToMany(targetEntity = Book.class, cascade = CascadeType.ALL, mappedBy = \"person\")\n    @OrderBy(name = \"isbn ASC, name DESC\")\n    private List books = new ArrayList();\n\n```\nTransient\n\n@Transient表示该属性并不是一个到数据库表的字段的映射，\n\n指定的这些属性不会被持久化，ORM框架将忽略该属性。\n\n如果一个属性并非数据库表的字段映射。就务必将其标示为@Transient。\n\n否则，ORM框架默认其注解为@Basic\n\n","source":"_posts/7月31号.md","raw":"---\ntitle: 7月31号\ndate: 2021-07-31 09:26:11\ncategories: \n- Spring Boot\n- 工作日志\ntags:\n- java\n- 框架\nthumbnail: https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg\n---\n\n昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg)\n\n\n\n## 视图\n\n- 建立视图，主键 主表选择，数据库脚本，\n\n表关联，一对一关联 一对多关联。增加字段\n\n- 界面视图，\n- 智能搜索app\n- 数据库对接 mongdb\n\n## 开发手册\n\nDO / BO / DTO / VO / AO / PO / UID\n\n- DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\n\n- BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。\n- DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于**展示层与服务层之间的数据传输对象**。\n- VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。\n- \n\n\n\n### log4jdbc\n\nSpring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成\n\n**JDBC**：Java Database Connectivity， 有四种连接的方式\n\n主要用途是与数据库建立连接，发送sql语句，处理结果\n\n可以直接调用sql命令，并与其他的数据库连接API易于使用，**低级接口**\n\n公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg)\n\n\n\nlog4jdbc是一个**JDBC驱动器**，能够记录**SQL日志**和**SQL执行时间**等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。\n\n 特性\n\n- 完全支持JDBC3和JDBC4\n- 配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4\n- 自动将占位符(?)替换为实际的参数\n- 能够及时方便地显示SQL的实际执行时间\n- 显示SQL Connection的数量的信息\n- 能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作\n- 支持现有大部分JDBC驱动。\n- 能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。\n- 能够**快速标识出应用程序中执行比较慢的SQL语句**。\n- 能够生成SQL连接数信息帮助识别连接池/线程问题。\n- open source\n\n\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.4</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.googlecode.log4jdbc</groupId>\n            <artifactId>log4jdbc</artifactId>\n            <version>1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.35</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.16</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.6.0</version>\n        </dependency>\n    </dependencies>\n```\n\n## Jpa\n\njpa拥有哪些注解\n\n```java\n\t@Entity  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描\n\t@Table 声明表名字\n\t@Id \t\t指定的类的属性，用于识别一个表中的主键\n  @Transient 指定的属性 它是不持久的，即该值永远不会存储在数据库中\n  @Column\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字\n  \n    \n```\n\n\n\n### 配置\n\n#### 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n```\n\n#### 配置文件yml\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mytest\n    type: com.alibaba.druid.pool.DruidDataSource\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver //驱动\n  jpa:\n    hibernate:\n      ddl-auto: update //自动更新\n    show-sql: true  //日志中显示sql语句\n\n```\n\nHibernate是一个[开放源代码](https://baike.baidu.com/item/开放源代码/114160)的[对象关系映射](https://baike.baidu.com/item/对象关系映射/311152)框架（**不需要写SQL**），它对[JDBC](https://baike.baidu.com/item/JDBC/485214)进行了非常轻量级的对象封装，它将**POJO与数据库表建立映射关系**，是一个全自动的orm框架，**hibernate可以自动生成SQL语句**，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。\n\n既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是**我们MVC中的数据持久层->在编写程序中的DAO层...**\n\n首先，我们来回顾一下我们在DAO层写程序的历程吧：\n\n1. **在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD**\n2. **在DAO层使用原生JDBC连接数据库，实现CRUD**\n3. **嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件-->DbUtils组件**\n\n\n\n## Controller注解\n\n@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，\n\n并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。\n\n```java\n@Controller\n　　@RequestMapping(\"/user\")\n　　public class UserController{\n\n    　　@RequestMapping(\"/users\")\n    　　public String users() {\n        　　return \"users\";\n    　　}\n　　}\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg)\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg)\n\n\n\n\n\n此时请求users方法的URL方法的URL路径就是.../user/users\n\n@PreAuthorize 注解 方法前拦截判断是否有权限\n\n@OrderBy \n```java\n@Table(name = \"MAPKEY_PERSON\")\n    public class Person {\n \n    @OneToMany(targetEntity = Book.class, cascade = CascadeType.ALL, mappedBy = \"person\")\n    @OrderBy(name = \"isbn ASC, name DESC\")\n    private List books = new ArrayList();\n\n```\nTransient\n\n@Transient表示该属性并不是一个到数据库表的字段的映射，\n\n指定的这些属性不会被持久化，ORM框架将忽略该属性。\n\n如果一个属性并非数据库表的字段映射。就务必将其标示为@Transient。\n\n否则，ORM框架默认其注解为@Basic\n\n","slug":"7月31号","published":1,"updated":"2021-08-03T02:38:14.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo840007c3769ucjfej4","content":"<p>昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg\"></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><ul>\n<li>建立视图，主键 主表选择，数据库脚本，</li>\n</ul>\n<p>表关联，一对一关联 一对多关联。增加字段</p>\n<ul>\n<li>界面视图，</li>\n<li>智能搜索app</li>\n<li>数据库对接 mongdb</li>\n</ul>\n<h2 id=\"开发手册\"><a href=\"#开发手册\" class=\"headerlink\" title=\"开发手册\"></a>开发手册</h2><p>DO / BO / DTO / VO / AO / PO / UID</p>\n<ul>\n<li><p>DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p>\n</li>\n<li><p>BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>\n</li>\n<li><p>DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于<strong>展示层与服务层之间的数据传输对象</strong>。</p>\n</li>\n<li><p>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p>\n</li>\n<li></li>\n</ul>\n<h3 id=\"log4jdbc\"><a href=\"#log4jdbc\" class=\"headerlink\" title=\"log4jdbc\"></a>log4jdbc</h3><p>Spring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成</p>\n<p><strong>JDBC</strong>：Java Database Connectivity， 有四种连接的方式</p>\n<p>主要用途是与数据库建立连接，发送sql语句，处理结果</p>\n<p>可以直接调用sql命令，并与其他的数据库连接API易于使用，<strong>低级接口</strong></p>\n<p>公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg\"></p>\n<p>log4jdbc是一个<strong>JDBC驱动器</strong>，能够记录<strong>SQL日志</strong>和<strong>SQL执行时间</strong>等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。</p>\n<p> 特性</p>\n<ul>\n<li>完全支持JDBC3和JDBC4</li>\n<li>配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4</li>\n<li>自动将占位符(?)替换为实际的参数</li>\n<li>能够及时方便地显示SQL的实际执行时间</li>\n<li>显示SQL Connection的数量的信息</li>\n<li>能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作</li>\n<li>支持现有大部分JDBC驱动。</li>\n<li>能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。</li>\n<li>能够<strong>快速标识出应用程序中执行比较慢的SQL语句</strong>。</li>\n<li>能够生成SQL连接数信息帮助识别连接池/线程问题。</li>\n<li>open source</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.35<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.16<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Jpa\"><a href=\"#Jpa\" class=\"headerlink\" title=\"Jpa\"></a>Jpa</h2><p>jpa拥有哪些注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描</span><br><span class=\"line\"><span class=\"meta\">@Table</span> 声明表名字</span><br><span class=\"line\"><span class=\"meta\">@Id</span> \t\t指定的类的属性，用于识别一个表中的主键</span><br><span class=\"line\"> <span class=\"meta\">@Transient</span> 指定的属性 它是不持久的，即该值永远不会存储在数据库中</span><br><span class=\"line\"> <span class=\"meta\">@Column</span>\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字</span><br><span class=\"line\"> </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置文件yml\"><a href=\"#配置文件yml\" class=\"headerlink\" title=\"配置文件yml\"></a>配置文件yml</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://localhost:3306/mytest</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span> <span class=\"string\">//驱动</span></span><br><span class=\"line\">  <span class=\"attr\">jpa:</span></span><br><span class=\"line\">    <span class=\"attr\">hibernate:</span></span><br><span class=\"line\">      <span class=\"attr\">ddl-auto:</span> <span class=\"string\">update</span> <span class=\"string\">//自动更新</span></span><br><span class=\"line\">    <span class=\"attr\">show-sql:</span> <span class=\"literal\">true</span>  <span class=\"string\">//日志中显示sql语句</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Hibernate是一个<a href=\"https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160\">开放源代码</a>的<a href=\"https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/311152\">对象关系映射</a>框架（<strong>不需要写SQL</strong>），它对<a href=\"https://baike.baidu.com/item/JDBC/485214\">JDBC</a>进行了非常轻量级的对象封装，它将<strong>POJO与数据库表建立映射关系</strong>，是一个全自动的orm框架，<strong>hibernate可以自动生成SQL语句</strong>，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p>\n<p>既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是<strong>我们MVC中的数据持久层-&gt;在编写程序中的DAO层…</strong></p>\n<p>首先，我们来回顾一下我们在DAO层写程序的历程吧：</p>\n<ol>\n<li><strong>在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD</strong></li>\n<li><strong>在DAO层使用原生JDBC连接数据库，实现CRUD</strong></li>\n<li><strong>嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件–&gt;DbUtils组件</strong></li>\n</ol>\n<h2 id=\"Controller注解\"><a href=\"#Controller注解\" class=\"headerlink\" title=\"Controller注解\"></a>Controller注解</h2><p>@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，</p>\n<p>并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\">　　<span class=\"meta\">@RequestMapping(&quot;/user&quot;)</span></span><br><span class=\"line\">　　<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    　　<span class=\"meta\">@RequestMapping(&quot;/users&quot;)</span></span><br><span class=\"line\">    　　<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">users</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        　　<span class=\"keyword\">return</span> <span class=\"string\">&quot;users&quot;</span>;</span><br><span class=\"line\">    　　&#125;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg\"></p>\n<p>此时请求users方法的URL方法的URL路径就是…/user/users</p>\n<p>@PreAuthorize 注解 方法前拦截判断是否有权限</p>\n<p>@OrderBy </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name = &quot;MAPKEY_PERSON&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@OneToMany(targetEntity = Book.class, cascade = CascadeType.ALL, mappedBy = &quot;person&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@OrderBy(name = &quot;isbn ASC, name DESC&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List books = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Transient</p>\n<p>@Transient表示该属性并不是一个到数据库表的字段的映射，</p>\n<p>指定的这些属性不会被持久化，ORM框架将忽略该属性。</p>\n<p>如果一个属性并非数据库表的字段映射。就务必将其标示为@Transient。</p>\n<p>否则，ORM框架默认其注解为@Basic</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg\"></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><ul>\n<li>建立视图，主键 主表选择，数据库脚本，</li>\n</ul>\n<p>表关联，一对一关联 一对多关联。增加字段</p>\n<ul>\n<li>界面视图，</li>\n<li>智能搜索app</li>\n<li>数据库对接 mongdb</li>\n</ul>\n<h2 id=\"开发手册\"><a href=\"#开发手册\" class=\"headerlink\" title=\"开发手册\"></a>开发手册</h2><p>DO / BO / DTO / VO / AO / PO / UID</p>\n<ul>\n<li><p>DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p>\n</li>\n<li><p>BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>\n</li>\n<li><p>DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于<strong>展示层与服务层之间的数据传输对象</strong>。</p>\n</li>\n<li><p>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p>\n</li>\n<li></li>\n</ul>\n<h3 id=\"log4jdbc\"><a href=\"#log4jdbc\" class=\"headerlink\" title=\"log4jdbc\"></a>log4jdbc</h3><p>Spring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成</p>\n<p><strong>JDBC</strong>：Java Database Connectivity， 有四种连接的方式</p>\n<p>主要用途是与数据库建立连接，发送sql语句，处理结果</p>\n<p>可以直接调用sql命令，并与其他的数据库连接API易于使用，<strong>低级接口</strong></p>\n<p>公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg\"></p>\n<p>log4jdbc是一个<strong>JDBC驱动器</strong>，能够记录<strong>SQL日志</strong>和<strong>SQL执行时间</strong>等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。</p>\n<p> 特性</p>\n<ul>\n<li>完全支持JDBC3和JDBC4</li>\n<li>配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4</li>\n<li>自动将占位符(?)替换为实际的参数</li>\n<li>能够及时方便地显示SQL的实际执行时间</li>\n<li>显示SQL Connection的数量的信息</li>\n<li>能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作</li>\n<li>支持现有大部分JDBC驱动。</li>\n<li>能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。</li>\n<li>能够<strong>快速标识出应用程序中执行比较慢的SQL语句</strong>。</li>\n<li>能够生成SQL连接数信息帮助识别连接池/线程问题。</li>\n<li>open source</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.35<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.16<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Jpa\"><a href=\"#Jpa\" class=\"headerlink\" title=\"Jpa\"></a>Jpa</h2><p>jpa拥有哪些注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描</span><br><span class=\"line\"><span class=\"meta\">@Table</span> 声明表名字</span><br><span class=\"line\"><span class=\"meta\">@Id</span> \t\t指定的类的属性，用于识别一个表中的主键</span><br><span class=\"line\"> <span class=\"meta\">@Transient</span> 指定的属性 它是不持久的，即该值永远不会存储在数据库中</span><br><span class=\"line\"> <span class=\"meta\">@Column</span>\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字</span><br><span class=\"line\"> </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置文件yml\"><a href=\"#配置文件yml\" class=\"headerlink\" title=\"配置文件yml\"></a>配置文件yml</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://localhost:3306/mytest</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span> <span class=\"string\">//驱动</span></span><br><span class=\"line\">  <span class=\"attr\">jpa:</span></span><br><span class=\"line\">    <span class=\"attr\">hibernate:</span></span><br><span class=\"line\">      <span class=\"attr\">ddl-auto:</span> <span class=\"string\">update</span> <span class=\"string\">//自动更新</span></span><br><span class=\"line\">    <span class=\"attr\">show-sql:</span> <span class=\"literal\">true</span>  <span class=\"string\">//日志中显示sql语句</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Hibernate是一个<a href=\"https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160\">开放源代码</a>的<a href=\"https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/311152\">对象关系映射</a>框架（<strong>不需要写SQL</strong>），它对<a href=\"https://baike.baidu.com/item/JDBC/485214\">JDBC</a>进行了非常轻量级的对象封装，它将<strong>POJO与数据库表建立映射关系</strong>，是一个全自动的orm框架，<strong>hibernate可以自动生成SQL语句</strong>，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p>\n<p>既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是<strong>我们MVC中的数据持久层-&gt;在编写程序中的DAO层…</strong></p>\n<p>首先，我们来回顾一下我们在DAO层写程序的历程吧：</p>\n<ol>\n<li><strong>在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD</strong></li>\n<li><strong>在DAO层使用原生JDBC连接数据库，实现CRUD</strong></li>\n<li><strong>嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件–&gt;DbUtils组件</strong></li>\n</ol>\n<h2 id=\"Controller注解\"><a href=\"#Controller注解\" class=\"headerlink\" title=\"Controller注解\"></a>Controller注解</h2><p>@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，</p>\n<p>并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\">　　<span class=\"meta\">@RequestMapping(&quot;/user&quot;)</span></span><br><span class=\"line\">　　<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    　　<span class=\"meta\">@RequestMapping(&quot;/users&quot;)</span></span><br><span class=\"line\">    　　<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">users</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        　　<span class=\"keyword\">return</span> <span class=\"string\">&quot;users&quot;</span>;</span><br><span class=\"line\">    　　&#125;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg\"></p>\n<p>此时请求users方法的URL方法的URL路径就是…/user/users</p>\n<p>@PreAuthorize 注解 方法前拦截判断是否有权限</p>\n<p>@OrderBy </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Table(name = &quot;MAPKEY_PERSON&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@OneToMany(targetEntity = Book.class, cascade = CascadeType.ALL, mappedBy = &quot;person&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@OrderBy(name = &quot;isbn ASC, name DESC&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List books = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Transient</p>\n<p>@Transient表示该属性并不是一个到数据库表的字段的映射，</p>\n<p>指定的这些属性不会被持久化，ORM框架将忽略该属性。</p>\n<p>如果一个属性并非数据库表的字段映射。就务必将其标示为@Transient。</p>\n<p>否则，ORM框架默认其注解为@Basic</p>\n"},{"title":"8月10日","date":"2021-08-10T01:31:58.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtbfyvxti7j318z0u00yq.jpg","_content":"今日任务，把原来的搜索接口写好，再写热搜统计，\n\n数据库前沿，今天必须总结出大概模板，具体的数据可以先不看了，\n\n给大家推荐一个网站，看图的 斜眼^^\n\nhttps://picjumbo.com/little-girl-with-sunflower-in-a-sunflower-field/\n\n每天都有更新很多好图，看完让人心情愉悦，我的很多封面都是由此而来。\n\nGetpost查询传入的是什么？分页参数怎么传的？\n\n默认传入的是空，也可以加@RequestParam或者@RequestBody\n\n@RequestBody 传入数据的时候，要注意一种空数据的情况，加一个@Nullable \n\n在springboot.lang这个包里面。\n\n\n\nPage这个类，\n\n\n\nQueryHelp.getpredicate\n\n\n\n```\nQuery q = field.getAnnotation(Query.class);\n```\n\n下面打印q，获得了join type之类的，\n\n@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)\n\npropName因为字段和数据库一样，就没填，join和type在查询类中有定义\n\n\n\n\n\n热搜要实现这几个功能，\n\n每查询一次，search_counts++,\n\n在QueryHelp中，返回的是不是查询语句？getContent()返回实体类？\n\ntoDto再返回传输类？\n\n@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)\n\n那什么地方进行查询比对的，\n\n需要对数据库的表进行排序，(实时动态？)\n\n前端每次点开新的界面，自动返回排名前几个的\n\n标的可能重名，都上了热搜则直接覆盖。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtbut5qixej30t70d8jun.jpg)\n\n是什么语法？\n\n\n\n","source":"_posts/8月10日.md","raw":"---\ntitle: 8月10日\ndate: 2021-08-10 09:31:58\ncategories:\n- 工作日志\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtbfyvxti7j318z0u00yq.jpg\n---\n今日任务，把原来的搜索接口写好，再写热搜统计，\n\n数据库前沿，今天必须总结出大概模板，具体的数据可以先不看了，\n\n给大家推荐一个网站，看图的 斜眼^^\n\nhttps://picjumbo.com/little-girl-with-sunflower-in-a-sunflower-field/\n\n每天都有更新很多好图，看完让人心情愉悦，我的很多封面都是由此而来。\n\nGetpost查询传入的是什么？分页参数怎么传的？\n\n默认传入的是空，也可以加@RequestParam或者@RequestBody\n\n@RequestBody 传入数据的时候，要注意一种空数据的情况，加一个@Nullable \n\n在springboot.lang这个包里面。\n\n\n\nPage这个类，\n\n\n\nQueryHelp.getpredicate\n\n\n\n```\nQuery q = field.getAnnotation(Query.class);\n```\n\n下面打印q，获得了join type之类的，\n\n@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)\n\npropName因为字段和数据库一样，就没填，join和type在查询类中有定义\n\n\n\n\n\n热搜要实现这几个功能，\n\n每查询一次，search_counts++,\n\n在QueryHelp中，返回的是不是查询语句？getContent()返回实体类？\n\ntoDto再返回传输类？\n\n@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)\n\n那什么地方进行查询比对的，\n\n需要对数据库的表进行排序，(实时动态？)\n\n前端每次点开新的界面，自动返回排名前几个的\n\n标的可能重名，都上了热搜则直接覆盖。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtbut5qixej30t70d8jun.jpg)\n\n是什么语法？\n\n\n\n","slug":"8月10日","published":1,"updated":"2021-08-10T10:15:57.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8d0009c3765cfl1b01","content":"<p>今日任务，把原来的搜索接口写好，再写热搜统计，</p>\n<p>数据库前沿，今天必须总结出大概模板，具体的数据可以先不看了，</p>\n<p>给大家推荐一个网站，看图的 斜眼^^</p>\n<p><a href=\"https://picjumbo.com/little-girl-with-sunflower-in-a-sunflower-field/\">https://picjumbo.com/little-girl-with-sunflower-in-a-sunflower-field/</a></p>\n<p>每天都有更新很多好图，看完让人心情愉悦，我的很多封面都是由此而来。</p>\n<p>Getpost查询传入的是什么？分页参数怎么传的？</p>\n<p>默认传入的是空，也可以加@RequestParam或者@RequestBody</p>\n<p>@RequestBody 传入数据的时候，要注意一种空数据的情况，加一个@Nullable </p>\n<p>在springboot.lang这个包里面。</p>\n<p>Page这个类，</p>\n<p>QueryHelp.getpredicate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Query q = field.getAnnotation(Query.class);</span><br></pre></td></tr></table></figure>\n\n<p>下面打印q，获得了join type之类的，</p>\n<p>@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)</p>\n<p>propName因为字段和数据库一样，就没填，join和type在查询类中有定义</p>\n<p>热搜要实现这几个功能，</p>\n<p>每查询一次，search_counts++,</p>\n<p>在QueryHelp中，返回的是不是查询语句？getContent()返回实体类？</p>\n<p>toDto再返回传输类？</p>\n<p>@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)</p>\n<p>那什么地方进行查询比对的，</p>\n<p>需要对数据库的表进行排序，(实时动态？)</p>\n<p>前端每次点开新的界面，自动返回排名前几个的</p>\n<p>标的可能重名，都上了热搜则直接覆盖。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtbut5qixej30t70d8jun.jpg\"></p>\n<p>是什么语法？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今日任务，把原来的搜索接口写好，再写热搜统计，</p>\n<p>数据库前沿，今天必须总结出大概模板，具体的数据可以先不看了，</p>\n<p>给大家推荐一个网站，看图的 斜眼^^</p>\n<p><a href=\"https://picjumbo.com/little-girl-with-sunflower-in-a-sunflower-field/\">https://picjumbo.com/little-girl-with-sunflower-in-a-sunflower-field/</a></p>\n<p>每天都有更新很多好图，看完让人心情愉悦，我的很多封面都是由此而来。</p>\n<p>Getpost查询传入的是什么？分页参数怎么传的？</p>\n<p>默认传入的是空，也可以加@RequestParam或者@RequestBody</p>\n<p>@RequestBody 传入数据的时候，要注意一种空数据的情况，加一个@Nullable </p>\n<p>在springboot.lang这个包里面。</p>\n<p>Page这个类，</p>\n<p>QueryHelp.getpredicate</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Query q = field.getAnnotation(Query.class);</span><br></pre></td></tr></table></figure>\n\n<p>下面打印q，获得了join type之类的，</p>\n<p>@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)</p>\n<p>propName因为字段和数据库一样，就没填，join和type在查询类中有定义</p>\n<p>热搜要实现这几个功能，</p>\n<p>每查询一次，search_counts++,</p>\n<p>在QueryHelp中，返回的是不是查询语句？getContent()返回实体类？</p>\n<p>toDto再返回传输类？</p>\n<p>@com.tigerobo.dasheng.admin.annotation.Query(join=LEFT, type=INNER_LIKE, propName=, blurry=, joinName=)</p>\n<p>那什么地方进行查询比对的，</p>\n<p>需要对数据库的表进行排序，(实时动态？)</p>\n<p>前端每次点开新的界面，自动返回排名前几个的</p>\n<p>标的可能重名，都上了热搜则直接覆盖。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtbut5qixej30t70d8jun.jpg\"></p>\n<p>是什么语法？</p>\n"},{"title":"8月11日","date":"2021-08-11T04:58:43.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtct85x1gaj61900u0jwi02.jpg","_content":"前端请求的页面也能看出一些东西，帮助我们后端调试\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtcrhlvhh4j61cq0jy43h02.jpg)\n\nQuery String Parameters\n\n请求参数，前端默认为page=0&size=10&sort=updateTime%2Cdesc&type=1\n\n%2C是逗号的转义。\n\n实体类的属性字段命名要用驼峰，数据库内可用下划线\n\n待查询的sql语句：   \n\n```sql\t\nselect city,name,age from t where city='杭州' order by name limit 1000 ;\n```\n\nSort_buffer_size定义：\n\nMysql为排序开辟的内存大小，如果要排序的数据量小于sort_buffer_size,排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。\n\n通过查看 OPTIMIZER_TRACE，number_of_tmp_files表示排序使用的临时文件数，**外部排序一般使用归并排序算法**。MySQL 将需要**排序的数据分成 12 份**，**每一份单独排序后存在这些临时文件中**。然后把这 **12个有序文件再合并成一个有序的大文件**\n\n1. 初始化 sort_buffer，确定放入 **name、city、age** 这三个字段；\n2. 从索引 city **找到第一个满足 city='杭州’条件的主键 id**，也就是图中的 ID_X；\n3. 到**主键 id 索引取出整行**，取 name、city、age 三个字段的值，存入 sort_buffer 中；\n4. 从索引 city 取下一个City='杭州'记录的主键 id；\n5. 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的ID_Y；\n6. 对 sort_buffer 中的数据按照**字段 name** 做快速排序；\n7. 按照排序结果取前 1000 行返回给客户端。\n\n该过程称为全字段排序\n\n\n\n如果查询返回字段很多的，MySQL会将需要排序的列和主键放入sort_buffer,此时执行流程为：\n\n1. 初始化 sort_buffer，确定放入两个字段，即 name 和 id；\n2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；\n3. 到主键 id 索引取出整行，**取 name、id 这两个字段**，存入 sort_buffer 中；\n4. 从索引 city 取下一个记录的主键 id；\n5. 重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y；\n6. 对 sort_buffer 中的数据按照字段 name 进行排序；、\n7. 遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。\n\n这个过程称为rowid排序,相比较全字段排序，它只取了排序字段和主键再内存中进行排序，**排序结束后还需要遍历主键索引树，取出需要查询的值，**这个回表的过程比较耗时。\n\n总结就是：先把符合记录的字段取出来，再在sort_buffer中排序，如果全字段排序，排完序直接取出返回给用户端。如果不是全字段，只排序了一部分字段，则还需要遍历主键索引，取出需要查询的值。这个**回表过程比较耗时**\n\n如果order by后面的字段走**联合索引**（两个或更多个列上的索引被称作复合索引。），联合索引中的数据有顺序的，比如（city, name, age）三个字段组成联合索引，会按照city排序，再按照name排序，最后按照age排序，这样查询的出的结果集可以直接返回，不需要使用sort_buffer内存进行排序,可以使用explain查看extra属性是否有Using filesort。\n\n\n\n\"message\": \"could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not execute statement\",\n\n\n\n参数有问题？\n","source":"_posts/8月11日.md","raw":"---\ntitle: 8月11日\ndate: 2021-08-11 12:58:43\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtct85x1gaj61900u0jwi02.jpg\n---\n前端请求的页面也能看出一些东西，帮助我们后端调试\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtcrhlvhh4j61cq0jy43h02.jpg)\n\nQuery String Parameters\n\n请求参数，前端默认为page=0&size=10&sort=updateTime%2Cdesc&type=1\n\n%2C是逗号的转义。\n\n实体类的属性字段命名要用驼峰，数据库内可用下划线\n\n待查询的sql语句：   \n\n```sql\t\nselect city,name,age from t where city='杭州' order by name limit 1000 ;\n```\n\nSort_buffer_size定义：\n\nMysql为排序开辟的内存大小，如果要排序的数据量小于sort_buffer_size,排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。\n\n通过查看 OPTIMIZER_TRACE，number_of_tmp_files表示排序使用的临时文件数，**外部排序一般使用归并排序算法**。MySQL 将需要**排序的数据分成 12 份**，**每一份单独排序后存在这些临时文件中**。然后把这 **12个有序文件再合并成一个有序的大文件**\n\n1. 初始化 sort_buffer，确定放入 **name、city、age** 这三个字段；\n2. 从索引 city **找到第一个满足 city='杭州’条件的主键 id**，也就是图中的 ID_X；\n3. 到**主键 id 索引取出整行**，取 name、city、age 三个字段的值，存入 sort_buffer 中；\n4. 从索引 city 取下一个City='杭州'记录的主键 id；\n5. 重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的ID_Y；\n6. 对 sort_buffer 中的数据按照**字段 name** 做快速排序；\n7. 按照排序结果取前 1000 行返回给客户端。\n\n该过程称为全字段排序\n\n\n\n如果查询返回字段很多的，MySQL会将需要排序的列和主键放入sort_buffer,此时执行流程为：\n\n1. 初始化 sort_buffer，确定放入两个字段，即 name 和 id；\n2. 从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；\n3. 到主键 id 索引取出整行，**取 name、id 这两个字段**，存入 sort_buffer 中；\n4. 从索引 city 取下一个记录的主键 id；\n5. 重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y；\n6. 对 sort_buffer 中的数据按照字段 name 进行排序；、\n7. 遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。\n\n这个过程称为rowid排序,相比较全字段排序，它只取了排序字段和主键再内存中进行排序，**排序结束后还需要遍历主键索引树，取出需要查询的值，**这个回表的过程比较耗时。\n\n总结就是：先把符合记录的字段取出来，再在sort_buffer中排序，如果全字段排序，排完序直接取出返回给用户端。如果不是全字段，只排序了一部分字段，则还需要遍历主键索引，取出需要查询的值。这个**回表过程比较耗时**\n\n如果order by后面的字段走**联合索引**（两个或更多个列上的索引被称作复合索引。），联合索引中的数据有顺序的，比如（city, name, age）三个字段组成联合索引，会按照city排序，再按照name排序，最后按照age排序，这样查询的出的结果集可以直接返回，不需要使用sort_buffer内存进行排序,可以使用explain查看extra属性是否有Using filesort。\n\n\n\n\"message\": \"could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not execute statement\",\n\n\n\n参数有问题？\n","slug":"8月11日","published":1,"updated":"2021-08-11T06:56:41.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8e000bc376grxia5h0","content":"<p>前端请求的页面也能看出一些东西，帮助我们后端调试</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtcrhlvhh4j61cq0jy43h02.jpg\"></p>\n<p>Query String Parameters</p>\n<p>请求参数，前端默认为page=0&amp;size=10&amp;sort=updateTime%2Cdesc&amp;type=1</p>\n<p>%2C是逗号的转义。</p>\n<p>实体类的属性字段命名要用驼峰，数据库内可用下划线</p>\n<p>待查询的sql语句：   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> city,name,age <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> city<span class=\"operator\">=</span><span class=\"string\">&#x27;杭州&#x27;</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> name limit <span class=\"number\">1000</span> ;</span><br></pre></td></tr></table></figure>\n\n<p>Sort_buffer_size定义：</p>\n<p>Mysql为排序开辟的内存大小，如果要排序的数据量小于sort_buffer_size,排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>\n<p>通过查看 OPTIMIZER_TRACE，number_of_tmp_files表示排序使用的临时文件数，<strong>外部排序一般使用归并排序算法</strong>。MySQL 将需要<strong>排序的数据分成 12 份</strong>，<strong>每一份单独排序后存在这些临时文件中</strong>。然后把这 <strong>12个有序文件再合并成一个有序的大文件</strong></p>\n<ol>\n<li>初始化 sort_buffer，确定放入 <strong>name、city、age</strong> 这三个字段；</li>\n<li>从索引 city <strong>找到第一个满足 city=’杭州’条件的主键 id</strong>，也就是图中的 ID_X；</li>\n<li>到<strong>主键 id 索引取出整行</strong>，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li>\n<li>从索引 city 取下一个City=’杭州’记录的主键 id；</li>\n<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的ID_Y；</li>\n<li>对 sort_buffer 中的数据按照<strong>字段 name</strong> 做快速排序；</li>\n<li>按照排序结果取前 1000 行返回给客户端。</li>\n</ol>\n<p>该过程称为全字段排序</p>\n<p>如果查询返回字段很多的，MySQL会将需要排序的列和主键放入sort_buffer,此时执行流程为：</p>\n<ol>\n<li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li>\n<li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li>\n<li>到主键 id 索引取出整行，<strong>取 name、id 这两个字段</strong>，存入 sort_buffer 中；</li>\n<li>从索引 city 取下一个记录的主键 id；</li>\n<li>重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</li>\n<li>对 sort_buffer 中的数据按照字段 name 进行排序；、</li>\n<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>\n</ol>\n<p>这个过程称为rowid排序,相比较全字段排序，它只取了排序字段和主键再内存中进行排序，<strong>排序结束后还需要遍历主键索引树，取出需要查询的值，</strong>这个回表的过程比较耗时。</p>\n<p>总结就是：先把符合记录的字段取出来，再在sort_buffer中排序，如果全字段排序，排完序直接取出返回给用户端。如果不是全字段，只排序了一部分字段，则还需要遍历主键索引，取出需要查询的值。这个<strong>回表过程比较耗时</strong></p>\n<p>如果order by后面的字段走<strong>联合索引</strong>（两个或更多个列上的索引被称作复合索引。），联合索引中的数据有顺序的，比如（city, name, age）三个字段组成联合索引，会按照city排序，再按照name排序，最后按照age排序，这样查询的出的结果集可以直接返回，不需要使用sort_buffer内存进行排序,可以使用explain查看extra属性是否有Using filesort。</p>\n<p>“message”: “could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not execute statement”,</p>\n<p>参数有问题？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前端请求的页面也能看出一些东西，帮助我们后端调试</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtcrhlvhh4j61cq0jy43h02.jpg\"></p>\n<p>Query String Parameters</p>\n<p>请求参数，前端默认为page=0&amp;size=10&amp;sort=updateTime%2Cdesc&amp;type=1</p>\n<p>%2C是逗号的转义。</p>\n<p>实体类的属性字段命名要用驼峰，数据库内可用下划线</p>\n<p>待查询的sql语句：   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> city,name,age <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> city<span class=\"operator\">=</span><span class=\"string\">&#x27;杭州&#x27;</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> name limit <span class=\"number\">1000</span> ;</span><br></pre></td></tr></table></figure>\n\n<p>Sort_buffer_size定义：</p>\n<p>Mysql为排序开辟的内存大小，如果要排序的数据量小于sort_buffer_size,排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>\n<p>通过查看 OPTIMIZER_TRACE，number_of_tmp_files表示排序使用的临时文件数，<strong>外部排序一般使用归并排序算法</strong>。MySQL 将需要<strong>排序的数据分成 12 份</strong>，<strong>每一份单独排序后存在这些临时文件中</strong>。然后把这 <strong>12个有序文件再合并成一个有序的大文件</strong></p>\n<ol>\n<li>初始化 sort_buffer，确定放入 <strong>name、city、age</strong> 这三个字段；</li>\n<li>从索引 city <strong>找到第一个满足 city=’杭州’条件的主键 id</strong>，也就是图中的 ID_X；</li>\n<li>到<strong>主键 id 索引取出整行</strong>，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li>\n<li>从索引 city 取下一个City=’杭州’记录的主键 id；</li>\n<li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的ID_Y；</li>\n<li>对 sort_buffer 中的数据按照<strong>字段 name</strong> 做快速排序；</li>\n<li>按照排序结果取前 1000 行返回给客户端。</li>\n</ol>\n<p>该过程称为全字段排序</p>\n<p>如果查询返回字段很多的，MySQL会将需要排序的列和主键放入sort_buffer,此时执行流程为：</p>\n<ol>\n<li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li>\n<li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li>\n<li>到主键 id 索引取出整行，<strong>取 name、id 这两个字段</strong>，存入 sort_buffer 中；</li>\n<li>从索引 city 取下一个记录的主键 id；</li>\n<li>重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</li>\n<li>对 sort_buffer 中的数据按照字段 name 进行排序；、</li>\n<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>\n</ol>\n<p>这个过程称为rowid排序,相比较全字段排序，它只取了排序字段和主键再内存中进行排序，<strong>排序结束后还需要遍历主键索引树，取出需要查询的值，</strong>这个回表的过程比较耗时。</p>\n<p>总结就是：先把符合记录的字段取出来，再在sort_buffer中排序，如果全字段排序，排完序直接取出返回给用户端。如果不是全字段，只排序了一部分字段，则还需要遍历主键索引，取出需要查询的值。这个<strong>回表过程比较耗时</strong></p>\n<p>如果order by后面的字段走<strong>联合索引</strong>（两个或更多个列上的索引被称作复合索引。），联合索引中的数据有顺序的，比如（city, name, age）三个字段组成联合索引，会按照city排序，再按照name排序，最后按照age排序，这样查询的出的结果集可以直接返回，不需要使用sort_buffer内存进行排序,可以使用explain查看extra属性是否有Using filesort。</p>\n<p>“message”: “could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not execute statement”,</p>\n<p>参数有问题？</p>\n"},{"title":"8月13日","date":"2021-08-13T07:39:02.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtikwgjigqj618z0u013y02.jpg","_content":"\n昨天一天都在忙谢希科老师的论文pre，大家都在公司写代码，就我在公司看论文写ppt，\n\n实习一天净赚500😂\n\n今天貌似是七夕？室友跟女朋友分手了，哎，好难。\n\n今天多写点\n\nService方法中的update是什么时候开启一个事务的？\n\nRepository的save方法，如果原Id存在会直接覆盖吗？\n\n\n\n今天使用jpa的save方法时发现null字段也会被更新到数据库，这个直接把数据库数据覆盖的行为很可怕，果断研究了一下怎样能不保存null值。\n\n1. 实体类加@DynamicInsert(true)/@DynamicUpdate(true)注解;\n\n\n\n\n\ncould not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet\",\n\n数据库里面没有写create_by这几个字段，导致Entity匹配不上。\n\n\n\n为什么本地跑没问题，提交到服务器就有问题？？？也发布了啊\n\n发布的时候，只要出现红色的，就没有发布成功，还是用的以前的。本地有时候测试成功是因为用的之前的jar包，详细了解了解maven\n\n日常导错包，真的是特别难找\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtfk7tcag7j61500u0q9g02.jpg)\n\n\n\n","source":"_posts/8月13日.md","raw":"---\ntitle: 8月13日\ndate: 2021-08-13 15:39:02\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtikwgjigqj618z0u013y02.jpg\n---\n\n昨天一天都在忙谢希科老师的论文pre，大家都在公司写代码，就我在公司看论文写ppt，\n\n实习一天净赚500😂\n\n今天貌似是七夕？室友跟女朋友分手了，哎，好难。\n\n今天多写点\n\nService方法中的update是什么时候开启一个事务的？\n\nRepository的save方法，如果原Id存在会直接覆盖吗？\n\n\n\n今天使用jpa的save方法时发现null字段也会被更新到数据库，这个直接把数据库数据覆盖的行为很可怕，果断研究了一下怎样能不保存null值。\n\n1. 实体类加@DynamicInsert(true)/@DynamicUpdate(true)注解;\n\n\n\n\n\ncould not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet\",\n\n数据库里面没有写create_by这几个字段，导致Entity匹配不上。\n\n\n\n为什么本地跑没问题，提交到服务器就有问题？？？也发布了啊\n\n发布的时候，只要出现红色的，就没有发布成功，还是用的以前的。本地有时候测试成功是因为用的之前的jar包，详细了解了解maven\n\n日常导错包，真的是特别难找\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtfk7tcag7j61500u0q9g02.jpg)\n\n\n\n","slug":"8月13日","published":1,"updated":"2021-08-16T05:45:48.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8h000ec376gvfe4nfh","content":"<p>昨天一天都在忙谢希科老师的论文pre，大家都在公司写代码，就我在公司看论文写ppt，</p>\n<p>实习一天净赚500😂</p>\n<p>今天貌似是七夕？室友跟女朋友分手了，哎，好难。</p>\n<p>今天多写点</p>\n<p>Service方法中的update是什么时候开启一个事务的？</p>\n<p>Repository的save方法，如果原Id存在会直接覆盖吗？</p>\n<p>今天使用jpa的save方法时发现null字段也会被更新到数据库，这个直接把数据库数据覆盖的行为很可怕，果断研究了一下怎样能不保存null值。</p>\n<ol>\n<li>实体类加@DynamicInsert(true)/@DynamicUpdate(true)注解;</li>\n</ol>\n<p>could not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet”,</p>\n<p>数据库里面没有写create_by这几个字段，导致Entity匹配不上。</p>\n<p>为什么本地跑没问题，提交到服务器就有问题？？？也发布了啊</p>\n<p>发布的时候，只要出现红色的，就没有发布成功，还是用的以前的。本地有时候测试成功是因为用的之前的jar包，详细了解了解maven</p>\n<p>日常导错包，真的是特别难找</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtfk7tcag7j61500u0q9g02.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天一天都在忙谢希科老师的论文pre，大家都在公司写代码，就我在公司看论文写ppt，</p>\n<p>实习一天净赚500😂</p>\n<p>今天貌似是七夕？室友跟女朋友分手了，哎，好难。</p>\n<p>今天多写点</p>\n<p>Service方法中的update是什么时候开启一个事务的？</p>\n<p>Repository的save方法，如果原Id存在会直接覆盖吗？</p>\n<p>今天使用jpa的save方法时发现null字段也会被更新到数据库，这个直接把数据库数据覆盖的行为很可怕，果断研究了一下怎样能不保存null值。</p>\n<ol>\n<li>实体类加@DynamicInsert(true)/@DynamicUpdate(true)注解;</li>\n</ol>\n<p>could not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet”,</p>\n<p>数据库里面没有写create_by这几个字段，导致Entity匹配不上。</p>\n<p>为什么本地跑没问题，提交到服务器就有问题？？？也发布了啊</p>\n<p>发布的时候，只要出现红色的，就没有发布成功，还是用的以前的。本地有时候测试成功是因为用的之前的jar包，详细了解了解maven</p>\n<p>日常导错包，真的是特别难找</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtfk7tcag7j61500u0q9g02.jpg\"></p>\n"},{"title":"8月14日","date":"2021-08-14T01:55:30.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtikv2kt77j61900u0k4r02.jpg","_content":"\n\n热搜配置： http://10.0.8.61:8011/api/configSearchHot?page=0&size=10&sort=level,asc\n\n热搜统计：http://10.0.8.61:8011/api/countSearchHot?page=0&size=10&sort=searchCounts,desc\n\n上移下移：\n\n\n\n\n\n假设在我们业务逻辑中需要传递一个 `UserForm`，接收 `age,name,param` 三个参数。并对其中输入进行进行校验，其中，`param` 没有具体的含义，只是为了说明问题。\n\n```json\n{\n    \"code\": 400,\n    \"message\": \"must not be blank\",\n    \"data\": null\n}\n```\n\n是有些字段不能为空，在实体类里面有定义\n\n```java\n  @Column(name=\"name\",unique = true,nullable = false)\n    @NotBlank\n    @ApiModelProperty(value = \"展示名称\")\n    private String name;\n```\n\n\n\n\n\n是可以既传请求体，也传参数的，\n\n\n\n\n\n\n\nTarget object must not be null; nested exception is java.lang.IllegalArgumentException: Target object must not be null\n\n哦我弄的put请求。。应该要post的\n\n\n\n8/14我删除了countSearchHot类中没用的字段，以及download的一些相关代码。\n\n我们一般情况下都是写完代码，commit到本地仓库，生成本地仓库commit ID，当前提交版本号，然后push到远程仓库，。\t\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtg52iceinj60hs0dcq3e02.jpg)\n\n**git pull看起来像git fetch+get merge**\n\n\n\nERROR o.h.e.jdbc.spi.SqlExceptionHelper - Zero date value prohibited\n\nWARN  o.h.e.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: S1009\n\n\n\nmaven报错一般都是导错包，检查检查，不然发布的还是以前的版本\n\nDto的字段名称跟数据库对应？\n\n排序的问题，还有update问题。\n\n\n\nTransaction silently rolled back because it has been marked as rollback-only\",\n\n​    \"data\": **null**\n\n是因为@Trasactional里面的注解写错了\n\n\n\n为什么数据有数据，查出来的字段全部为空null？\n\nDto的问题，数据库查询出空字段的\n\n\n\nPost字段的名称是跟实体domain一致的。\n\n实体的字段名称需要和Dto一致！\n\n\n\n修改了字段，记得clean maven！\n\n不然查出来还是空的。\n\n\n\n传入卡片\n\n卡片正文是一个list，appcode 就一个应用，写死，pagecode，\n\n**1.Boolean类型,生成的get方法是get开头的(建议使用这个).**\n**2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).**\n\n\n\ndefined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/rest/ConfigSearchHotController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'configSearchHotServiceImpl' defined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/service/impl/ConfigSearchHotServiceImpl.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'configSearchHotRepository': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Using named parameters for method public abstract void com.tigerobo.dasheng.admin.modules.search.repository.ConfigSearchHotRepository.updateLevel(java.lang.Integer) but parameter 'Optional[targetLevel]' not found in annotated query 'update search_hot_config set level =:level -1 where level >  targetLevel'!\n\tat \n\n\n\nRepository的sql写的有问题， ：或者？都是在传入参数绑定用的，别的和原生sql差不多。\n\nNamed parameter not bound 绑定参数的问题。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtjrn6zdv6j614w0aajs602.jpg)\n\n需要添加事务注解\n\n\n\ncould not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet\"\n\n实体类和DTO和查询类名字要统一，数据库表和column要统一\n\n\n\n然后Maven-clean，重新编译运行。\n","source":"_posts/8月14.md","raw":"---\ntitle: 8月14日\ndate: 2021-08-14 09:55:30\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtikv2kt77j61900u0k4r02.jpg\n---\n\n\n热搜配置： http://10.0.8.61:8011/api/configSearchHot?page=0&size=10&sort=level,asc\n\n热搜统计：http://10.0.8.61:8011/api/countSearchHot?page=0&size=10&sort=searchCounts,desc\n\n上移下移：\n\n\n\n\n\n假设在我们业务逻辑中需要传递一个 `UserForm`，接收 `age,name,param` 三个参数。并对其中输入进行进行校验，其中，`param` 没有具体的含义，只是为了说明问题。\n\n```json\n{\n    \"code\": 400,\n    \"message\": \"must not be blank\",\n    \"data\": null\n}\n```\n\n是有些字段不能为空，在实体类里面有定义\n\n```java\n  @Column(name=\"name\",unique = true,nullable = false)\n    @NotBlank\n    @ApiModelProperty(value = \"展示名称\")\n    private String name;\n```\n\n\n\n\n\n是可以既传请求体，也传参数的，\n\n\n\n\n\n\n\nTarget object must not be null; nested exception is java.lang.IllegalArgumentException: Target object must not be null\n\n哦我弄的put请求。。应该要post的\n\n\n\n8/14我删除了countSearchHot类中没用的字段，以及download的一些相关代码。\n\n我们一般情况下都是写完代码，commit到本地仓库，生成本地仓库commit ID，当前提交版本号，然后push到远程仓库，。\t\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtg52iceinj60hs0dcq3e02.jpg)\n\n**git pull看起来像git fetch+get merge**\n\n\n\nERROR o.h.e.jdbc.spi.SqlExceptionHelper - Zero date value prohibited\n\nWARN  o.h.e.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: S1009\n\n\n\nmaven报错一般都是导错包，检查检查，不然发布的还是以前的版本\n\nDto的字段名称跟数据库对应？\n\n排序的问题，还有update问题。\n\n\n\nTransaction silently rolled back because it has been marked as rollback-only\",\n\n​    \"data\": **null**\n\n是因为@Trasactional里面的注解写错了\n\n\n\n为什么数据有数据，查出来的字段全部为空null？\n\nDto的问题，数据库查询出空字段的\n\n\n\nPost字段的名称是跟实体domain一致的。\n\n实体的字段名称需要和Dto一致！\n\n\n\n修改了字段，记得clean maven！\n\n不然查出来还是空的。\n\n\n\n传入卡片\n\n卡片正文是一个list，appcode 就一个应用，写死，pagecode，\n\n**1.Boolean类型,生成的get方法是get开头的(建议使用这个).**\n**2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).**\n\n\n\ndefined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/rest/ConfigSearchHotController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'configSearchHotServiceImpl' defined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/service/impl/ConfigSearchHotServiceImpl.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'configSearchHotRepository': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Using named parameters for method public abstract void com.tigerobo.dasheng.admin.modules.search.repository.ConfigSearchHotRepository.updateLevel(java.lang.Integer) but parameter 'Optional[targetLevel]' not found in annotated query 'update search_hot_config set level =:level -1 where level >  targetLevel'!\n\tat \n\n\n\nRepository的sql写的有问题， ：或者？都是在传入参数绑定用的，别的和原生sql差不多。\n\nNamed parameter not bound 绑定参数的问题。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtjrn6zdv6j614w0aajs602.jpg)\n\n需要添加事务注解\n\n\n\ncould not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet\"\n\n实体类和DTO和查询类名字要统一，数据库表和column要统一\n\n\n\n然后Maven-clean，重新编译运行。\n","slug":"8月14","published":1,"updated":"2021-08-17T08:16:50.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8i000fc376eoieg6fk","content":"<p>热搜配置： <a href=\"http://10.0.8.61:8011/api/configSearchHot?page=0&amp;size=10&amp;sort=level,asc\">http://10.0.8.61:8011/api/configSearchHot?page=0&amp;size=10&amp;sort=level,asc</a></p>\n<p>热搜统计：<a href=\"http://10.0.8.61:8011/api/countSearchHot?page=0&amp;size=10&amp;sort=searchCounts,desc\">http://10.0.8.61:8011/api/countSearchHot?page=0&amp;size=10&amp;sort=searchCounts,desc</a></p>\n<p>上移下移：</p>\n<p>假设在我们业务逻辑中需要传递一个 <code>UserForm</code>，接收 <code>age,name,param</code> 三个参数。并对其中输入进行进行校验，其中，<code>param</code> 没有具体的含义，只是为了说明问题。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;message&quot;</span>: <span class=\"string\">&quot;must not be blank&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是有些字段不能为空，在实体类里面有定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Column(name=&quot;name&quot;,unique = true,nullable = false)</span></span><br><span class=\"line\">  <span class=\"meta\">@NotBlank</span></span><br><span class=\"line\">  <span class=\"meta\">@ApiModelProperty(value = &quot;展示名称&quot;)</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>是可以既传请求体，也传参数的，</p>\n<p>Target object must not be null; nested exception is java.lang.IllegalArgumentException: Target object must not be null</p>\n<p>哦我弄的put请求。。应该要post的</p>\n<p>8/14我删除了countSearchHot类中没用的字段，以及download的一些相关代码。</p>\n<p>我们一般情况下都是写完代码，commit到本地仓库，生成本地仓库commit ID，当前提交版本号，然后push到远程仓库，。    </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtg52iceinj60hs0dcq3e02.jpg\"></p>\n<p><strong>git pull看起来像git fetch+get merge</strong></p>\n<p>ERROR o.h.e.jdbc.spi.SqlExceptionHelper - Zero date value prohibited</p>\n<p>WARN  o.h.e.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: S1009</p>\n<p>maven报错一般都是导错包，检查检查，不然发布的还是以前的版本</p>\n<p>Dto的字段名称跟数据库对应？</p>\n<p>排序的问题，还有update问题。</p>\n<p>Transaction silently rolled back because it has been marked as rollback-only”,</p>\n<p>​    “data”: <strong>null</strong></p>\n<p>是因为@Trasactional里面的注解写错了</p>\n<p>为什么数据有数据，查出来的字段全部为空null？</p>\n<p>Dto的问题，数据库查询出空字段的</p>\n<p>Post字段的名称是跟实体domain一致的。</p>\n<p>实体的字段名称需要和Dto一致！</p>\n<p>修改了字段，记得clean maven！</p>\n<p>不然查出来还是空的。</p>\n<p>传入卡片</p>\n<p>卡片正文是一个list，appcode 就一个应用，写死，pagecode，</p>\n<p><strong>1.Boolean类型,生成的get方法是get开头的(建议使用这个).</strong><br><strong>2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).</strong></p>\n<p>defined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/rest/ConfigSearchHotController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘configSearchHotServiceImpl’ defined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/service/impl/ConfigSearchHotServiceImpl.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘configSearchHotRepository’: Invocation of init method failed; nested exception is java.lang.IllegalStateException: Using named parameters for method public abstract void com.tigerobo.dasheng.admin.modules.search.repository.ConfigSearchHotRepository.updateLevel(java.lang.Integer) but parameter ‘Optional[targetLevel]’ not found in annotated query ‘update search_hot_config set level =:level -1 where level &gt;  targetLevel’!<br>    at </p>\n<p>Repository的sql写的有问题， ：或者？都是在传入参数绑定用的，别的和原生sql差不多。</p>\n<p>Named parameter not bound 绑定参数的问题。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtjrn6zdv6j614w0aajs602.jpg\"></p>\n<p>需要添加事务注解</p>\n<p>could not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet”</p>\n<p>实体类和DTO和查询类名字要统一，数据库表和column要统一</p>\n<p>然后Maven-clean，重新编译运行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>热搜配置： <a href=\"http://10.0.8.61:8011/api/configSearchHot?page=0&amp;size=10&amp;sort=level,asc\">http://10.0.8.61:8011/api/configSearchHot?page=0&amp;size=10&amp;sort=level,asc</a></p>\n<p>热搜统计：<a href=\"http://10.0.8.61:8011/api/countSearchHot?page=0&amp;size=10&amp;sort=searchCounts,desc\">http://10.0.8.61:8011/api/countSearchHot?page=0&amp;size=10&amp;sort=searchCounts,desc</a></p>\n<p>上移下移：</p>\n<p>假设在我们业务逻辑中需要传递一个 <code>UserForm</code>，接收 <code>age,name,param</code> 三个参数。并对其中输入进行进行校验，其中，<code>param</code> 没有具体的含义，只是为了说明问题。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span>: <span class=\"number\">400</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;message&quot;</span>: <span class=\"string\">&quot;must not be blank&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是有些字段不能为空，在实体类里面有定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Column(name=&quot;name&quot;,unique = true,nullable = false)</span></span><br><span class=\"line\">  <span class=\"meta\">@NotBlank</span></span><br><span class=\"line\">  <span class=\"meta\">@ApiModelProperty(value = &quot;展示名称&quot;)</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>是可以既传请求体，也传参数的，</p>\n<p>Target object must not be null; nested exception is java.lang.IllegalArgumentException: Target object must not be null</p>\n<p>哦我弄的put请求。。应该要post的</p>\n<p>8/14我删除了countSearchHot类中没用的字段，以及download的一些相关代码。</p>\n<p>我们一般情况下都是写完代码，commit到本地仓库，生成本地仓库commit ID，当前提交版本号，然后push到远程仓库，。    </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtg52iceinj60hs0dcq3e02.jpg\"></p>\n<p><strong>git pull看起来像git fetch+get merge</strong></p>\n<p>ERROR o.h.e.jdbc.spi.SqlExceptionHelper - Zero date value prohibited</p>\n<p>WARN  o.h.e.jdbc.spi.SqlExceptionHelper - SQL Error: 0, SQLState: S1009</p>\n<p>maven报错一般都是导错包，检查检查，不然发布的还是以前的版本</p>\n<p>Dto的字段名称跟数据库对应？</p>\n<p>排序的问题，还有update问题。</p>\n<p>Transaction silently rolled back because it has been marked as rollback-only”,</p>\n<p>​    “data”: <strong>null</strong></p>\n<p>是因为@Trasactional里面的注解写错了</p>\n<p>为什么数据有数据，查出来的字段全部为空null？</p>\n<p>Dto的问题，数据库查询出空字段的</p>\n<p>Post字段的名称是跟实体domain一致的。</p>\n<p>实体的字段名称需要和Dto一致！</p>\n<p>修改了字段，记得clean maven！</p>\n<p>不然查出来还是空的。</p>\n<p>传入卡片</p>\n<p>卡片正文是一个list，appcode 就一个应用，写死，pagecode，</p>\n<p><strong>1.Boolean类型,生成的get方法是get开头的(建议使用这个).</strong><br><strong>2.boolean类型,生成的get方法是is开头的(用这个最好重写getXxx()格式的方法).</strong></p>\n<p>defined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/rest/ConfigSearchHotController.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘configSearchHotServiceImpl’ defined in file [/Users/wuzhenren/IdeaProjects/dasheng/dasheng-admin/da-search/target/classes/com/tigerobo/dasheng/admin/modules/search/service/impl/ConfigSearchHotServiceImpl.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘configSearchHotRepository’: Invocation of init method failed; nested exception is java.lang.IllegalStateException: Using named parameters for method public abstract void com.tigerobo.dasheng.admin.modules.search.repository.ConfigSearchHotRepository.updateLevel(java.lang.Integer) but parameter ‘Optional[targetLevel]’ not found in annotated query ‘update search_hot_config set level =:level -1 where level &gt;  targetLevel’!<br>    at </p>\n<p>Repository的sql写的有问题， ：或者？都是在传入参数绑定用的，别的和原生sql差不多。</p>\n<p>Named parameter not bound 绑定参数的问题。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtjrn6zdv6j614w0aajs602.jpg\"></p>\n<p>需要添加事务注解</p>\n<p>could not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet”</p>\n<p>实体类和DTO和查询类名字要统一，数据库表和column要统一</p>\n<p>然后Maven-clean，重新编译运行。</p>\n"},{"title":"8月16-周二-天气晴","date":"2021-08-17T02:26:12.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtkplgeo4bj61900u047002.jpg","_content":"query did not return a unique result\n\n\n\n\n\nsql中':='符号为对变量赋值；\n\n'='符号为if等条件判断中使用；\n\n\n\n啊这 修改丢失了。。\n\n","source":"_posts/8月16-周二-天气晴.md","raw":"---\ntitle: 8月16-周二-天气晴\ndate: 2021-08-17 10:26:12\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtkplgeo4bj61900u047002.jpg\n---\nquery did not return a unique result\n\n\n\n\n\nsql中':='符号为对变量赋值；\n\n'='符号为if等条件判断中使用；\n\n\n\n啊这 修改丢失了。。\n\n","slug":"8月16-周二-天气晴","published":1,"updated":"2021-08-18T01:59:44.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8l000ic376f7ls7t9l","content":"<p>query did not return a unique result</p>\n<p>sql中’:=’符号为对变量赋值；</p>\n<p>‘=’符号为if等条件判断中使用；</p>\n<p>啊这 修改丢失了。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>query did not return a unique result</p>\n<p>sql中’:=’符号为对变量赋值；</p>\n<p>‘=’符号为if等条件判断中使用；</p>\n<p>啊这 修改丢失了。。</p>\n"},{"title":"8月18日","date":"2021-08-18T01:27:57.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtkpjpx1kjj61c80hojtl02.jpg","_content":"\n昨天遗留的bug有点多。热搜那一块根据criteria查询type好像无效。\n\n默认底纹还不知道怎么弄，默认底纹还需要修改。自动补全也还没做。\n\nUpdates were rejected because the tip of your current branch is behind\n解决办法，在push的最后加一个-f， 即强制push。\n\n出现问题的原因，自己手动在远程仓库修改了内容，而自己的仓库没有同步版本，\n\ngit log可以查看commit的历史版本，在一个文件夹存着。\n\ngit push origin c98xxxxxxxxxxxxxx:main\n\n\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtkrgnrmmcj60j807gwfm02.jpg)\n\nfindOneLevelOrderByLevelAsc\n\n\n\nlambda表达式后半段是需要传参数的，名字要注意。\n\n\n\nJpa多条件查询命名规则\n\nfindBy+属性名+\"查询方式\"+\"多条件连接符(and|or)\" +属性名+\"查询方式\"   精准匹配可以省略\n\n\n\nSQL的count语法\n\n```sql\nselect count(column_name) from table_name;\nselect count(distinct column_name) from table_name;\n```\n\n\n\nJpa的sql无缘无故报错极有可能是native没开。\n\n\n\nselect后面接什么只选一条记录呀 limit 1\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtl1vyu0jnj617n0u0dj702.jpg)\n\n原来是Dto里面没有加Data注解。\n\n然后Maven-clean\n","source":"_posts/8月17日.md","raw":"---\ntitle: 8月18日\ndate: 2021-08-18 09:27:57\ncategories: \n- 工作日志\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtkpjpx1kjj61c80hojtl02.jpg\n---\n\n昨天遗留的bug有点多。热搜那一块根据criteria查询type好像无效。\n\n默认底纹还不知道怎么弄，默认底纹还需要修改。自动补全也还没做。\n\nUpdates were rejected because the tip of your current branch is behind\n解决办法，在push的最后加一个-f， 即强制push。\n\n出现问题的原因，自己手动在远程仓库修改了内容，而自己的仓库没有同步版本，\n\ngit log可以查看commit的历史版本，在一个文件夹存着。\n\ngit push origin c98xxxxxxxxxxxxxx:main\n\n\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtkrgnrmmcj60j807gwfm02.jpg)\n\nfindOneLevelOrderByLevelAsc\n\n\n\nlambda表达式后半段是需要传参数的，名字要注意。\n\n\n\nJpa多条件查询命名规则\n\nfindBy+属性名+\"查询方式\"+\"多条件连接符(and|or)\" +属性名+\"查询方式\"   精准匹配可以省略\n\n\n\nSQL的count语法\n\n```sql\nselect count(column_name) from table_name;\nselect count(distinct column_name) from table_name;\n```\n\n\n\nJpa的sql无缘无故报错极有可能是native没开。\n\n\n\nselect后面接什么只选一条记录呀 limit 1\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtl1vyu0jnj617n0u0dj702.jpg)\n\n原来是Dto里面没有加Data注解。\n\n然后Maven-clean\n","slug":"8月17日","published":1,"updated":"2021-08-18T09:26:37.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8l000kc3769v262xmd","content":"<p>昨天遗留的bug有点多。热搜那一块根据criteria查询type好像无效。</p>\n<p>默认底纹还不知道怎么弄，默认底纹还需要修改。自动补全也还没做。</p>\n<p>Updates were rejected because the tip of your current branch is behind<br>解决办法，在push的最后加一个-f， 即强制push。</p>\n<p>出现问题的原因，自己手动在远程仓库修改了内容，而自己的仓库没有同步版本，</p>\n<p>git log可以查看commit的历史版本，在一个文件夹存着。</p>\n<p>git push origin c98xxxxxxxxxxxxxx:main</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtkrgnrmmcj60j807gwfm02.jpg\"></p>\n<p>findOneLevelOrderByLevelAsc</p>\n<p>lambda表达式后半段是需要传参数的，名字要注意。</p>\n<p>Jpa多条件查询命名规则</p>\n<p>findBy+属性名+”查询方式”+”多条件连接符(and|or)” +属性名+”查询方式”   精准匹配可以省略</p>\n<p>SQL的count语法</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(column_name) <span class=\"keyword\">from</span> table_name;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> column_name) <span class=\"keyword\">from</span> table_name;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Jpa的sql无缘无故报错极有可能是native没开。</p>\n<p>select后面接什么只选一条记录呀 limit 1</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtl1vyu0jnj617n0u0dj702.jpg\"></p>\n<p>原来是Dto里面没有加Data注解。</p>\n<p>然后Maven-clean</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天遗留的bug有点多。热搜那一块根据criteria查询type好像无效。</p>\n<p>默认底纹还不知道怎么弄，默认底纹还需要修改。自动补全也还没做。</p>\n<p>Updates were rejected because the tip of your current branch is behind<br>解决办法，在push的最后加一个-f， 即强制push。</p>\n<p>出现问题的原因，自己手动在远程仓库修改了内容，而自己的仓库没有同步版本，</p>\n<p>git log可以查看commit的历史版本，在一个文件夹存着。</p>\n<p>git push origin c98xxxxxxxxxxxxxx:main</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtkrgnrmmcj60j807gwfm02.jpg\"></p>\n<p>findOneLevelOrderByLevelAsc</p>\n<p>lambda表达式后半段是需要传参数的，名字要注意。</p>\n<p>Jpa多条件查询命名规则</p>\n<p>findBy+属性名+”查询方式”+”多条件连接符(and|or)” +属性名+”查询方式”   精准匹配可以省略</p>\n<p>SQL的count语法</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(column_name) <span class=\"keyword\">from</span> table_name;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> column_name) <span class=\"keyword\">from</span> table_name;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Jpa的sql无缘无故报错极有可能是native没开。</p>\n<p>select后面接什么只选一条记录呀 limit 1</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtl1vyu0jnj617n0u0dj702.jpg\"></p>\n<p>原来是Dto里面没有加Data注解。</p>\n<p>然后Maven-clean</p>\n"},{"title":"8月19日","date":"2021-08-19T02:10:22.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtlvn0hptyj61900u0tig02.jpg","_content":"今天开始写搜索的API，面向用户的，。\n\n从今天开始，每天增加两道leetcode题解，放在文章末尾。\n\n注解@Scheduled 可以作为一个触发源添加到一个方法中，例如，以下的方法将以一个固定延迟时间5秒钟调用一次执行，这个周期是以上一个调用任务的完成时间为基准，在上一个任务完成之后，5s后再次执行：\n\n```\n@Scheduled(fixedDelay = 5000)\npublic void doSomething() { \n// something that should execute periodically\n}\n```\n\n\n\nMap遍历的方式：\n\n```java\nMap<Integer,Integer> map=new HashMap<Integer,Integer>();\nfor(Map.Entry<Integer,Integer> entry:map.entrySet()){\n  \n}\n```\n\n\n\n\n\nSpring AOP 中@Pointcut的用法\n\n```java\n@Pointcut(\"execution(public * com.xxxxxx.cnht.search.controller.*.*(..))\")\n```\n\n(..)表示零个或多个任意参数,各个参数也可以用“*”来表示匹配任意类型的参数,全路径的类名等\n\n- 异常类型匹配（throws-pattern?）\n\n在Spring 2.0中，Pointcut的定义包括两个部分：**Pointcut表示式**(expression)和**Pointcut签名**(signature)\n\n```java\n//Pointcut表示式\n@Pointcut(\"execution(* com.savage.aop.MessageSender.*(..))\")\n//Point签名\nprivate void log(){} \n```\n\n然后要使用所定义的Pointcut时，可以指定Pointcut签名\n如下：\n\n```java\n@Before(\"og()\")\n```\n\n\n\n这种使用方式等同于以下方式，直接定义execution表达式使用\n\n```java\n@Before(\"execution(* com.savage.aop.MessageSender.*(..))\")\n```\n\n\n\n\n\n@Around的作用，SpringAOP增强处理\n\n用来在调用一个具体方法前和调用后来完成一些具体的任务。\n\n比如我们想在执行controller中方法前打印出请求参数，并在方法执行结束后来打印出响应值，这个时候，我们就可以借助于@Around注解来实现；\n\n再比如我们想在执行方法时动态修改参数值等\n\n类似功能的注解还有@Before等等，用到了Spring AOP切面思想，Spring AOP常用于拦截器、事务、日志、权限验证等方面。\n\n\n\n- **既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；**\n- **可以决定目标方法在什么时候执行，如何执行，甚至可以完全阻止目标目标方法的执行；**\n- **可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值； 当需要改变目标方法的返回值时，只能使用Around方法；**\n\n虽然Around功能强大，但通常需要在**线程安全的环境**下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。\n\n\n\n切面执行顺序：\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtm48k4p5fj60gw0aymxh02.jpg)\n\n\n\n异常：\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtm49dznucj60gy0axdg502.jpg)\n\n\n\n概念\nJoint Point\nJointPoint是程序运行过程中可识别的点，这个点可以用来作为AOP切入点。JointPoint对象则包含了和切入相关的很多信息。比如切入点的对象，方法，属性等。我们可以通过反射的方式获取这些点的状态和信息，用于追踪tracing和记录logging应用信息。\n\nPointcut\npointcut 是一种程序结构和规则，它用于选取join point并收集这些point的上下文信息。\npointcut通常包含了一系列的Joint Point，我们可以通过pointcut来同时操作jointpoint。单从概念上，可以把Pointcut当做jointpoint的集合。\n\n# java内部类(又名嵌套类)\n\n访问特点：\n\n  内部类可以直接访问外部类的成员，包括私有成员。之所以课直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式 **外部类名.this**\n\n 而外部类要访问内部类中的成员必须要建立内部类的对象\n\n1. 内部类的修饰符\n\n  public ，private static .......\n\n当内部类的修饰符 为static时 ，此时，当外部类加载的时候，该内部类已经存在了。所以我们可以认为其是一个外部类。\n\n此时，访问内部类时，**不需要再new一个外部类的方式去访问**，直接 **Outer.Inner in = new Outer.Inner();**\n\n当内部类中的成员也是静态的，那么久直接 Outer.Inner.function() ，注意： 如果内部类中定义了静态成员，那么该内部类必须是静态的。\n\n访问局部变量，该局部变量就要被定义为final类型，\n\n事实上，当存在有内部类时，经过编译之后，会产生两个class文件，内部类和外部类各一个，那么调用内部类的方法时怎么访问外部类的**局部变量**呢？\n\n实际上，编译后的内部类的构造方法中传入了**对应的外部类的引用**和**所有局部变量的形参**。\n\n由于外部类方法执行完后局部变量会消亡，所以内部类构造函数中的**局部变量实际是一份“复制”**。\n\n而为了访问外部类中的私有成员变量，外部类编译后也产生了访问类似与getXXX的方法。）\n\n**所以如果不修饰为final，可能会造成内部类构造完成之后**，**外部类的局部变量的内容发生了改变**，这是不被允许的。\n\n匿名内部类的具体应用。\n\n 通常的使用场景之一：\n\n  当函数参数是接口类型时，并且接口中的方法不超过3个，可以用匿名内部类作为实际参数，进行传递。\n\n@Builder注解\n\nlombok注解在java进行编译时进行代码的构建，对于java对象的创建工作它可以更优雅，不需要写多余的重复的代码，这对于JAVA开发人员是很重要的，在出现lombok之后，对象的创建工作更提供Builder方法，它提供在设计数据实体时，对外保持private setter，而对属性的赋值采用Builder的方式，这种方式最优雅，也更符合封装的原则，不对外公开属性的写操作！\n\n@Builder声明实体，表示可以进行Builder方式初始化，@Value注解，表示只公开getter，对所有属性的setter都封闭，即private修饰，所以它不能和@Builder现起用\n\n# 注解@Slf4j的使用\n\n声明:**如果不想每次都写private final Logger logger = LoggerFactory.getLogger(当前类名.class); 可以用注解@Slf4j;**\n\n@Slf4j是用作日志输出的，一般会在项目每个类的开头加入该注解，如果不写下面这段代码，并且想用log\n\n输出Info日志\n\n这个日志打印到哪里了呢\n\n在配置文件，如properties,yaml文件内写好输出日志的文件路径。那么log就会输出到对应的文件内，方便后期查看！\n\n代码最后一行的log.info(),这就直接输出到了控制台，如果想要把文件输出到某个文件中的话，你可以在写启动脚本的时候设置输出到什么位置\n\n**@JsonIgnore注解**\n\n**作用：在json序列化时将pojo中的一些属性忽略掉，标记在属性或者方法上，返回的json数据即不包含该属性。**\n\n```java\n@JsonIgnore\nprivate String password;// 密码\n```\n\n\n\nSpring 自 2.0 版本开始，陆续引入了一些注解用于简化 Spring 的开发。@Repository注解便属于最先引入的一批，它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。\n\n同时，为了让 Spring 能够扫描类路径中的类并识别出 @Repository 注解，需要在 XML 配置文件中启用Bean 的自动扫描功能，这可以通过<context:component-scan/>实现。如下所示：\n\n`@Repository`注解修饰哪个类，则表明这个类具有对对象进行CRUD（增删改查）的功能，而且`@Repository`是`@Component`注解的一个派生品，所以被`@Repository`注解的类可以自动的被`@ComponentScan` 通过路径扫描给找到。\n\n\n\n@Query(\"SELECT U FROM User U \")\n    User selectXuanze();\n\n    /**\n     * select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2\n     * 不能用实体传参，只能用list传参\n     * @param name\n     * @param pwd\n     * @return\n     */\n     @Query(\"select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2 \")\n     List<User> selectstatuc(String name, String pwd);\n    @Query(\"SELECT U.name,U.statues FROM User U WHERE U.name=?1 AND U.pwd=?2\")\n    void  selectname(String name,String pwd);\n\n}\n\n@Param是MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应，一般在2=<参数数<=5时使用最佳。\n\n\n\nTomcat 是由 Apache 开发的一个 Servlet 容器，实现了对Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。\n\n\n\n","source":"_posts/8月19日.md","raw":"---\ntitle: 8月19日\ndate: 2021-08-19 10:10:22\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtlvn0hptyj61900u0tig02.jpg\n---\n今天开始写搜索的API，面向用户的，。\n\n从今天开始，每天增加两道leetcode题解，放在文章末尾。\n\n注解@Scheduled 可以作为一个触发源添加到一个方法中，例如，以下的方法将以一个固定延迟时间5秒钟调用一次执行，这个周期是以上一个调用任务的完成时间为基准，在上一个任务完成之后，5s后再次执行：\n\n```\n@Scheduled(fixedDelay = 5000)\npublic void doSomething() { \n// something that should execute periodically\n}\n```\n\n\n\nMap遍历的方式：\n\n```java\nMap<Integer,Integer> map=new HashMap<Integer,Integer>();\nfor(Map.Entry<Integer,Integer> entry:map.entrySet()){\n  \n}\n```\n\n\n\n\n\nSpring AOP 中@Pointcut的用法\n\n```java\n@Pointcut(\"execution(public * com.xxxxxx.cnht.search.controller.*.*(..))\")\n```\n\n(..)表示零个或多个任意参数,各个参数也可以用“*”来表示匹配任意类型的参数,全路径的类名等\n\n- 异常类型匹配（throws-pattern?）\n\n在Spring 2.0中，Pointcut的定义包括两个部分：**Pointcut表示式**(expression)和**Pointcut签名**(signature)\n\n```java\n//Pointcut表示式\n@Pointcut(\"execution(* com.savage.aop.MessageSender.*(..))\")\n//Point签名\nprivate void log(){} \n```\n\n然后要使用所定义的Pointcut时，可以指定Pointcut签名\n如下：\n\n```java\n@Before(\"og()\")\n```\n\n\n\n这种使用方式等同于以下方式，直接定义execution表达式使用\n\n```java\n@Before(\"execution(* com.savage.aop.MessageSender.*(..))\")\n```\n\n\n\n\n\n@Around的作用，SpringAOP增强处理\n\n用来在调用一个具体方法前和调用后来完成一些具体的任务。\n\n比如我们想在执行controller中方法前打印出请求参数，并在方法执行结束后来打印出响应值，这个时候，我们就可以借助于@Around注解来实现；\n\n再比如我们想在执行方法时动态修改参数值等\n\n类似功能的注解还有@Before等等，用到了Spring AOP切面思想，Spring AOP常用于拦截器、事务、日志、权限验证等方面。\n\n\n\n- **既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；**\n- **可以决定目标方法在什么时候执行，如何执行，甚至可以完全阻止目标目标方法的执行；**\n- **可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值； 当需要改变目标方法的返回值时，只能使用Around方法；**\n\n虽然Around功能强大，但通常需要在**线程安全的环境**下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。\n\n\n\n切面执行顺序：\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtm48k4p5fj60gw0aymxh02.jpg)\n\n\n\n异常：\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtm49dznucj60gy0axdg502.jpg)\n\n\n\n概念\nJoint Point\nJointPoint是程序运行过程中可识别的点，这个点可以用来作为AOP切入点。JointPoint对象则包含了和切入相关的很多信息。比如切入点的对象，方法，属性等。我们可以通过反射的方式获取这些点的状态和信息，用于追踪tracing和记录logging应用信息。\n\nPointcut\npointcut 是一种程序结构和规则，它用于选取join point并收集这些point的上下文信息。\npointcut通常包含了一系列的Joint Point，我们可以通过pointcut来同时操作jointpoint。单从概念上，可以把Pointcut当做jointpoint的集合。\n\n# java内部类(又名嵌套类)\n\n访问特点：\n\n  内部类可以直接访问外部类的成员，包括私有成员。之所以课直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式 **外部类名.this**\n\n 而外部类要访问内部类中的成员必须要建立内部类的对象\n\n1. 内部类的修饰符\n\n  public ，private static .......\n\n当内部类的修饰符 为static时 ，此时，当外部类加载的时候，该内部类已经存在了。所以我们可以认为其是一个外部类。\n\n此时，访问内部类时，**不需要再new一个外部类的方式去访问**，直接 **Outer.Inner in = new Outer.Inner();**\n\n当内部类中的成员也是静态的，那么久直接 Outer.Inner.function() ，注意： 如果内部类中定义了静态成员，那么该内部类必须是静态的。\n\n访问局部变量，该局部变量就要被定义为final类型，\n\n事实上，当存在有内部类时，经过编译之后，会产生两个class文件，内部类和外部类各一个，那么调用内部类的方法时怎么访问外部类的**局部变量**呢？\n\n实际上，编译后的内部类的构造方法中传入了**对应的外部类的引用**和**所有局部变量的形参**。\n\n由于外部类方法执行完后局部变量会消亡，所以内部类构造函数中的**局部变量实际是一份“复制”**。\n\n而为了访问外部类中的私有成员变量，外部类编译后也产生了访问类似与getXXX的方法。）\n\n**所以如果不修饰为final，可能会造成内部类构造完成之后**，**外部类的局部变量的内容发生了改变**，这是不被允许的。\n\n匿名内部类的具体应用。\n\n 通常的使用场景之一：\n\n  当函数参数是接口类型时，并且接口中的方法不超过3个，可以用匿名内部类作为实际参数，进行传递。\n\n@Builder注解\n\nlombok注解在java进行编译时进行代码的构建，对于java对象的创建工作它可以更优雅，不需要写多余的重复的代码，这对于JAVA开发人员是很重要的，在出现lombok之后，对象的创建工作更提供Builder方法，它提供在设计数据实体时，对外保持private setter，而对属性的赋值采用Builder的方式，这种方式最优雅，也更符合封装的原则，不对外公开属性的写操作！\n\n@Builder声明实体，表示可以进行Builder方式初始化，@Value注解，表示只公开getter，对所有属性的setter都封闭，即private修饰，所以它不能和@Builder现起用\n\n# 注解@Slf4j的使用\n\n声明:**如果不想每次都写private final Logger logger = LoggerFactory.getLogger(当前类名.class); 可以用注解@Slf4j;**\n\n@Slf4j是用作日志输出的，一般会在项目每个类的开头加入该注解，如果不写下面这段代码，并且想用log\n\n输出Info日志\n\n这个日志打印到哪里了呢\n\n在配置文件，如properties,yaml文件内写好输出日志的文件路径。那么log就会输出到对应的文件内，方便后期查看！\n\n代码最后一行的log.info(),这就直接输出到了控制台，如果想要把文件输出到某个文件中的话，你可以在写启动脚本的时候设置输出到什么位置\n\n**@JsonIgnore注解**\n\n**作用：在json序列化时将pojo中的一些属性忽略掉，标记在属性或者方法上，返回的json数据即不包含该属性。**\n\n```java\n@JsonIgnore\nprivate String password;// 密码\n```\n\n\n\nSpring 自 2.0 版本开始，陆续引入了一些注解用于简化 Spring 的开发。@Repository注解便属于最先引入的一批，它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。\n\n同时，为了让 Spring 能够扫描类路径中的类并识别出 @Repository 注解，需要在 XML 配置文件中启用Bean 的自动扫描功能，这可以通过<context:component-scan/>实现。如下所示：\n\n`@Repository`注解修饰哪个类，则表明这个类具有对对象进行CRUD（增删改查）的功能，而且`@Repository`是`@Component`注解的一个派生品，所以被`@Repository`注解的类可以自动的被`@ComponentScan` 通过路径扫描给找到。\n\n\n\n@Query(\"SELECT U FROM User U \")\n    User selectXuanze();\n\n    /**\n     * select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2\n     * 不能用实体传参，只能用list传参\n     * @param name\n     * @param pwd\n     * @return\n     */\n     @Query(\"select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2 \")\n     List<User> selectstatuc(String name, String pwd);\n    @Query(\"SELECT U.name,U.statues FROM User U WHERE U.name=?1 AND U.pwd=?2\")\n    void  selectname(String name,String pwd);\n\n}\n\n@Param是MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应，一般在2=<参数数<=5时使用最佳。\n\n\n\nTomcat 是由 Apache 开发的一个 Servlet 容器，实现了对Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。\n\n\n\n","slug":"8月19日","published":1,"updated":"2021-08-20T07:20:56.915Z","_id":"cksiamo8n000oc376fu9ohpyn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天开始写搜索的API，面向用户的，。</p>\n<p>从今天开始，每天增加两道leetcode题解，放在文章末尾。</p>\n<p>注解@Scheduled 可以作为一个触发源添加到一个方法中，例如，以下的方法将以一个固定延迟时间5秒钟调用一次执行，这个周期是以上一个调用任务的完成时间为基准，在上一个任务完成之后，5s后再次执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Scheduled(fixedDelay = 5000)</span><br><span class=\"line\">public void doSomething() &#123; </span><br><span class=\"line\">// something that should execute periodically</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Map遍历的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer,Integer&gt; map=<span class=\"keyword\">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>Spring AOP 中@Pointcut的用法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;execution(public * com.xxxxxx.cnht.search.controller.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<p>(..)表示零个或多个任意参数,各个参数也可以用“*”来表示匹配任意类型的参数,全路径的类名等</p>\n<ul>\n<li>异常类型匹配（throws-pattern?）</li>\n</ul>\n<p>在Spring 2.0中，Pointcut的定义包括两个部分：<strong>Pointcut表示式</strong>(expression)和<strong>Pointcut签名</strong>(signature)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Pointcut表示式</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;execution(* com.savage.aop.MessageSender.*(..))&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//Point签名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">()</span></span>&#123;&#125; </span><br></pre></td></tr></table></figure>\n\n<p>然后要使用所定义的Pointcut时，可以指定Pointcut签名<br>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Before(&quot;og()&quot;)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种使用方式等同于以下方式，直接定义execution表达式使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Before(&quot;execution(* com.savage.aop.MessageSender.*(..))&quot;)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>@Around的作用，SpringAOP增强处理</p>\n<p>用来在调用一个具体方法前和调用后来完成一些具体的任务。</p>\n<p>比如我们想在执行controller中方法前打印出请求参数，并在方法执行结束后来打印出响应值，这个时候，我们就可以借助于@Around注解来实现；</p>\n<p>再比如我们想在执行方法时动态修改参数值等</p>\n<p>类似功能的注解还有@Before等等，用到了Spring AOP切面思想，Spring AOP常用于拦截器、事务、日志、权限验证等方面。</p>\n<ul>\n<li><strong>既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</strong></li>\n<li><strong>可以决定目标方法在什么时候执行，如何执行，甚至可以完全阻止目标目标方法的执行；</strong></li>\n<li><strong>可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值； 当需要改变目标方法的返回值时，只能使用Around方法；</strong></li>\n</ul>\n<p>虽然Around功能强大，但通常需要在<strong>线程安全的环境</strong>下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p>\n<p>切面执行顺序：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtm48k4p5fj60gw0aymxh02.jpg\"></p>\n<p>异常：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtm49dznucj60gy0axdg502.jpg\"></p>\n<p>概念<br>Joint Point<br>JointPoint是程序运行过程中可识别的点，这个点可以用来作为AOP切入点。JointPoint对象则包含了和切入相关的很多信息。比如切入点的对象，方法，属性等。我们可以通过反射的方式获取这些点的状态和信息，用于追踪tracing和记录logging应用信息。</p>\n<p>Pointcut<br>pointcut 是一种程序结构和规则，它用于选取join point并收集这些point的上下文信息。<br>pointcut通常包含了一系列的Joint Point，我们可以通过pointcut来同时操作jointpoint。单从概念上，可以把Pointcut当做jointpoint的集合。</p>\n<h1 id=\"java内部类-又名嵌套类\"><a href=\"#java内部类-又名嵌套类\" class=\"headerlink\" title=\"java内部类(又名嵌套类)\"></a>java内部类(又名嵌套类)</h1><p>访问特点：</p>\n<p>  内部类可以直接访问外部类的成员，包括私有成员。之所以课直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式 <strong>外部类名.this</strong></p>\n<p> 而外部类要访问内部类中的成员必须要建立内部类的对象</p>\n<ol>\n<li>内部类的修饰符</li>\n</ol>\n<p>  public ，private static …….</p>\n<p>当内部类的修饰符 为static时 ，此时，当外部类加载的时候，该内部类已经存在了。所以我们可以认为其是一个外部类。</p>\n<p>此时，访问内部类时，<strong>不需要再new一个外部类的方式去访问</strong>，直接 <strong>Outer.Inner in = new Outer.Inner();</strong></p>\n<p>当内部类中的成员也是静态的，那么久直接 Outer.Inner.function() ，注意： 如果内部类中定义了静态成员，那么该内部类必须是静态的。</p>\n<p>访问局部变量，该局部变量就要被定义为final类型，</p>\n<p>事实上，当存在有内部类时，经过编译之后，会产生两个class文件，内部类和外部类各一个，那么调用内部类的方法时怎么访问外部类的<strong>局部变量</strong>呢？</p>\n<p>实际上，编译后的内部类的构造方法中传入了<strong>对应的外部类的引用</strong>和<strong>所有局部变量的形参</strong>。</p>\n<p>由于外部类方法执行完后局部变量会消亡，所以内部类构造函数中的<strong>局部变量实际是一份“复制”</strong>。</p>\n<p>而为了访问外部类中的私有成员变量，外部类编译后也产生了访问类似与getXXX的方法。）</p>\n<p><strong>所以如果不修饰为final，可能会造成内部类构造完成之后</strong>，<strong>外部类的局部变量的内容发生了改变</strong>，这是不被允许的。</p>\n<p>匿名内部类的具体应用。</p>\n<p> 通常的使用场景之一：</p>\n<p>  当函数参数是接口类型时，并且接口中的方法不超过3个，可以用匿名内部类作为实际参数，进行传递。</p>\n<p>@Builder注解</p>\n<p>lombok注解在java进行编译时进行代码的构建，对于java对象的创建工作它可以更优雅，不需要写多余的重复的代码，这对于JAVA开发人员是很重要的，在出现lombok之后，对象的创建工作更提供Builder方法，它提供在设计数据实体时，对外保持private setter，而对属性的赋值采用Builder的方式，这种方式最优雅，也更符合封装的原则，不对外公开属性的写操作！</p>\n<p>@Builder声明实体，表示可以进行Builder方式初始化，@Value注解，表示只公开getter，对所有属性的setter都封闭，即private修饰，所以它不能和@Builder现起用</p>\n<h1 id=\"注解-Slf4j的使用\"><a href=\"#注解-Slf4j的使用\" class=\"headerlink\" title=\"注解@Slf4j的使用\"></a>注解@Slf4j的使用</h1><p>声明:<strong>如果不想每次都写private final Logger logger = LoggerFactory.getLogger(当前类名.class); 可以用注解@Slf4j;</strong></p>\n<p>@Slf4j是用作日志输出的，一般会在项目每个类的开头加入该注解，如果不写下面这段代码，并且想用log</p>\n<p>输出Info日志</p>\n<p>这个日志打印到哪里了呢</p>\n<p>在配置文件，如properties,yaml文件内写好输出日志的文件路径。那么log就会输出到对应的文件内，方便后期查看！</p>\n<p>代码最后一行的log.info(),这就直接输出到了控制台，如果想要把文件输出到某个文件中的话，你可以在写启动脚本的时候设置输出到什么位置</p>\n<p><strong>@JsonIgnore注解</strong></p>\n<p><strong>作用：在json序列化时将pojo中的一些属性忽略掉，标记在属性或者方法上，返回的json数据即不包含该属性。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@JsonIgnore</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String password;<span class=\"comment\">// 密码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Spring 自 2.0 版本开始，陆续引入了一些注解用于简化 Spring 的开发。@Repository注解便属于最先引入的一批，它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。</p>\n<p>同时，为了让 Spring 能够扫描类路径中的类并识别出 @Repository 注解，需要在 XML 配置文件中启用Bean 的自动扫描功能，这可以通过<a href=\"context:component-scan/\">context:component-scan/</a>实现。如下所示：</p>\n<p><code>@Repository</code>注解修饰哪个类，则表明这个类具有对对象进行CRUD（增删改查）的功能，而且<code>@Repository</code>是<code>@Component</code>注解的一个派生品，所以被<code>@Repository</code>注解的类可以自动的被<code>@ComponentScan</code> 通过路径扫描给找到。</p>\n<p>@Query(“SELECT U FROM User U “)<br>    User selectXuanze();</p>\n<pre><code>/**\n * select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2\n * 不能用实体传参，只能用list传参\n * @param name\n * @param pwd\n * @return\n */\n @Query(&quot;select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2 &quot;)\n List&lt;User&gt; selectstatuc(String name, String pwd);\n@Query(&quot;SELECT U.name,U.statues FROM User U WHERE U.name=?1 AND U.pwd=?2&quot;)\nvoid  selectname(String name,String pwd);\n</code></pre>\n<p>}</p>\n<p>@Param是MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应，一般在2=&lt;参数数&lt;=5时使用最佳。</p>\n<p>Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天开始写搜索的API，面向用户的，。</p>\n<p>从今天开始，每天增加两道leetcode题解，放在文章末尾。</p>\n<p>注解@Scheduled 可以作为一个触发源添加到一个方法中，例如，以下的方法将以一个固定延迟时间5秒钟调用一次执行，这个周期是以上一个调用任务的完成时间为基准，在上一个任务完成之后，5s后再次执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Scheduled(fixedDelay = 5000)</span><br><span class=\"line\">public void doSomething() &#123; </span><br><span class=\"line\">// something that should execute periodically</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Map遍历的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer,Integer&gt; map=<span class=\"keyword\">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>Spring AOP 中@Pointcut的用法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;execution(public * com.xxxxxx.cnht.search.controller.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<p>(..)表示零个或多个任意参数,各个参数也可以用“*”来表示匹配任意类型的参数,全路径的类名等</p>\n<ul>\n<li>异常类型匹配（throws-pattern?）</li>\n</ul>\n<p>在Spring 2.0中，Pointcut的定义包括两个部分：<strong>Pointcut表示式</strong>(expression)和<strong>Pointcut签名</strong>(signature)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Pointcut表示式</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;execution(* com.savage.aop.MessageSender.*(..))&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//Point签名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">()</span></span>&#123;&#125; </span><br></pre></td></tr></table></figure>\n\n<p>然后要使用所定义的Pointcut时，可以指定Pointcut签名<br>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Before(&quot;og()&quot;)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种使用方式等同于以下方式，直接定义execution表达式使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Before(&quot;execution(* com.savage.aop.MessageSender.*(..))&quot;)</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>@Around的作用，SpringAOP增强处理</p>\n<p>用来在调用一个具体方法前和调用后来完成一些具体的任务。</p>\n<p>比如我们想在执行controller中方法前打印出请求参数，并在方法执行结束后来打印出响应值，这个时候，我们就可以借助于@Around注解来实现；</p>\n<p>再比如我们想在执行方法时动态修改参数值等</p>\n<p>类似功能的注解还有@Before等等，用到了Spring AOP切面思想，Spring AOP常用于拦截器、事务、日志、权限验证等方面。</p>\n<ul>\n<li><strong>既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</strong></li>\n<li><strong>可以决定目标方法在什么时候执行，如何执行，甚至可以完全阻止目标目标方法的执行；</strong></li>\n<li><strong>可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值； 当需要改变目标方法的返回值时，只能使用Around方法；</strong></li>\n</ul>\n<p>虽然Around功能强大，但通常需要在<strong>线程安全的环境</strong>下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p>\n<p>切面执行顺序：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtm48k4p5fj60gw0aymxh02.jpg\"></p>\n<p>异常：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtm49dznucj60gy0axdg502.jpg\"></p>\n<p>概念<br>Joint Point<br>JointPoint是程序运行过程中可识别的点，这个点可以用来作为AOP切入点。JointPoint对象则包含了和切入相关的很多信息。比如切入点的对象，方法，属性等。我们可以通过反射的方式获取这些点的状态和信息，用于追踪tracing和记录logging应用信息。</p>\n<p>Pointcut<br>pointcut 是一种程序结构和规则，它用于选取join point并收集这些point的上下文信息。<br>pointcut通常包含了一系列的Joint Point，我们可以通过pointcut来同时操作jointpoint。单从概念上，可以把Pointcut当做jointpoint的集合。</p>\n<h1 id=\"java内部类-又名嵌套类\"><a href=\"#java内部类-又名嵌套类\" class=\"headerlink\" title=\"java内部类(又名嵌套类)\"></a>java内部类(又名嵌套类)</h1><p>访问特点：</p>\n<p>  内部类可以直接访问外部类的成员，包括私有成员。之所以课直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式 <strong>外部类名.this</strong></p>\n<p> 而外部类要访问内部类中的成员必须要建立内部类的对象</p>\n<ol>\n<li>内部类的修饰符</li>\n</ol>\n<p>  public ，private static …….</p>\n<p>当内部类的修饰符 为static时 ，此时，当外部类加载的时候，该内部类已经存在了。所以我们可以认为其是一个外部类。</p>\n<p>此时，访问内部类时，<strong>不需要再new一个外部类的方式去访问</strong>，直接 <strong>Outer.Inner in = new Outer.Inner();</strong></p>\n<p>当内部类中的成员也是静态的，那么久直接 Outer.Inner.function() ，注意： 如果内部类中定义了静态成员，那么该内部类必须是静态的。</p>\n<p>访问局部变量，该局部变量就要被定义为final类型，</p>\n<p>事实上，当存在有内部类时，经过编译之后，会产生两个class文件，内部类和外部类各一个，那么调用内部类的方法时怎么访问外部类的<strong>局部变量</strong>呢？</p>\n<p>实际上，编译后的内部类的构造方法中传入了<strong>对应的外部类的引用</strong>和<strong>所有局部变量的形参</strong>。</p>\n<p>由于外部类方法执行完后局部变量会消亡，所以内部类构造函数中的<strong>局部变量实际是一份“复制”</strong>。</p>\n<p>而为了访问外部类中的私有成员变量，外部类编译后也产生了访问类似与getXXX的方法。）</p>\n<p><strong>所以如果不修饰为final，可能会造成内部类构造完成之后</strong>，<strong>外部类的局部变量的内容发生了改变</strong>，这是不被允许的。</p>\n<p>匿名内部类的具体应用。</p>\n<p> 通常的使用场景之一：</p>\n<p>  当函数参数是接口类型时，并且接口中的方法不超过3个，可以用匿名内部类作为实际参数，进行传递。</p>\n<p>@Builder注解</p>\n<p>lombok注解在java进行编译时进行代码的构建，对于java对象的创建工作它可以更优雅，不需要写多余的重复的代码，这对于JAVA开发人员是很重要的，在出现lombok之后，对象的创建工作更提供Builder方法，它提供在设计数据实体时，对外保持private setter，而对属性的赋值采用Builder的方式，这种方式最优雅，也更符合封装的原则，不对外公开属性的写操作！</p>\n<p>@Builder声明实体，表示可以进行Builder方式初始化，@Value注解，表示只公开getter，对所有属性的setter都封闭，即private修饰，所以它不能和@Builder现起用</p>\n<h1 id=\"注解-Slf4j的使用\"><a href=\"#注解-Slf4j的使用\" class=\"headerlink\" title=\"注解@Slf4j的使用\"></a>注解@Slf4j的使用</h1><p>声明:<strong>如果不想每次都写private final Logger logger = LoggerFactory.getLogger(当前类名.class); 可以用注解@Slf4j;</strong></p>\n<p>@Slf4j是用作日志输出的，一般会在项目每个类的开头加入该注解，如果不写下面这段代码，并且想用log</p>\n<p>输出Info日志</p>\n<p>这个日志打印到哪里了呢</p>\n<p>在配置文件，如properties,yaml文件内写好输出日志的文件路径。那么log就会输出到对应的文件内，方便后期查看！</p>\n<p>代码最后一行的log.info(),这就直接输出到了控制台，如果想要把文件输出到某个文件中的话，你可以在写启动脚本的时候设置输出到什么位置</p>\n<p><strong>@JsonIgnore注解</strong></p>\n<p><strong>作用：在json序列化时将pojo中的一些属性忽略掉，标记在属性或者方法上，返回的json数据即不包含该属性。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@JsonIgnore</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String password;<span class=\"comment\">// 密码</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Spring 自 2.0 版本开始，陆续引入了一些注解用于简化 Spring 的开发。@Repository注解便属于最先引入的一批，它用于将数据访问层 (DAO 层 ) 的类标识为 Spring Bean。具体只需将该注解标注在 DAO类上即可。</p>\n<p>同时，为了让 Spring 能够扫描类路径中的类并识别出 @Repository 注解，需要在 XML 配置文件中启用Bean 的自动扫描功能，这可以通过<a href=\"context:component-scan/\">context:component-scan/</a>实现。如下所示：</p>\n<p><code>@Repository</code>注解修饰哪个类，则表明这个类具有对对象进行CRUD（增删改查）的功能，而且<code>@Repository</code>是<code>@Component</code>注解的一个派生品，所以被<code>@Repository</code>注解的类可以自动的被<code>@ComponentScan</code> 通过路径扫描给找到。</p>\n<p>@Query(“SELECT U FROM User U “)<br>    User selectXuanze();</p>\n<pre><code>/**\n * select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2\n * 不能用实体传参，只能用list传参\n * @param name\n * @param pwd\n * @return\n */\n @Query(&quot;select u.name ,u.statues from User u where u.name=?1 and u.pwd=?2 &quot;)\n List&lt;User&gt; selectstatuc(String name, String pwd);\n@Query(&quot;SELECT U.name,U.statues FROM User U WHERE U.name=?1 AND U.pwd=?2&quot;)\nvoid  selectname(String name,String pwd);\n</code></pre>\n<p>}</p>\n<p>@Param是MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应，一般在2=&lt;参数数&lt;=5时使用最佳。</p>\n<p>Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。</p>\n"},{"title":"8月2日","date":"2021-08-02T02:27:44.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt28mj2ze1j31900u0ag0.jpg","_content":"git remote命令可以查看到远程仓库的简短名称：\n\n\n\n如果要看具体的URL，可以用git remote -v,发现关联的远程仓库就是我自己的github仓库:\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt2714mwtkj30sc0a8did.jpg)\n\n使用git remote add remote git@github.com:antirez/redis.git 把这个远程仓库添加到remote中：\n\n\n\nGit fetch此命令会到远程仓库中拉取对应你本地仓库中还没有的数据，\n\n但注意**它只是把远程分支到你本地对于到分支上的数据更新**了，你本地的库里面还是没有任何数据的。比如我在远程库修改了Test.txt\n\n\n\n此时再接着执行merge操作，把远程库的代码merge到你本地库版本当中就会有数据了。\n\n## Java开发手册\n\n### 命名规范\n\n在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。\n\nstartTime / workQueue / nameList / TERMINATED_THREAD_COUNT\n\n如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n\n正例： public class OrderFactory;\n\n​\t\t\tpublic class LoginProxy;\n\n​\t\t\tpublic class ResourceObserver;\n\n接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。\n\n正例：\n\n接口方法签名 void commit();\n\n接口基础常量 String COMPANY = \"alibaba\"; \n\nA) Service/DAO层方法命名规约    \n\n- 获取单个对象的方法用get做前缀。    \n\n- 获取多个对象的方法用list做前缀，复数形式结尾如：listObjects。    \n\n- 获取统计值的方法用count做前缀。    \n\n- 插入的方法用save/insert做前缀。    \n\n- 删除的方法用remove/delete做前缀。    \n\n- 修改的方法用update做前缀。\n\nB) 领域模型命名规约 \n\n- 数据对象：xxxDO，xxx即为数据表名。\n- 数据传输对象：xxxDTO，xxx为业务领域相关的名称。\n- 展示对象：xxxVO，xxx一般为网页名称。\n- POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。\n\n采用4个空格缩进，禁止使用tab字符。 说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。\n\n注释的双斜线与注释内容之间有且仅有一个空格。 \n\n正例：   // 这是示例注释，请注意在双斜线之后有一个空格\n\n\n\n不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 说明：任何情形，没有必要插入多个空行进行隔开。\n\n所有整型包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在 IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。\n\n### 关于基本数据类型与包装数据类型的使用标准如下：\n\n所有的POJO类属性必须使用包装数据类型。\n\nRPC方法的返回值和参数必须使用包装数据类型。\n\n所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。\n\n\n\n数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。\n\n\n\n定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。\n\nPOJO类必须写toString方法。使用IDE中的工具：source> generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。\n\n说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。\n\n当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。 19. 【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter 方法。\n\n慎用Object的clone方法来拷贝对象。 说明：对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。\n\n深拷贝实现方法：\n\n1. JSON方法\n\n- 将对象转换为json字符串形式\n- 将转换而来的字符串转换为原生js对象JSON.parse\n\n#### 类成员与方法访问控制从严：\n\n1. 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。\n2. 工具类不允许有public或default构造方法。\n3. 类非static成员变量并且与子类共享，必须是protected。\n4. 类非static成员变量并且仅在本类使用，必须是private。\n5. 类static成员变量如果仅在本类使用，必须是private。\n6. 若是static成员变量，考虑是否为final。final修饰的时候代表对象只能赋值一次，要求它的值不能再被修改。\n7. 类成员方法只供类内部调用，必须是private。\n8. 类成员方法只对继承类公开，那么限制为protected。\n\n任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。\n\n\n\n#### 集合\n\n关于hashCode和equals的处理，遵循如下规则： 1） 只要覆写equals，就必须覆写hashCode。 2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。 3） 如果自定义对象作为Map的键，那么必须覆写hashCode和equals。\n\n**说明：**String已覆写hashCode和equals方法，所以我们可以愉快地使用String对象作为key来使用。\n\n在使用Collection接口任何实现类的addAll()方法时，都要对输入的集合参数进行NPE判断。\n\n说明：在ArrayList#addAll方法的第一行代码即Object[] a = c.toArray(); 其中c为输入集合参数，如果为null，则直接抛出异常。\n\n使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 \n\n**说明**：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n---\n\nautowire注解，什么时候需要，什么时候不需要，\n\n@RequiredConstructed注解 以及和final之间的关系\n\nc t r l+Alt+鼠标左键，或者加b\n\nfieldname： 字段名\n\njoinname：外联？\n\nEntity 中与部门关联的字段名称\n\n注解类：自定义的可以成为java程序标记的类\n\ngetClass().getAnnotation 返回注解类的注解\n\n**Pageable** 是Spring Data库中定义的一个接口，**用于构造翻页查询**，是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关所有信息（例如pageNumber、pageSize等），这样，Jpa就能够通过pageable参数来得到一个带分页信息的Sql语句。\n\nElasticsearch也是使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过**简单连贯的RESTful API**让**全文搜索**变得简单并隐藏Lucene的复杂性。\n\n不过，Elasticsearch不仅仅是Lucene和全文搜索引擎，它还提供：\n\n- 分布式的实时文件存储，**每个字段**都被索引并可被**搜索**\n- **实时分析**的**分布式搜索引擎**\n- 可以扩展到上百台服务器，处理PB级**结构化或非结构化数据**\n\n**结构化和非结构化**\n\n关系数据库用于结构化数据，大多数其他类型的应用程序用于非结构化数据。\n\n结构化数据也称作**行数据**，是由**二维表**结构来逻辑**表达和实现**的数据，严格地遵循数据格式与长度规范，主要通过**关系型数据库**进行存储和管理。\n\n与结构化数据相对的是**不适于由数据库二维表来表现的非结构化数据**，包括所有格式的办公文档、XML、HTML、各类报表、图片和音频、视频信息等。\n\n","source":"_posts/8月2日.md","raw":"---\ntitle: 8月2日\ndate: 2021-08-02 10:27:44\ncategories:\n- Spring Boot\n- 工作日志\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt28mj2ze1j31900u0ag0.jpg\n\n---\ngit remote命令可以查看到远程仓库的简短名称：\n\n\n\n如果要看具体的URL，可以用git remote -v,发现关联的远程仓库就是我自己的github仓库:\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt2714mwtkj30sc0a8did.jpg)\n\n使用git remote add remote git@github.com:antirez/redis.git 把这个远程仓库添加到remote中：\n\n\n\nGit fetch此命令会到远程仓库中拉取对应你本地仓库中还没有的数据，\n\n但注意**它只是把远程分支到你本地对于到分支上的数据更新**了，你本地的库里面还是没有任何数据的。比如我在远程库修改了Test.txt\n\n\n\n此时再接着执行merge操作，把远程库的代码merge到你本地库版本当中就会有数据了。\n\n## Java开发手册\n\n### 命名规范\n\n在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。\n\nstartTime / workQueue / nameList / TERMINATED_THREAD_COUNT\n\n如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n\n正例： public class OrderFactory;\n\n​\t\t\tpublic class LoginProxy;\n\n​\t\t\tpublic class ResourceObserver;\n\n接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。\n\n正例：\n\n接口方法签名 void commit();\n\n接口基础常量 String COMPANY = \"alibaba\"; \n\nA) Service/DAO层方法命名规约    \n\n- 获取单个对象的方法用get做前缀。    \n\n- 获取多个对象的方法用list做前缀，复数形式结尾如：listObjects。    \n\n- 获取统计值的方法用count做前缀。    \n\n- 插入的方法用save/insert做前缀。    \n\n- 删除的方法用remove/delete做前缀。    \n\n- 修改的方法用update做前缀。\n\nB) 领域模型命名规约 \n\n- 数据对象：xxxDO，xxx即为数据表名。\n- 数据传输对象：xxxDTO，xxx为业务领域相关的名称。\n- 展示对象：xxxVO，xxx一般为网页名称。\n- POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。\n\n采用4个空格缩进，禁止使用tab字符。 说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。\n\n注释的双斜线与注释内容之间有且仅有一个空格。 \n\n正例：   // 这是示例注释，请注意在双斜线之后有一个空格\n\n\n\n不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 说明：任何情形，没有必要插入多个空行进行隔开。\n\n所有整型包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在 IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。\n\n### 关于基本数据类型与包装数据类型的使用标准如下：\n\n所有的POJO类属性必须使用包装数据类型。\n\nRPC方法的返回值和参数必须使用包装数据类型。\n\n所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。\n\n\n\n数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。\n\n\n\n定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。\n\nPOJO类必须写toString方法。使用IDE中的工具：source> generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。\n\n说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。\n\n当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。 19. 【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter 方法。\n\n慎用Object的clone方法来拷贝对象。 说明：对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。\n\n深拷贝实现方法：\n\n1. JSON方法\n\n- 将对象转换为json字符串形式\n- 将转换而来的字符串转换为原生js对象JSON.parse\n\n#### 类成员与方法访问控制从严：\n\n1. 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。\n2. 工具类不允许有public或default构造方法。\n3. 类非static成员变量并且与子类共享，必须是protected。\n4. 类非static成员变量并且仅在本类使用，必须是private。\n5. 类static成员变量如果仅在本类使用，必须是private。\n6. 若是static成员变量，考虑是否为final。final修饰的时候代表对象只能赋值一次，要求它的值不能再被修改。\n7. 类成员方法只供类内部调用，必须是private。\n8. 类成员方法只对继承类公开，那么限制为protected。\n\n任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。\n\n\n\n#### 集合\n\n关于hashCode和equals的处理，遵循如下规则： 1） 只要覆写equals，就必须覆写hashCode。 2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。 3） 如果自定义对象作为Map的键，那么必须覆写hashCode和equals。\n\n**说明：**String已覆写hashCode和equals方法，所以我们可以愉快地使用String对象作为key来使用。\n\n在使用Collection接口任何实现类的addAll()方法时，都要对输入的集合参数进行NPE判断。\n\n说明：在ArrayList#addAll方法的第一行代码即Object[] a = c.toArray(); 其中c为输入集合参数，如果为null，则直接抛出异常。\n\n使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 \n\n**说明**：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n---\n\nautowire注解，什么时候需要，什么时候不需要，\n\n@RequiredConstructed注解 以及和final之间的关系\n\nc t r l+Alt+鼠标左键，或者加b\n\nfieldname： 字段名\n\njoinname：外联？\n\nEntity 中与部门关联的字段名称\n\n注解类：自定义的可以成为java程序标记的类\n\ngetClass().getAnnotation 返回注解类的注解\n\n**Pageable** 是Spring Data库中定义的一个接口，**用于构造翻页查询**，是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关所有信息（例如pageNumber、pageSize等），这样，Jpa就能够通过pageable参数来得到一个带分页信息的Sql语句。\n\nElasticsearch也是使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过**简单连贯的RESTful API**让**全文搜索**变得简单并隐藏Lucene的复杂性。\n\n不过，Elasticsearch不仅仅是Lucene和全文搜索引擎，它还提供：\n\n- 分布式的实时文件存储，**每个字段**都被索引并可被**搜索**\n- **实时分析**的**分布式搜索引擎**\n- 可以扩展到上百台服务器，处理PB级**结构化或非结构化数据**\n\n**结构化和非结构化**\n\n关系数据库用于结构化数据，大多数其他类型的应用程序用于非结构化数据。\n\n结构化数据也称作**行数据**，是由**二维表**结构来逻辑**表达和实现**的数据，严格地遵循数据格式与长度规范，主要通过**关系型数据库**进行存储和管理。\n\n与结构化数据相对的是**不适于由数据库二维表来表现的非结构化数据**，包括所有格式的办公文档、XML、HTML、各类报表、图片和音频、视频信息等。\n\n","slug":"8月2日","published":1,"updated":"2021-08-02T12:08:44.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8o000pc37621j8hrre","content":"<p>git remote命令可以查看到远程仓库的简短名称：</p>\n<p>如果要看具体的URL，可以用git remote -v,发现关联的远程仓库就是我自己的github仓库:</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt2714mwtkj30sc0a8did.jpg\"></p>\n<p>使用git remote add remote <a href=\"mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;\">&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:antirez/redis.git 把这个远程仓库添加到remote中：</p>\n<p>Git fetch此命令会到远程仓库中拉取对应你本地仓库中还没有的数据，</p>\n<p>但注意<strong>它只是把远程分支到你本地对于到分支上的数据更新</strong>了，你本地的库里面还是没有任何数据的。比如我在远程库修改了Test.txt</p>\n<p>此时再接着执行merge操作，把远程库的代码merge到你本地库版本当中就会有数据了。</p>\n<h2 id=\"Java开发手册\"><a href=\"#Java开发手册\" class=\"headerlink\" title=\"Java开发手册\"></a>Java开发手册</h2><h3 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h3><p>在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p>\n<p>startTime / workQueue / nameList / TERMINATED_THREAD_COUNT</p>\n<p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>\n<p>正例： public class OrderFactory;</p>\n<p>​            public class LoginProxy;</p>\n<p>​            public class ResourceObserver;</p>\n<p>接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</p>\n<p>正例：</p>\n<p>接口方法签名 void commit();</p>\n<p>接口基础常量 String COMPANY = “alibaba”; </p>\n<p>A) Service/DAO层方法命名规约    </p>\n<ul>\n<li><p>获取单个对象的方法用get做前缀。    </p>\n</li>\n<li><p>获取多个对象的方法用list做前缀，复数形式结尾如：listObjects。    </p>\n</li>\n<li><p>获取统计值的方法用count做前缀。    </p>\n</li>\n<li><p>插入的方法用save/insert做前缀。    </p>\n</li>\n<li><p>删除的方法用remove/delete做前缀。    </p>\n</li>\n<li><p>修改的方法用update做前缀。</p>\n</li>\n</ul>\n<p>B) 领域模型命名规约 </p>\n<ul>\n<li>数据对象：xxxDO，xxx即为数据表名。</li>\n<li>数据传输对象：xxxDTO，xxx为业务领域相关的名称。</li>\n<li>展示对象：xxxVO，xxx一般为网页名称。</li>\n<li>POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</li>\n</ul>\n<p>采用4个空格缩进，禁止使用tab字符。 说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。</p>\n<p>注释的双斜线与注释内容之间有且仅有一个空格。 </p>\n<p>正例：   // 这是示例注释，请注意在双斜线之后有一个空格</p>\n<p>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 说明：任何情形，没有必要插入多个空行进行隔开。</p>\n<p>所有整型包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在 IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p>\n<h3 id=\"关于基本数据类型与包装数据类型的使用标准如下：\"><a href=\"#关于基本数据类型与包装数据类型的使用标准如下：\" class=\"headerlink\" title=\"关于基本数据类型与包装数据类型的使用标准如下：\"></a>关于基本数据类型与包装数据类型的使用标准如下：</h3><p>所有的POJO类属性必须使用包装数据类型。</p>\n<p>RPC方法的返回值和参数必须使用包装数据类型。</p>\n<p>所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。</p>\n<p>数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。</p>\n<p>定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。</p>\n<p>POJO类必须写toString方法。使用IDE中的工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。</p>\n<p>说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</p>\n<p>当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。 19. 【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter 方法。</p>\n<p>慎用Object的clone方法来拷贝对象。 说明：对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。</p>\n<p>深拷贝实现方法：</p>\n<ol>\n<li>JSON方法</li>\n</ol>\n<ul>\n<li>将对象转换为json字符串形式</li>\n<li>将转换而来的字符串转换为原生js对象JSON.parse</li>\n</ul>\n<h4 id=\"类成员与方法访问控制从严：\"><a href=\"#类成员与方法访问控制从严：\" class=\"headerlink\" title=\"类成员与方法访问控制从严：\"></a>类成员与方法访问控制从严：</h4><ol>\n<li>如果不允许外部直接通过new来创建对象，那么构造方法必须是private。</li>\n<li>工具类不允许有public或default构造方法。</li>\n<li>类非static成员变量并且与子类共享，必须是protected。</li>\n<li>类非static成员变量并且仅在本类使用，必须是private。</li>\n<li>类static成员变量如果仅在本类使用，必须是private。</li>\n<li>若是static成员变量，考虑是否为final。final修饰的时候代表对象只能赋值一次，要求它的值不能再被修改。</li>\n<li>类成员方法只供类内部调用，必须是private。</li>\n<li>类成员方法只对继承类公开，那么限制为protected。</li>\n</ol>\n<p>任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。</p>\n<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>关于hashCode和equals的处理，遵循如下规则： 1） 只要覆写equals，就必须覆写hashCode。 2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。 3） 如果自定义对象作为Map的键，那么必须覆写hashCode和equals。</p>\n<p><strong>说明：</strong>String已覆写hashCode和equals方法，所以我们可以愉快地使用String对象作为key来使用。</p>\n<p>在使用Collection接口任何实现类的addAll()方法时，都要对输入的集合参数进行NPE判断。</p>\n<p>说明：在ArrayList#addAll方法的第一行代码即Object[] a = c.toArray(); 其中c为输入集合参数，如果为null，则直接抛出异常。</p>\n<p>使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 </p>\n<p><strong>说明</strong>：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>\n<hr>\n<p>autowire注解，什么时候需要，什么时候不需要，</p>\n<p>@RequiredConstructed注解 以及和final之间的关系</p>\n<p>c t r l+Alt+鼠标左键，或者加b</p>\n<p>fieldname： 字段名</p>\n<p>joinname：外联？</p>\n<p>Entity 中与部门关联的字段名称</p>\n<p>注解类：自定义的可以成为java程序标记的类</p>\n<p>getClass().getAnnotation 返回注解类的注解</p>\n<p><strong>Pageable</strong> 是Spring Data库中定义的一个接口，<strong>用于构造翻页查询</strong>，是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关所有信息（例如pageNumber、pageSize等），这样，Jpa就能够通过pageable参数来得到一个带分页信息的Sql语句。</p>\n<p>Elasticsearch也是使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过<strong>简单连贯的RESTful API</strong>让<strong>全文搜索</strong>变得简单并隐藏Lucene的复杂性。</p>\n<p>不过，Elasticsearch不仅仅是Lucene和全文搜索引擎，它还提供：</p>\n<ul>\n<li>分布式的实时文件存储，<strong>每个字段</strong>都被索引并可被<strong>搜索</strong></li>\n<li><strong>实时分析</strong>的<strong>分布式搜索引擎</strong></li>\n<li>可以扩展到上百台服务器，处理PB级<strong>结构化或非结构化数据</strong></li>\n</ul>\n<p><strong>结构化和非结构化</strong></p>\n<p>关系数据库用于结构化数据，大多数其他类型的应用程序用于非结构化数据。</p>\n<p>结构化数据也称作<strong>行数据</strong>，是由<strong>二维表</strong>结构来逻辑<strong>表达和实现</strong>的数据，严格地遵循数据格式与长度规范，主要通过<strong>关系型数据库</strong>进行存储和管理。</p>\n<p>与结构化数据相对的是<strong>不适于由数据库二维表来表现的非结构化数据</strong>，包括所有格式的办公文档、XML、HTML、各类报表、图片和音频、视频信息等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>git remote命令可以查看到远程仓库的简短名称：</p>\n<p>如果要看具体的URL，可以用git remote -v,发现关联的远程仓库就是我自己的github仓库:</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt2714mwtkj30sc0a8did.jpg\"></p>\n<p>使用git remote add remote <a href=\"mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;\">&#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:antirez/redis.git 把这个远程仓库添加到remote中：</p>\n<p>Git fetch此命令会到远程仓库中拉取对应你本地仓库中还没有的数据，</p>\n<p>但注意<strong>它只是把远程分支到你本地对于到分支上的数据更新</strong>了，你本地的库里面还是没有任何数据的。比如我在远程库修改了Test.txt</p>\n<p>此时再接着执行merge操作，把远程库的代码merge到你本地库版本当中就会有数据了。</p>\n<h2 id=\"Java开发手册\"><a href=\"#Java开发手册\" class=\"headerlink\" title=\"Java开发手册\"></a>Java开发手册</h2><h3 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h3><p>在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p>\n<p>startTime / workQueue / nameList / TERMINATED_THREAD_COUNT</p>\n<p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>\n<p>正例： public class OrderFactory;</p>\n<p>​            public class LoginProxy;</p>\n<p>​            public class ResourceObserver;</p>\n<p>接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</p>\n<p>正例：</p>\n<p>接口方法签名 void commit();</p>\n<p>接口基础常量 String COMPANY = “alibaba”; </p>\n<p>A) Service/DAO层方法命名规约    </p>\n<ul>\n<li><p>获取单个对象的方法用get做前缀。    </p>\n</li>\n<li><p>获取多个对象的方法用list做前缀，复数形式结尾如：listObjects。    </p>\n</li>\n<li><p>获取统计值的方法用count做前缀。    </p>\n</li>\n<li><p>插入的方法用save/insert做前缀。    </p>\n</li>\n<li><p>删除的方法用remove/delete做前缀。    </p>\n</li>\n<li><p>修改的方法用update做前缀。</p>\n</li>\n</ul>\n<p>B) 领域模型命名规约 </p>\n<ul>\n<li>数据对象：xxxDO，xxx即为数据表名。</li>\n<li>数据传输对象：xxxDTO，xxx为业务领域相关的名称。</li>\n<li>展示对象：xxxVO，xxx一般为网页名称。</li>\n<li>POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</li>\n</ul>\n<p>采用4个空格缩进，禁止使用tab字符。 说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。</p>\n<p>注释的双斜线与注释内容之间有且仅有一个空格。 </p>\n<p>正例：   // 这是示例注释，请注意在双斜线之后有一个空格</p>\n<p>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。 说明：任何情形，没有必要插入多个空行进行隔开。</p>\n<p>所有整型包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在 IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p>\n<h3 id=\"关于基本数据类型与包装数据类型的使用标准如下：\"><a href=\"#关于基本数据类型与包装数据类型的使用标准如下：\" class=\"headerlink\" title=\"关于基本数据类型与包装数据类型的使用标准如下：\"></a>关于基本数据类型与包装数据类型的使用标准如下：</h3><p>所有的POJO类属性必须使用包装数据类型。</p>\n<p>RPC方法的返回值和参数必须使用包装数据类型。</p>\n<p>所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。</p>\n<p>数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。</p>\n<p>定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。</p>\n<p>POJO类必须写toString方法。使用IDE中的工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。</p>\n<p>说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</p>\n<p>当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条。 19. 【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter 方法。</p>\n<p>慎用Object的clone方法来拷贝对象。 说明：对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。</p>\n<p>深拷贝实现方法：</p>\n<ol>\n<li>JSON方法</li>\n</ol>\n<ul>\n<li>将对象转换为json字符串形式</li>\n<li>将转换而来的字符串转换为原生js对象JSON.parse</li>\n</ul>\n<h4 id=\"类成员与方法访问控制从严：\"><a href=\"#类成员与方法访问控制从严：\" class=\"headerlink\" title=\"类成员与方法访问控制从严：\"></a>类成员与方法访问控制从严：</h4><ol>\n<li>如果不允许外部直接通过new来创建对象，那么构造方法必须是private。</li>\n<li>工具类不允许有public或default构造方法。</li>\n<li>类非static成员变量并且与子类共享，必须是protected。</li>\n<li>类非static成员变量并且仅在本类使用，必须是private。</li>\n<li>类static成员变量如果仅在本类使用，必须是private。</li>\n<li>若是static成员变量，考虑是否为final。final修饰的时候代表对象只能赋值一次，要求它的值不能再被修改。</li>\n<li>类成员方法只供类内部调用，必须是private。</li>\n<li>类成员方法只对继承类公开，那么限制为protected。</li>\n</ol>\n<p>任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。</p>\n<h4 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h4><p>关于hashCode和equals的处理，遵循如下规则： 1） 只要覆写equals，就必须覆写hashCode。 2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两个方法。 3） 如果自定义对象作为Map的键，那么必须覆写hashCode和equals。</p>\n<p><strong>说明：</strong>String已覆写hashCode和equals方法，所以我们可以愉快地使用String对象作为key来使用。</p>\n<p>在使用Collection接口任何实现类的addAll()方法时，都要对输入的集合参数进行NPE判断。</p>\n<p>说明：在ArrayList#addAll方法的第一行代码即Object[] a = c.toArray(); 其中c为输入集合参数，如果为null，则直接抛出异常。</p>\n<p>使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 </p>\n<p><strong>说明</strong>：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>\n<hr>\n<p>autowire注解，什么时候需要，什么时候不需要，</p>\n<p>@RequiredConstructed注解 以及和final之间的关系</p>\n<p>c t r l+Alt+鼠标左键，或者加b</p>\n<p>fieldname： 字段名</p>\n<p>joinname：外联？</p>\n<p>Entity 中与部门关联的字段名称</p>\n<p>注解类：自定义的可以成为java程序标记的类</p>\n<p>getClass().getAnnotation 返回注解类的注解</p>\n<p><strong>Pageable</strong> 是Spring Data库中定义的一个接口，<strong>用于构造翻页查询</strong>，是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关所有信息（例如pageNumber、pageSize等），这样，Jpa就能够通过pageable参数来得到一个带分页信息的Sql语句。</p>\n<p>Elasticsearch也是使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过<strong>简单连贯的RESTful API</strong>让<strong>全文搜索</strong>变得简单并隐藏Lucene的复杂性。</p>\n<p>不过，Elasticsearch不仅仅是Lucene和全文搜索引擎，它还提供：</p>\n<ul>\n<li>分布式的实时文件存储，<strong>每个字段</strong>都被索引并可被<strong>搜索</strong></li>\n<li><strong>实时分析</strong>的<strong>分布式搜索引擎</strong></li>\n<li>可以扩展到上百台服务器，处理PB级<strong>结构化或非结构化数据</strong></li>\n</ul>\n<p><strong>结构化和非结构化</strong></p>\n<p>关系数据库用于结构化数据，大多数其他类型的应用程序用于非结构化数据。</p>\n<p>结构化数据也称作<strong>行数据</strong>，是由<strong>二维表</strong>结构来逻辑<strong>表达和实现</strong>的数据，严格地遵循数据格式与长度规范，主要通过<strong>关系型数据库</strong>进行存储和管理。</p>\n<p>与结构化数据相对的是<strong>不适于由数据库二维表来表现的非结构化数据</strong>，包括所有格式的办公文档、XML、HTML、各类报表、图片和音频、视频信息等。</p>\n"},{"title":"8月3日","date":"2021-08-03T01:29:25.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt3no19bjkj30u0190wmk.jpg","_content":"\n今天六点以后要开始看论文了。看到9点半\n\n\n\n今天遇到个bug，是我在GetMapping那里打了断点，影响我运行，结果一直跑不起来，\n\nRequiredArgsConstructor可以代替Autowired注解，注入时需要用final定义\n\n装配分为三种： byName，byType，construct\n\n- byName就是会将与属性一样的bean进行装配\n- byType是同属性一样类型的bean进行装配\n- constructor就是通过构造器来将类型与参数相同的bean进行装配。\n\n@Autowired注解是byType类型的，这个注解可以用在属性上面，setter方面上面以及构造器上面。使用这个注解时，就不需要在类中为属性添加setter方法了\n\n**但是这个属性是强制性的，也就是说必须得装配上，如果没有找到合适的bean能够装配上，就会抛出异常。**\n\n这时可以使用required=false来允许可以不被装配上，默认值为true。当required=true时，@Autowired要求必须装配，但是在没有bean能装配上时，就会抛出异常：NoSuchBeanDefinitionException。\n\n如果required=false时，则不会抛出异常。\n\n- @Inject必须是强制装配的，没有required属性，也就是不能为null，如果不存在匹配的bean，会抛出异常。\n- 自动装配时，装配的bean必须是唯一与属性进行吻合的，不能多也不能少，有且只有一个可以进行装配的bean，才能自动装配成功。否则会抛出异常。\n\n@Retention作用是定义**被它所注解的注解保留多久**，\n\n**启用级联**后，更新一个表的主键值，系统会相应地**更新所有匹配的外键值**，如果在表A中将姓名为张三的记录改为李四，那么表B中的姓名为张三的所有记录也会随着改为李四。级联删除与更新相类似。如果在表A中将姓名为张三的记录删除，那么表B中的姓名为张三的所有记录也将删除。\n\nnothing to commit, working tree clean\nssh: connect to host github.com port 22: Operation timed out\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n这种错误基本都是因为vpn，网上不去\n\n什么是Database，什么是Schema，什么是Table，什么是列，什么是行，什么是User？\n\n我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间。\n\nTable可以看作是每个Schema中的床，Table（床）就被放入每个房间中，\n\nDataBase>Scheme>Table\n\n\n\nLucene 是一个基于 Java 的全文信息检索工具包，目前主流的搜索系统Elasticsearch和solr都是基于lucene的索引和搜索能力进行。\n\n\n\nlucene是如何存储需要检索的数据，以及如何完成高效的数据检索？\n\n\n\n---\n\n会议，貌似主要是建表、字段的问题，表建好了，别的容易了\n\nqq处理器，有分词，\n\nxxbox\n\n增量更新，\n\n算法埋点，\n\n","source":"_posts/8月3日.md","raw":"---\ntitle: 8月3日\ndate: 2021-08-03 09:29:25\ncategories:\n- 工作日志\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt3no19bjkj30u0190wmk.jpg\n---\n\n今天六点以后要开始看论文了。看到9点半\n\n\n\n今天遇到个bug，是我在GetMapping那里打了断点，影响我运行，结果一直跑不起来，\n\nRequiredArgsConstructor可以代替Autowired注解，注入时需要用final定义\n\n装配分为三种： byName，byType，construct\n\n- byName就是会将与属性一样的bean进行装配\n- byType是同属性一样类型的bean进行装配\n- constructor就是通过构造器来将类型与参数相同的bean进行装配。\n\n@Autowired注解是byType类型的，这个注解可以用在属性上面，setter方面上面以及构造器上面。使用这个注解时，就不需要在类中为属性添加setter方法了\n\n**但是这个属性是强制性的，也就是说必须得装配上，如果没有找到合适的bean能够装配上，就会抛出异常。**\n\n这时可以使用required=false来允许可以不被装配上，默认值为true。当required=true时，@Autowired要求必须装配，但是在没有bean能装配上时，就会抛出异常：NoSuchBeanDefinitionException。\n\n如果required=false时，则不会抛出异常。\n\n- @Inject必须是强制装配的，没有required属性，也就是不能为null，如果不存在匹配的bean，会抛出异常。\n- 自动装配时，装配的bean必须是唯一与属性进行吻合的，不能多也不能少，有且只有一个可以进行装配的bean，才能自动装配成功。否则会抛出异常。\n\n@Retention作用是定义**被它所注解的注解保留多久**，\n\n**启用级联**后，更新一个表的主键值，系统会相应地**更新所有匹配的外键值**，如果在表A中将姓名为张三的记录改为李四，那么表B中的姓名为张三的所有记录也会随着改为李四。级联删除与更新相类似。如果在表A中将姓名为张三的记录删除，那么表B中的姓名为张三的所有记录也将删除。\n\nnothing to commit, working tree clean\nssh: connect to host github.com port 22: Operation timed out\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n这种错误基本都是因为vpn，网上不去\n\n什么是Database，什么是Schema，什么是Table，什么是列，什么是行，什么是User？\n\n我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间。\n\nTable可以看作是每个Schema中的床，Table（床）就被放入每个房间中，\n\nDataBase>Scheme>Table\n\n\n\nLucene 是一个基于 Java 的全文信息检索工具包，目前主流的搜索系统Elasticsearch和solr都是基于lucene的索引和搜索能力进行。\n\n\n\nlucene是如何存储需要检索的数据，以及如何完成高效的数据检索？\n\n\n\n---\n\n会议，貌似主要是建表、字段的问题，表建好了，别的容易了\n\nqq处理器，有分词，\n\nxxbox\n\n增量更新，\n\n算法埋点，\n\n","slug":"8月3日","published":1,"updated":"2021-08-05T01:34:48.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8p000rc3762d7qdm2f","content":"<p>今天六点以后要开始看论文了。看到9点半</p>\n<p>今天遇到个bug，是我在GetMapping那里打了断点，影响我运行，结果一直跑不起来，</p>\n<p>RequiredArgsConstructor可以代替Autowired注解，注入时需要用final定义</p>\n<p>装配分为三种： byName，byType，construct</p>\n<ul>\n<li>byName就是会将与属性一样的bean进行装配</li>\n<li>byType是同属性一样类型的bean进行装配</li>\n<li>constructor就是通过构造器来将类型与参数相同的bean进行装配。</li>\n</ul>\n<p>@Autowired注解是byType类型的，这个注解可以用在属性上面，setter方面上面以及构造器上面。使用这个注解时，就不需要在类中为属性添加setter方法了</p>\n<p><strong>但是这个属性是强制性的，也就是说必须得装配上，如果没有找到合适的bean能够装配上，就会抛出异常。</strong></p>\n<p>这时可以使用required=false来允许可以不被装配上，默认值为true。当required=true时，@Autowired要求必须装配，但是在没有bean能装配上时，就会抛出异常：NoSuchBeanDefinitionException。</p>\n<p>如果required=false时，则不会抛出异常。</p>\n<ul>\n<li>@Inject必须是强制装配的，没有required属性，也就是不能为null，如果不存在匹配的bean，会抛出异常。</li>\n<li>自动装配时，装配的bean必须是唯一与属性进行吻合的，不能多也不能少，有且只有一个可以进行装配的bean，才能自动装配成功。否则会抛出异常。</li>\n</ul>\n<p>@Retention作用是定义<strong>被它所注解的注解保留多久</strong>，</p>\n<p><strong>启用级联</strong>后，更新一个表的主键值，系统会相应地<strong>更新所有匹配的外键值</strong>，如果在表A中将姓名为张三的记录改为李四，那么表B中的姓名为张三的所有记录也会随着改为李四。级联删除与更新相类似。如果在表A中将姓名为张三的记录删除，那么表B中的姓名为张三的所有记录也将删除。</p>\n<p>nothing to commit, working tree clean<br>ssh: connect to host github.com port 22: Operation timed out<br>fatal: Could not read from remote repository.</p>\n<p>Please make sure you have the correct access rights<br>and the repository exists.</p>\n<p>这种错误基本都是因为vpn，网上不去</p>\n<p>什么是Database，什么是Schema，什么是Table，什么是列，什么是行，什么是User？</p>\n<p>我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间。</p>\n<p>Table可以看作是每个Schema中的床，Table（床）就被放入每个房间中，</p>\n<p>DataBase&gt;Scheme&gt;Table</p>\n<p>Lucene 是一个基于 Java 的全文信息检索工具包，目前主流的搜索系统Elasticsearch和solr都是基于lucene的索引和搜索能力进行。</p>\n<p>lucene是如何存储需要检索的数据，以及如何完成高效的数据检索？</p>\n<hr>\n<p>会议，貌似主要是建表、字段的问题，表建好了，别的容易了</p>\n<p>qq处理器，有分词，</p>\n<p>xxbox</p>\n<p>增量更新，</p>\n<p>算法埋点，</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天六点以后要开始看论文了。看到9点半</p>\n<p>今天遇到个bug，是我在GetMapping那里打了断点，影响我运行，结果一直跑不起来，</p>\n<p>RequiredArgsConstructor可以代替Autowired注解，注入时需要用final定义</p>\n<p>装配分为三种： byName，byType，construct</p>\n<ul>\n<li>byName就是会将与属性一样的bean进行装配</li>\n<li>byType是同属性一样类型的bean进行装配</li>\n<li>constructor就是通过构造器来将类型与参数相同的bean进行装配。</li>\n</ul>\n<p>@Autowired注解是byType类型的，这个注解可以用在属性上面，setter方面上面以及构造器上面。使用这个注解时，就不需要在类中为属性添加setter方法了</p>\n<p><strong>但是这个属性是强制性的，也就是说必须得装配上，如果没有找到合适的bean能够装配上，就会抛出异常。</strong></p>\n<p>这时可以使用required=false来允许可以不被装配上，默认值为true。当required=true时，@Autowired要求必须装配，但是在没有bean能装配上时，就会抛出异常：NoSuchBeanDefinitionException。</p>\n<p>如果required=false时，则不会抛出异常。</p>\n<ul>\n<li>@Inject必须是强制装配的，没有required属性，也就是不能为null，如果不存在匹配的bean，会抛出异常。</li>\n<li>自动装配时，装配的bean必须是唯一与属性进行吻合的，不能多也不能少，有且只有一个可以进行装配的bean，才能自动装配成功。否则会抛出异常。</li>\n</ul>\n<p>@Retention作用是定义<strong>被它所注解的注解保留多久</strong>，</p>\n<p><strong>启用级联</strong>后，更新一个表的主键值，系统会相应地<strong>更新所有匹配的外键值</strong>，如果在表A中将姓名为张三的记录改为李四，那么表B中的姓名为张三的所有记录也会随着改为李四。级联删除与更新相类似。如果在表A中将姓名为张三的记录删除，那么表B中的姓名为张三的所有记录也将删除。</p>\n<p>nothing to commit, working tree clean<br>ssh: connect to host github.com port 22: Operation timed out<br>fatal: Could not read from remote repository.</p>\n<p>Please make sure you have the correct access rights<br>and the repository exists.</p>\n<p>这种错误基本都是因为vpn，网上不去</p>\n<p>什么是Database，什么是Schema，什么是Table，什么是列，什么是行，什么是User？</p>\n<p>我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间。</p>\n<p>Table可以看作是每个Schema中的床，Table（床）就被放入每个房间中，</p>\n<p>DataBase&gt;Scheme&gt;Table</p>\n<p>Lucene 是一个基于 Java 的全文信息检索工具包，目前主流的搜索系统Elasticsearch和solr都是基于lucene的索引和搜索能力进行。</p>\n<p>lucene是如何存储需要检索的数据，以及如何完成高效的数据检索？</p>\n<hr>\n<p>会议，貌似主要是建表、字段的问题，表建好了，别的容易了</p>\n<p>qq处理器，有分词，</p>\n<p>xxbox</p>\n<p>增量更新，</p>\n<p>算法埋点，</p>\n"},{"title":"8月4日","date":"2021-08-04T02:09:49.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt4j949zagj31900u0gus.jpg","_content":"\npage类，\n\n分页使用到的，分页无非就是使用到类 select * from table limit FROM,TO\n\n在数据库中做分页查询的时候，我们要想知道获取数据的起始位置和结束位置，就要知道每页显示的数据个数，\n\n我们可以根据数据总个数和每页显示的数据个数算出来总页数。\n\n#### page类\n\n```java\npublic class PageBean<T>(){\n  //1. 当前页数 从页面获取\n  private int currentPage;\n  //2. 每页显示数据个数，赋初值或者setter获取\n  private int currentCount;\n  //3. 总条数，从数据库获取\n  private int totalRecord;\n  //4. 总页数，计算得到\n  private int totalPage;\n  //5. 每页的显示数据，从数据库得到\n  List<T> list=new ArrayList<>();\n  ```\n  getter()和setter()方法\n}\n```\n\n\n\n#### SearchRequest类\n\n```java\npublic class SearchRequest {\n\n    private Integer From;\n    private Integer pageSize;\n    //.....其他查询条件\n    private String name;\n    private String age;\n\n    getter()和setter()方法\n}\n\n```\n\n\n\n#### Controller层\n\n```java\n@RequestMapping(value = \"/Page.action\")\npublic @ResponseBody PageBean<> SearchRecordPage(SearchRequest searchRequest, PageBean pagebean){\n  //\n  int totalRecord=service.getPageSize(searchRequest);\n  pageBean.setTotalRecord(totalRecord);pageBean.setTotalPage((int) Math.ceil((pageBean.getTotalRecord()*1.0)/pageBean.getCurrentCount()));\n//获取当前点击页面的数据（pageBean前台传错来一个页面显示多少条，和页码数）\nList<> list = service.getRecord(searchRequest,pageBean);\n//返回前台数据\n  pageBean.setList(list);\n  return pageBean;\n}\n```\n\n\n\nService的书写\n\nSearchRequest包含了From和pageSize\n\n```java\npublic List<T> getRecord(SearchRequest searchRequest, PageBean<ResultClassName> pageBean) {\n        //数据库进行分页的方法searchrequest加入from 和to\n        //当前页面\n        int currentPage=pageBean.getCurrentPage();  \n        //页面的显示个数\n        int currentCount=pageBean.getCurrentCount();\n        //根据页面算出数据库查询的起始位置\n        int from=currentCount*(currentPage-1);\n        //获取的数据个数\n        int pageSize=currentCount;\n        //将查询范围在查询条件里\n\t\t\t\tsearchRequest.setFrom(From);\n        searchRequest.setPageSize(pageSize);\n        //根据以上条件返回目的对象\n        pageBean.setList( Mapper.getRecord(searchRequest));\n        return pageBean; \n}\n```\n\nSQL的写法\n\n```sql\n<select id=\"getRepairRecord\" resultType=\"ResultClassName\"\n\t\tparameterType=\"SearchRequest\">\n\t\tSELECT *\n\t\tFROM 表名\n\t\t<where>\n\t\t\t\t<if test=\"name!=null and name!=''\">\n\t\t\t\t\t\tand name=#{name}</if>\n\t\t\t\t<if test=\"age!=null and age!=''\">\n\t\t\t\t\t\tand age=#{age}\n\t\t\t\t</if>\n\t\t\t</where>\n\t\t\t<if test=\"From!=null  and pageSize!=null\">\n            limit #{From},#{pageSize}\n         </if>\n         </select>\n\t\t\t\t\n```\n\n\n\n## java8的lambda表达式：\n\n前世-匿名类\n\n举一个匿名类的例子：\n\nComparator接口：\n\n```java\npublic interface Comparator<T> {\n  int compare(T o1, T o2);\n}\n```\n\n使用匿名类创建排序的比较方法：注意new Comparator\n\n```java\nCollections.sort(words, new Comparator<String>(){\n  public int compare(String s1, String s2){\n    return Integer.compare(s1.length(),s2.length())\n  }\n});\n```\n\n匿名类适用于需要函数对象的经典面向对象设计模式，特别是策略模式，上面的匿名类是排序字符串的具体策略。**然而，匿名类确实过于冗长。**\n\n起到的作用是，新new了一个接口，接口一个方法为compare，有两个参数s1，s2,\n\n\n\n##### 为什么sort里面要有一个Comparator接口，这么麻烦\n\nsort点进去有binarysort，不管Objcet实际是什么类型的，都可以使用接口中定义的方法。\n\n可能会有个疑问，为什么不在Object这个超类中定义这个方法然后子类重写，而是要用实现接口呢。这个嘛，是因为大部分用不着这个功能，写上去就会用浪费，我们就用接口来弥补，你要你就实现接口。\n\n### Lambda表达式的今生\n\n在 Java 8 中，语言形式化了这样的概念，即使用**单个抽象方法的接口是特别的**，应该得到特别的对待。即一个接口只有一个方法。\n\n这些接口现在称为**函数式接口**，并且该语言允许你**使用lambda 表达式或简称 lambda 来创建这些接口的实例。**\n\nLambdas 在功能上与匿名类相似，但更为简洁。下面的代码使用 lambdas 替换上面的匿名类。清晰明了\n\n```java\nCollections.sort(words,(s1,s2)->\n                Integer.compare(s1.length(),s2.length()))\n```\n\n\n\n```java\nnew Comparator<String>(){\n  public int compare(String s1, String s2){\n    return Integer.compare(s1.length(),s2.length())\n  }\n}\n```\n\n\n\n等价于\n\n```java\n(s1,s2)->Integer.compare(s1.length(),s2.length())\n```\n\n右边的东西形成了一个函数，这个函数需要两个参数，s1,s2.\n\n```java\ncustomSchemaRepository.findAll((root,criteriaQuery,criteriaBuilder) -> QueryHelp.getPredicate(root,criteria,criteriaBuilder))\n```\n\n\n\n### Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\n\n1. 使用Lambda表达式必须具有接口，且要求接口中有且仅有一个抽象方法。\n2. 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。\n\n### Lambda标准形式\n\n### (参数类型 参数名称) ‐> { 代码语句 }\n\n说明：\n\n1. 小括号内：没有参数就留空（），多个参数就用逗号分隔。\n2. -> 是新引入的语法格式，代表指向动作。\n3. 大括号内的语法与传统方法体要求基本一致。\n\n### Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\n\n在Lambda表达式标准形式的基础上：\n\n1. 小括号内参数的类型可以省略；\n2. 如果小括号内只有一个参数，则小括号可以省略；\n3. 如果大括号内只有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。\n\n综上所述，从 Java 8 开始，lambda 是迄今为止表示小函数对象的最佳方式。除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。\n\n备注：有且仅有一个抽象方法的接口，称为“函数式接口”。\n\n\n\n内连接（INNER JOIN）实例\n\n**LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。**\n\n```sql\nSELECT column_name(s) FROM table_name WHERE column_name LIKE pattern\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt4rqhbp72j31b20fcmyw.jpg)\n\n现在，我们希望从上面的 \"Persons\" 表中选取居住在以 \"N\" 开始的城市里的人：\n\n我们可以使用下面的 SELECT 语句：\n\n```sql\nSELECT * FROM Persons\nWHERE City LIKE 'N%'\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt4rr2kf49j31ak08q74y.jpg)\n\nTF-IDF（term frequency–inverse document frequency）\n\n是一种用于[信息检索](https://baike.baidu.com/item/信息检索/831904)与数据挖掘的常用加权技术。\n\nTF是词频(**Term** Frequency)，IDF是逆文本频率指数(Inverse Document Frequency)。\n\n\n\n# ES(elasticsearch)搜索引擎\n\n#### 什么是搜索?\n\n根据一个搜索词，检索出所有包含该词的数据\n例如：用户在搜索框输入一个词，客户端软件发送一个请求到后台，后台通过sql语句从数据库中找出相关条目(数据库会**一条一条的对比**)，这就是一个最简单搜索原型\n\n#### 普通搜索面临的问题\n\n1, 当数据量很大时，假如500G， 效率低。从用户角度，从点击搜索按钮到看到搜索结果可能要很长时间，1小时？2小时？用户疯掉\n\n2, 当数据量达到1T，一台电脑已经放不下了，这时候就需要多台，这就是分布式。这时候数据就在不同的服务器了，一个客户端不可能去请求每台机器，所以就需要一个管理员角色，负责把客户端请求分发到每台机器，同时汇总结果返回给客户端\n\n#### 普通搜索速度简单优化(倒排索引)\n\n数据库每个条目的名称进行分词，形成一个key为词，value为条目id的数据表。同时对用户输入的搜索词进行分词，检索出每个词在数据库中的id，求个交集，然后把这些id查不出返回就行了。\n\n输入 复仇者联盟， 经过分词后变成\n[复仇者，联盟]\n倒排索引表也已经建好了，可能长这样\n复仇者 4，5，6，11 数字为文档编号\n联盟 5，9，11\n\n#### 倒排索引\n\n需要根据属性的值来查找记录，这种**索引表中的每一项**都包括一个[属性值, 具有该属性值的各个记录的地址]。\n\n由于不是由记录来确定属性值，而是由**属性值来确定记录的位置**，因而称为倒排索引(inverted index)。\n\n带有倒排索引的文件我们称为倒排[索引文件](https://baike.baidu.com/item/索引文件)，简称[倒排文件](https://baike.baidu.com/item/倒排文件/4137688)(inverted file)。\n\n倒排列表用来记录有**哪些文档**包含了**某个单词**，一般在文档集合里会有很多文档 **包含**某个单词，每个文档会记录**文档编号（DocID)**,单词在这个文档中出现的**次数（TF）**及单词在文档中**哪些位置出现过等信息**.这样与一个文档相关的信息被称做倒排索引项（Posting）。并不存储倒排索引项中的实际文档编号，而是代之以文档编号差值（D-Gap），原始的 3个文档编号分别是187、196和199，通过编号差值计算，在实际存储的时候就转化成了：187、9、3。\n\n之所以要对文档编号进行差值计算，主要原因是为了更好地对数据进行压缩，原始文档编号一般都是大数值，通过差值计算，就有效地将大数值转换为了小数值，而这有助于增加数据的压缩率。\n\n##### 索引构建方法\n\n###### 简单法\n\n索引的构建相当于从正排表到倒排表的建立过程。当我们分析完网页时 ,得到的是以网页为主码的索引表。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt4zlokt0sj30j205pgly.jpg)\n\n流程描述如下：\n\n1）将文档分析成单词term标记，\n\n2）使用hash去重单词term\n\n3）对单词生成倒排列表\n\n倒排列表就是文档编号DocID，没有包含其他的信息（如词频，单词位置等），这就是简单的索引。\n\n这个简单索引功能可以用于小数据，例如索引几千个文档。然而它有两点限制：\n\n1）需要有足够的内存来存储倒排表，对于搜索引擎来说， 都是G级别数据，特别是当规模不断扩大时 ,我们根本不可能提供这么多的内存。\n\n2）算法是顺序执行，不便于并行处理。\n\n###### 合并法\n\n归并法,即每次将内存中数据写入磁盘时，包括词典在内的所有中间结果信息都被写入磁盘，这样内存所有内容都可以被清空，后续建立索引可以使用全部的定额内存。\n\n[![图4归并索引](https://bkimg.cdn.bcebos.com/pic/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/倒排索引/11001569/0/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?fr=lemma&ct=single)图4归并索引\n\n如图4归并示意图：\n\n**合并流程：**\n\n1）页面分析，生成临时倒排数据索引A，B，当临时倒排数据索引A，B占满内存后，将内存索引A，B写入临时文件生成临时倒排文件，\n\n\\2) 对生成的多个临时倒排文件 ,执行多路归并 ,输出得到最终的倒排文件 ( inverted file)。\n\n[![合并流程](https://bkimg.cdn.bcebos.com/pic/91529822720e0cf3226631b10b46f21fbf09aae3?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/倒排索引/11001569/0/91529822720e0cf3226631b10b46f21fbf09aae3?fr=lemma&ct=single)合并流程\n\n索引创建过程中的页面分析 ,特别是中文分词为主要时间开销。算法的第二步相对很快。这样创建算法的优化集中在中文分词效率上。\n\n假设只存在正向索引（forward index），那么就需要扫描索引库中的所有文档，找出所有包含关键词“华为手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。\n\n\n\n得到**正向索引**的结构如下：\n\n​    “文档1”的ID > 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。\n\n​    “文档2”的ID > 此文档出现的关键词列表。\n\n[文档ID,关键词]\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt507hvr8qj30kb092q3f.jpg)\n\n因为互联网上收录在搜索引擎中的文档的数目是个天文数字，**这样的索引结构根本无法满足实时返回排名结果的要求。**\n\n就是每个关键词都要去扫描库中的所有文档\n\n**所以，搜索引擎会将正向索引重新构建为倒排索引**，即把文件ID对应到关键词的映射转换为**关键词到文件ID的映射**\n\n[关键词,文件ID]\n\n![img](https://images2015.cnblogs.com/blog/855959/201707/855959-20170706154505378-610589524.png)\n\n　　从词的关键字，去找文档。\n\n###### 单词-文档矩阵\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt508mmtcdj30co076mxg.jpg)\n\n","source":"_posts/8月4日.md","raw":"---\ntitle: 8月4日\ndate: 2021-08-04 10:09:49\ncategories:\n- 工作日志\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt4j949zagj31900u0gus.jpg\n---\n\npage类，\n\n分页使用到的，分页无非就是使用到类 select * from table limit FROM,TO\n\n在数据库中做分页查询的时候，我们要想知道获取数据的起始位置和结束位置，就要知道每页显示的数据个数，\n\n我们可以根据数据总个数和每页显示的数据个数算出来总页数。\n\n#### page类\n\n```java\npublic class PageBean<T>(){\n  //1. 当前页数 从页面获取\n  private int currentPage;\n  //2. 每页显示数据个数，赋初值或者setter获取\n  private int currentCount;\n  //3. 总条数，从数据库获取\n  private int totalRecord;\n  //4. 总页数，计算得到\n  private int totalPage;\n  //5. 每页的显示数据，从数据库得到\n  List<T> list=new ArrayList<>();\n  ```\n  getter()和setter()方法\n}\n```\n\n\n\n#### SearchRequest类\n\n```java\npublic class SearchRequest {\n\n    private Integer From;\n    private Integer pageSize;\n    //.....其他查询条件\n    private String name;\n    private String age;\n\n    getter()和setter()方法\n}\n\n```\n\n\n\n#### Controller层\n\n```java\n@RequestMapping(value = \"/Page.action\")\npublic @ResponseBody PageBean<> SearchRecordPage(SearchRequest searchRequest, PageBean pagebean){\n  //\n  int totalRecord=service.getPageSize(searchRequest);\n  pageBean.setTotalRecord(totalRecord);pageBean.setTotalPage((int) Math.ceil((pageBean.getTotalRecord()*1.0)/pageBean.getCurrentCount()));\n//获取当前点击页面的数据（pageBean前台传错来一个页面显示多少条，和页码数）\nList<> list = service.getRecord(searchRequest,pageBean);\n//返回前台数据\n  pageBean.setList(list);\n  return pageBean;\n}\n```\n\n\n\nService的书写\n\nSearchRequest包含了From和pageSize\n\n```java\npublic List<T> getRecord(SearchRequest searchRequest, PageBean<ResultClassName> pageBean) {\n        //数据库进行分页的方法searchrequest加入from 和to\n        //当前页面\n        int currentPage=pageBean.getCurrentPage();  \n        //页面的显示个数\n        int currentCount=pageBean.getCurrentCount();\n        //根据页面算出数据库查询的起始位置\n        int from=currentCount*(currentPage-1);\n        //获取的数据个数\n        int pageSize=currentCount;\n        //将查询范围在查询条件里\n\t\t\t\tsearchRequest.setFrom(From);\n        searchRequest.setPageSize(pageSize);\n        //根据以上条件返回目的对象\n        pageBean.setList( Mapper.getRecord(searchRequest));\n        return pageBean; \n}\n```\n\nSQL的写法\n\n```sql\n<select id=\"getRepairRecord\" resultType=\"ResultClassName\"\n\t\tparameterType=\"SearchRequest\">\n\t\tSELECT *\n\t\tFROM 表名\n\t\t<where>\n\t\t\t\t<if test=\"name!=null and name!=''\">\n\t\t\t\t\t\tand name=#{name}</if>\n\t\t\t\t<if test=\"age!=null and age!=''\">\n\t\t\t\t\t\tand age=#{age}\n\t\t\t\t</if>\n\t\t\t</where>\n\t\t\t<if test=\"From!=null  and pageSize!=null\">\n            limit #{From},#{pageSize}\n         </if>\n         </select>\n\t\t\t\t\n```\n\n\n\n## java8的lambda表达式：\n\n前世-匿名类\n\n举一个匿名类的例子：\n\nComparator接口：\n\n```java\npublic interface Comparator<T> {\n  int compare(T o1, T o2);\n}\n```\n\n使用匿名类创建排序的比较方法：注意new Comparator\n\n```java\nCollections.sort(words, new Comparator<String>(){\n  public int compare(String s1, String s2){\n    return Integer.compare(s1.length(),s2.length())\n  }\n});\n```\n\n匿名类适用于需要函数对象的经典面向对象设计模式，特别是策略模式，上面的匿名类是排序字符串的具体策略。**然而，匿名类确实过于冗长。**\n\n起到的作用是，新new了一个接口，接口一个方法为compare，有两个参数s1，s2,\n\n\n\n##### 为什么sort里面要有一个Comparator接口，这么麻烦\n\nsort点进去有binarysort，不管Objcet实际是什么类型的，都可以使用接口中定义的方法。\n\n可能会有个疑问，为什么不在Object这个超类中定义这个方法然后子类重写，而是要用实现接口呢。这个嘛，是因为大部分用不着这个功能，写上去就会用浪费，我们就用接口来弥补，你要你就实现接口。\n\n### Lambda表达式的今生\n\n在 Java 8 中，语言形式化了这样的概念，即使用**单个抽象方法的接口是特别的**，应该得到特别的对待。即一个接口只有一个方法。\n\n这些接口现在称为**函数式接口**，并且该语言允许你**使用lambda 表达式或简称 lambda 来创建这些接口的实例。**\n\nLambdas 在功能上与匿名类相似，但更为简洁。下面的代码使用 lambdas 替换上面的匿名类。清晰明了\n\n```java\nCollections.sort(words,(s1,s2)->\n                Integer.compare(s1.length(),s2.length()))\n```\n\n\n\n```java\nnew Comparator<String>(){\n  public int compare(String s1, String s2){\n    return Integer.compare(s1.length(),s2.length())\n  }\n}\n```\n\n\n\n等价于\n\n```java\n(s1,s2)->Integer.compare(s1.length(),s2.length())\n```\n\n右边的东西形成了一个函数，这个函数需要两个参数，s1,s2.\n\n```java\ncustomSchemaRepository.findAll((root,criteriaQuery,criteriaBuilder) -> QueryHelp.getPredicate(root,criteria,criteriaBuilder))\n```\n\n\n\n### Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\n\n1. 使用Lambda表达式必须具有接口，且要求接口中有且仅有一个抽象方法。\n2. 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。\n\n### Lambda标准形式\n\n### (参数类型 参数名称) ‐> { 代码语句 }\n\n说明：\n\n1. 小括号内：没有参数就留空（），多个参数就用逗号分隔。\n2. -> 是新引入的语法格式，代表指向动作。\n3. 大括号内的语法与传统方法体要求基本一致。\n\n### Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\n\n在Lambda表达式标准形式的基础上：\n\n1. 小括号内参数的类型可以省略；\n2. 如果小括号内只有一个参数，则小括号可以省略；\n3. 如果大括号内只有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。\n\n综上所述，从 Java 8 开始，lambda 是迄今为止表示小函数对象的最佳方式。除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。\n\n备注：有且仅有一个抽象方法的接口，称为“函数式接口”。\n\n\n\n内连接（INNER JOIN）实例\n\n**LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。**\n\n```sql\nSELECT column_name(s) FROM table_name WHERE column_name LIKE pattern\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt4rqhbp72j31b20fcmyw.jpg)\n\n现在，我们希望从上面的 \"Persons\" 表中选取居住在以 \"N\" 开始的城市里的人：\n\n我们可以使用下面的 SELECT 语句：\n\n```sql\nSELECT * FROM Persons\nWHERE City LIKE 'N%'\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt4rr2kf49j31ak08q74y.jpg)\n\nTF-IDF（term frequency–inverse document frequency）\n\n是一种用于[信息检索](https://baike.baidu.com/item/信息检索/831904)与数据挖掘的常用加权技术。\n\nTF是词频(**Term** Frequency)，IDF是逆文本频率指数(Inverse Document Frequency)。\n\n\n\n# ES(elasticsearch)搜索引擎\n\n#### 什么是搜索?\n\n根据一个搜索词，检索出所有包含该词的数据\n例如：用户在搜索框输入一个词，客户端软件发送一个请求到后台，后台通过sql语句从数据库中找出相关条目(数据库会**一条一条的对比**)，这就是一个最简单搜索原型\n\n#### 普通搜索面临的问题\n\n1, 当数据量很大时，假如500G， 效率低。从用户角度，从点击搜索按钮到看到搜索结果可能要很长时间，1小时？2小时？用户疯掉\n\n2, 当数据量达到1T，一台电脑已经放不下了，这时候就需要多台，这就是分布式。这时候数据就在不同的服务器了，一个客户端不可能去请求每台机器，所以就需要一个管理员角色，负责把客户端请求分发到每台机器，同时汇总结果返回给客户端\n\n#### 普通搜索速度简单优化(倒排索引)\n\n数据库每个条目的名称进行分词，形成一个key为词，value为条目id的数据表。同时对用户输入的搜索词进行分词，检索出每个词在数据库中的id，求个交集，然后把这些id查不出返回就行了。\n\n输入 复仇者联盟， 经过分词后变成\n[复仇者，联盟]\n倒排索引表也已经建好了，可能长这样\n复仇者 4，5，6，11 数字为文档编号\n联盟 5，9，11\n\n#### 倒排索引\n\n需要根据属性的值来查找记录，这种**索引表中的每一项**都包括一个[属性值, 具有该属性值的各个记录的地址]。\n\n由于不是由记录来确定属性值，而是由**属性值来确定记录的位置**，因而称为倒排索引(inverted index)。\n\n带有倒排索引的文件我们称为倒排[索引文件](https://baike.baidu.com/item/索引文件)，简称[倒排文件](https://baike.baidu.com/item/倒排文件/4137688)(inverted file)。\n\n倒排列表用来记录有**哪些文档**包含了**某个单词**，一般在文档集合里会有很多文档 **包含**某个单词，每个文档会记录**文档编号（DocID)**,单词在这个文档中出现的**次数（TF）**及单词在文档中**哪些位置出现过等信息**.这样与一个文档相关的信息被称做倒排索引项（Posting）。并不存储倒排索引项中的实际文档编号，而是代之以文档编号差值（D-Gap），原始的 3个文档编号分别是187、196和199，通过编号差值计算，在实际存储的时候就转化成了：187、9、3。\n\n之所以要对文档编号进行差值计算，主要原因是为了更好地对数据进行压缩，原始文档编号一般都是大数值，通过差值计算，就有效地将大数值转换为了小数值，而这有助于增加数据的压缩率。\n\n##### 索引构建方法\n\n###### 简单法\n\n索引的构建相当于从正排表到倒排表的建立过程。当我们分析完网页时 ,得到的是以网页为主码的索引表。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt4zlokt0sj30j205pgly.jpg)\n\n流程描述如下：\n\n1）将文档分析成单词term标记，\n\n2）使用hash去重单词term\n\n3）对单词生成倒排列表\n\n倒排列表就是文档编号DocID，没有包含其他的信息（如词频，单词位置等），这就是简单的索引。\n\n这个简单索引功能可以用于小数据，例如索引几千个文档。然而它有两点限制：\n\n1）需要有足够的内存来存储倒排表，对于搜索引擎来说， 都是G级别数据，特别是当规模不断扩大时 ,我们根本不可能提供这么多的内存。\n\n2）算法是顺序执行，不便于并行处理。\n\n###### 合并法\n\n归并法,即每次将内存中数据写入磁盘时，包括词典在内的所有中间结果信息都被写入磁盘，这样内存所有内容都可以被清空，后续建立索引可以使用全部的定额内存。\n\n[![图4归并索引](https://bkimg.cdn.bcebos.com/pic/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/倒排索引/11001569/0/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?fr=lemma&ct=single)图4归并索引\n\n如图4归并示意图：\n\n**合并流程：**\n\n1）页面分析，生成临时倒排数据索引A，B，当临时倒排数据索引A，B占满内存后，将内存索引A，B写入临时文件生成临时倒排文件，\n\n\\2) 对生成的多个临时倒排文件 ,执行多路归并 ,输出得到最终的倒排文件 ( inverted file)。\n\n[![合并流程](https://bkimg.cdn.bcebos.com/pic/91529822720e0cf3226631b10b46f21fbf09aae3?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/倒排索引/11001569/0/91529822720e0cf3226631b10b46f21fbf09aae3?fr=lemma&ct=single)合并流程\n\n索引创建过程中的页面分析 ,特别是中文分词为主要时间开销。算法的第二步相对很快。这样创建算法的优化集中在中文分词效率上。\n\n假设只存在正向索引（forward index），那么就需要扫描索引库中的所有文档，找出所有包含关键词“华为手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。\n\n\n\n得到**正向索引**的结构如下：\n\n​    “文档1”的ID > 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。\n\n​    “文档2”的ID > 此文档出现的关键词列表。\n\n[文档ID,关键词]\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt507hvr8qj30kb092q3f.jpg)\n\n因为互联网上收录在搜索引擎中的文档的数目是个天文数字，**这样的索引结构根本无法满足实时返回排名结果的要求。**\n\n就是每个关键词都要去扫描库中的所有文档\n\n**所以，搜索引擎会将正向索引重新构建为倒排索引**，即把文件ID对应到关键词的映射转换为**关键词到文件ID的映射**\n\n[关键词,文件ID]\n\n![img](https://images2015.cnblogs.com/blog/855959/201707/855959-20170706154505378-610589524.png)\n\n　　从词的关键字，去找文档。\n\n###### 单词-文档矩阵\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt508mmtcdj30co076mxg.jpg)\n\n","slug":"8月4日","published":1,"updated":"2021-08-04T15:46:23.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8q000tc376ftsgffw0","content":"<p>page类，</p>\n<p>分页使用到的，分页无非就是使用到类 select * from table limit FROM,TO</p>\n<p>在数据库中做分页查询的时候，我们要想知道获取数据的起始位置和结束位置，就要知道每页显示的数据个数，</p>\n<p>我们可以根据数据总个数和每页显示的数据个数算出来总页数。</p>\n<h4 id=\"page类\"><a href=\"#page类\" class=\"headerlink\" title=\"page类\"></a>page类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PageBean</span>&lt;<span class=\"title\">T</span>&gt;()</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//1. 当前页数 从页面获取</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentPage;</span><br><span class=\"line\">  <span class=\"comment\">//2. 每页显示数据个数，赋初值或者setter获取</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentCount;</span><br><span class=\"line\">  <span class=\"comment\">//3. 总条数，从数据库获取</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalRecord;</span><br><span class=\"line\">  <span class=\"comment\">//4. 总页数，计算得到</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalPage;</span><br><span class=\"line\">  <span class=\"comment\">//5. 每页的显示数据，从数据库得到</span></span><br><span class=\"line\">  List&lt;T&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>  getter()和setter()方法<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### SearchRequest类</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">public class SearchRequest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Integer From;</span><br><span class=\"line\">    private Integer pageSize;</span><br><span class=\"line\">    //.....其他查询条件</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String age;</span><br><span class=\"line\"></span><br><span class=\"line\">    getter()和setter()方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;/Page.action&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@ResponseBody</span> PageBean&lt;&gt; SearchRecordPage(SearchRequest searchRequest, PageBean pagebean)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> totalRecord=service.getPageSize(searchRequest);</span><br><span class=\"line\">  pageBean.setTotalRecord(totalRecord);pageBean.setTotalPage((<span class=\"keyword\">int</span>) Math.ceil((pageBean.getTotalRecord()*<span class=\"number\">1.0</span>)/pageBean.getCurrentCount()));</span><br><span class=\"line\"><span class=\"comment\">//获取当前点击页面的数据（pageBean前台传错来一个页面显示多少条，和页码数）</span></span><br><span class=\"line\">List&lt;&gt; list = service.getRecord(searchRequest,pageBean);</span><br><span class=\"line\"><span class=\"comment\">//返回前台数据</span></span><br><span class=\"line\">  pageBean.setList(list);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pageBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Service的书写</p>\n<p>SearchRequest包含了From和pageSize</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;T&gt; <span class=\"title\">getRecord</span><span class=\"params\">(SearchRequest searchRequest, PageBean&lt;ResultClassName&gt; pageBean)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//数据库进行分页的方法searchrequest加入from 和to</span></span><br><span class=\"line\">        <span class=\"comment\">//当前页面</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentPage=pageBean.getCurrentPage();  </span><br><span class=\"line\">        <span class=\"comment\">//页面的显示个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentCount=pageBean.getCurrentCount();</span><br><span class=\"line\">        <span class=\"comment\">//根据页面算出数据库查询的起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> from=currentCount*(currentPage-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//获取的数据个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pageSize=currentCount;</span><br><span class=\"line\">        <span class=\"comment\">//将查询范围在查询条件里</span></span><br><span class=\"line\">\t\t\t\tsearchRequest.setFrom(From);</span><br><span class=\"line\">        searchRequest.setPageSize(pageSize);</span><br><span class=\"line\">        <span class=\"comment\">//根据以上条件返回目的对象</span></span><br><span class=\"line\">        pageBean.setList( Mapper.getRecord(searchRequest));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pageBean; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SQL的写法</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">&lt;</span><span class=\"keyword\">select</span> id<span class=\"operator\">=</span>&quot;getRepairRecord&quot; resultType<span class=\"operator\">=</span>&quot;ResultClassName&quot;</span><br><span class=\"line\">\t\tparameterType<span class=\"operator\">=</span>&quot;SearchRequest&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">FROM</span> 表名</span><br><span class=\"line\">\t\t<span class=\"operator\">&lt;</span><span class=\"keyword\">where</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;name!=null and name!=&#x27;&#x27;&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">and</span> name<span class=\"operator\">=</span>#&#123;name&#125;<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;age!=null and age!=&#x27;&#x27;&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">and</span> age<span class=\"operator\">=</span>#&#123;age&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">where</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;From!=null  and pageSize!=null&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            limit #&#123;<span class=\"keyword\">From</span>&#125;,#&#123;pageSize&#125;</span><br><span class=\"line\">         <span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">         <span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">select</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"java8的lambda表达式：\"><a href=\"#java8的lambda表达式：\" class=\"headerlink\" title=\"java8的lambda表达式：\"></a>java8的lambda表达式：</h2><p>前世-匿名类</p>\n<p>举一个匿名类的例子：</p>\n<p>Comparator接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用匿名类创建排序的比较方法：注意new Comparator</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(),s2.length())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>匿名类适用于需要函数对象的经典面向对象设计模式，特别是策略模式，上面的匿名类是排序字符串的具体策略。<strong>然而，匿名类确实过于冗长。</strong></p>\n<p>起到的作用是，新new了一个接口，接口一个方法为compare，有两个参数s1，s2,</p>\n<h5 id=\"为什么sort里面要有一个Comparator接口，这么麻烦\"><a href=\"#为什么sort里面要有一个Comparator接口，这么麻烦\" class=\"headerlink\" title=\"为什么sort里面要有一个Comparator接口，这么麻烦\"></a>为什么sort里面要有一个Comparator接口，这么麻烦</h5><p>sort点进去有binarysort，不管Objcet实际是什么类型的，都可以使用接口中定义的方法。</p>\n<p>可能会有个疑问，为什么不在Object这个超类中定义这个方法然后子类重写，而是要用实现接口呢。这个嘛，是因为大部分用不着这个功能，写上去就会用浪费，我们就用接口来弥补，你要你就实现接口。</p>\n<h3 id=\"Lambda表达式的今生\"><a href=\"#Lambda表达式的今生\" class=\"headerlink\" title=\"Lambda表达式的今生\"></a>Lambda表达式的今生</h3><p>在 Java 8 中，语言形式化了这样的概念，即使用<strong>单个抽象方法的接口是特别的</strong>，应该得到特别的对待。即一个接口只有一个方法。</p>\n<p>这些接口现在称为<strong>函数式接口</strong>，并且该语言允许你<strong>使用lambda 表达式或简称 lambda 来创建这些接口的实例。</strong></p>\n<p>Lambdas 在功能上与匿名类相似，但更为简洁。下面的代码使用 lambdas 替换上面的匿名类。清晰明了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(words,(s1,s2)-&gt;</span><br><span class=\"line\">                Integer.compare(s1.length(),s2.length()))</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(),s2.length())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(s1,s2)-&gt;Integer.compare(s1.length(),s2.length())</span><br></pre></td></tr></table></figure>\n\n<p>右边的东西形成了一个函数，这个函数需要两个参数，s1,s2.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customSchemaRepository.findAll((root,criteriaQuery,criteriaBuilder) -&gt; QueryHelp.getPredicate(root,criteria,criteriaBuilder))</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\"><a href=\"#Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\" class=\"headerlink\" title=\"Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\"></a>Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：</h3><ol>\n<li>使用Lambda表达式必须具有接口，且要求接口中有且仅有一个抽象方法。</li>\n<li>使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>\n</ol>\n<h3 id=\"Lambda标准形式\"><a href=\"#Lambda标准形式\" class=\"headerlink\" title=\"Lambda标准形式\"></a>Lambda标准形式</h3><h3 id=\"参数类型-参数名称-‐-gt-代码语句\"><a href=\"#参数类型-参数名称-‐-gt-代码语句\" class=\"headerlink\" title=\"(参数类型 参数名称) ‐&gt; { 代码语句 }\"></a>(参数类型 参数名称) ‐&gt; { 代码语句 }</h3><p>说明：</p>\n<ol>\n<li>小括号内：没有参数就留空（），多个参数就用逗号分隔。</li>\n<li>-&gt; 是新引入的语法格式，代表指向动作。</li>\n<li>大括号内的语法与传统方法体要求基本一致。</li>\n</ol>\n<h3 id=\"Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\"><a href=\"#Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\" class=\"headerlink\" title=\"Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\"></a>Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略</h3><p>在Lambda表达式标准形式的基础上：</p>\n<ol>\n<li>小括号内参数的类型可以省略；</li>\n<li>如果小括号内只有一个参数，则小括号可以省略；</li>\n<li>如果大括号内只有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>\n</ol>\n<p>综上所述，从 Java 8 开始，lambda 是迄今为止表示小函数对象的最佳方式。除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。</p>\n<p>备注：有且仅有一个抽象方法的接口，称为“函数式接口”。</p>\n<p>内连接（INNER JOIN）实例</p>\n<p><strong>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s) <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">WHERE</span> column_name <span class=\"keyword\">LIKE</span> <span class=\"keyword\">pattern</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt4rqhbp72j31b20fcmyw.jpg\"></p>\n<p>现在，我们希望从上面的 “Persons” 表中选取居住在以 “N” 开始的城市里的人：</p>\n<p>我们可以使用下面的 SELECT 语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> City <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;N%&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt4rr2kf49j31ak08q74y.jpg\"></p>\n<p>TF-IDF（term frequency–inverse document frequency）</p>\n<p>是一种用于<a href=\"https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/831904\">信息检索</a>与数据挖掘的常用加权技术。</p>\n<p>TF是词频(<strong>Term</strong> Frequency)，IDF是逆文本频率指数(Inverse Document Frequency)。</p>\n<h1 id=\"ES-elasticsearch-搜索引擎\"><a href=\"#ES-elasticsearch-搜索引擎\" class=\"headerlink\" title=\"ES(elasticsearch)搜索引擎\"></a>ES(elasticsearch)搜索引擎</h1><h4 id=\"什么是搜索\"><a href=\"#什么是搜索\" class=\"headerlink\" title=\"什么是搜索?\"></a>什么是搜索?</h4><p>根据一个搜索词，检索出所有包含该词的数据<br>例如：用户在搜索框输入一个词，客户端软件发送一个请求到后台，后台通过sql语句从数据库中找出相关条目(数据库会<strong>一条一条的对比</strong>)，这就是一个最简单搜索原型</p>\n<h4 id=\"普通搜索面临的问题\"><a href=\"#普通搜索面临的问题\" class=\"headerlink\" title=\"普通搜索面临的问题\"></a>普通搜索面临的问题</h4><p>1, 当数据量很大时，假如500G， 效率低。从用户角度，从点击搜索按钮到看到搜索结果可能要很长时间，1小时？2小时？用户疯掉</p>\n<p>2, 当数据量达到1T，一台电脑已经放不下了，这时候就需要多台，这就是分布式。这时候数据就在不同的服务器了，一个客户端不可能去请求每台机器，所以就需要一个管理员角色，负责把客户端请求分发到每台机器，同时汇总结果返回给客户端</p>\n<h4 id=\"普通搜索速度简单优化-倒排索引\"><a href=\"#普通搜索速度简单优化-倒排索引\" class=\"headerlink\" title=\"普通搜索速度简单优化(倒排索引)\"></a>普通搜索速度简单优化(倒排索引)</h4><p>数据库每个条目的名称进行分词，形成一个key为词，value为条目id的数据表。同时对用户输入的搜索词进行分词，检索出每个词在数据库中的id，求个交集，然后把这些id查不出返回就行了。</p>\n<p>输入 复仇者联盟， 经过分词后变成<br>[复仇者，联盟]<br>倒排索引表也已经建好了，可能长这样<br>复仇者 4，5，6，11 数字为文档编号<br>联盟 5，9，11</p>\n<h4 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h4><p>需要根据属性的值来查找记录，这种<strong>索引表中的每一项</strong>都包括一个[属性值, 具有该属性值的各个记录的地址]。</p>\n<p>由于不是由记录来确定属性值，而是由<strong>属性值来确定记录的位置</strong>，因而称为倒排索引(inverted index)。</p>\n<p>带有倒排索引的文件我们称为倒排<a href=\"https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6\">索引文件</a>，简称<a href=\"https://baike.baidu.com/item/%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6/4137688\">倒排文件</a>(inverted file)。</p>\n<p>倒排列表用来记录有<strong>哪些文档</strong>包含了<strong>某个单词</strong>，一般在文档集合里会有很多文档 <strong>包含</strong>某个单词，每个文档会记录<strong>文档编号（DocID)</strong>,单词在这个文档中出现的<strong>次数（TF）</strong>及单词在文档中<strong>哪些位置出现过等信息</strong>.这样与一个文档相关的信息被称做倒排索引项（Posting）。并不存储倒排索引项中的实际文档编号，而是代之以文档编号差值（D-Gap），原始的 3个文档编号分别是187、196和199，通过编号差值计算，在实际存储的时候就转化成了：187、9、3。</p>\n<p>之所以要对文档编号进行差值计算，主要原因是为了更好地对数据进行压缩，原始文档编号一般都是大数值，通过差值计算，就有效地将大数值转换为了小数值，而这有助于增加数据的压缩率。</p>\n<h5 id=\"索引构建方法\"><a href=\"#索引构建方法\" class=\"headerlink\" title=\"索引构建方法\"></a>索引构建方法</h5><h6 id=\"简单法\"><a href=\"#简单法\" class=\"headerlink\" title=\"简单法\"></a>简单法</h6><p>索引的构建相当于从正排表到倒排表的建立过程。当我们分析完网页时 ,得到的是以网页为主码的索引表。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt4zlokt0sj30j205pgly.jpg\"></p>\n<p>流程描述如下：</p>\n<p>1）将文档分析成单词term标记，</p>\n<p>2）使用hash去重单词term</p>\n<p>3）对单词生成倒排列表</p>\n<p>倒排列表就是文档编号DocID，没有包含其他的信息（如词频，单词位置等），这就是简单的索引。</p>\n<p>这个简单索引功能可以用于小数据，例如索引几千个文档。然而它有两点限制：</p>\n<p>1）需要有足够的内存来存储倒排表，对于搜索引擎来说， 都是G级别数据，特别是当规模不断扩大时 ,我们根本不可能提供这么多的内存。</p>\n<p>2）算法是顺序执行，不便于并行处理。</p>\n<h6 id=\"合并法\"><a href=\"#合并法\" class=\"headerlink\" title=\"合并法\"></a>合并法</h6><p>归并法,即每次将内存中数据写入磁盘时，包括词典在内的所有中间结果信息都被写入磁盘，这样内存所有内容都可以被清空，后续建立索引可以使用全部的定额内存。</p>\n<p><a href=\"https://baike.baidu.com/pic/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/11001569/0/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?fr=lemma&ct=single\"><img src=\"https://bkimg.cdn.bcebos.com/pic/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto\" alt=\"图4归并索引\"></a>图4归并索引</p>\n<p>如图4归并示意图：</p>\n<p><strong>合并流程：</strong></p>\n<p>1）页面分析，生成临时倒排数据索引A，B，当临时倒排数据索引A，B占满内存后，将内存索引A，B写入临时文件生成临时倒排文件，</p>\n<p>\\2) 对生成的多个临时倒排文件 ,执行多路归并 ,输出得到最终的倒排文件 ( inverted file)。</p>\n<p><a href=\"https://baike.baidu.com/pic/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/11001569/0/91529822720e0cf3226631b10b46f21fbf09aae3?fr=lemma&ct=single\"><img src=\"https://bkimg.cdn.bcebos.com/pic/91529822720e0cf3226631b10b46f21fbf09aae3?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto\" alt=\"合并流程\"></a>合并流程</p>\n<p>索引创建过程中的页面分析 ,特别是中文分词为主要时间开销。算法的第二步相对很快。这样创建算法的优化集中在中文分词效率上。</p>\n<p>假设只存在正向索引（forward index），那么就需要扫描索引库中的所有文档，找出所有包含关键词“华为手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。</p>\n<p>得到<strong>正向索引</strong>的结构如下：</p>\n<p>​    “文档1”的ID &gt; 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。</p>\n<p>​    “文档2”的ID &gt; 此文档出现的关键词列表。</p>\n<p>[文档ID,关键词]</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt507hvr8qj30kb092q3f.jpg\"></p>\n<p>因为互联网上收录在搜索引擎中的文档的数目是个天文数字，<strong>这样的索引结构根本无法满足实时返回排名结果的要求。</strong></p>\n<p>就是每个关键词都要去扫描库中的所有文档</p>\n<p><strong>所以，搜索引擎会将正向索引重新构建为倒排索引</strong>，即把文件ID对应到关键词的映射转换为<strong>关键词到文件ID的映射</strong></p>\n<p>[关键词,文件ID]</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/855959/201707/855959-20170706154505378-610589524.png\" alt=\"img\"></p>\n<p>　　从词的关键字，去找文档。</p>\n<h6 id=\"单词-文档矩阵\"><a href=\"#单词-文档矩阵\" class=\"headerlink\" title=\"单词-文档矩阵\"></a>单词-文档矩阵</h6><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt508mmtcdj30co076mxg.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>page类，</p>\n<p>分页使用到的，分页无非就是使用到类 select * from table limit FROM,TO</p>\n<p>在数据库中做分页查询的时候，我们要想知道获取数据的起始位置和结束位置，就要知道每页显示的数据个数，</p>\n<p>我们可以根据数据总个数和每页显示的数据个数算出来总页数。</p>\n<h4 id=\"page类\"><a href=\"#page类\" class=\"headerlink\" title=\"page类\"></a>page类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PageBean</span>&lt;<span class=\"title\">T</span>&gt;()</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//1. 当前页数 从页面获取</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentPage;</span><br><span class=\"line\">  <span class=\"comment\">//2. 每页显示数据个数，赋初值或者setter获取</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentCount;</span><br><span class=\"line\">  <span class=\"comment\">//3. 总条数，从数据库获取</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalRecord;</span><br><span class=\"line\">  <span class=\"comment\">//4. 总页数，计算得到</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> totalPage;</span><br><span class=\"line\">  <span class=\"comment\">//5. 每页的显示数据，从数据库得到</span></span><br><span class=\"line\">  List&lt;T&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>  getter()和setter()方法<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#### SearchRequest类</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">public class SearchRequest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Integer From;</span><br><span class=\"line\">    private Integer pageSize;</span><br><span class=\"line\">    //.....其他查询条件</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private String age;</span><br><span class=\"line\"></span><br><span class=\"line\">    getter()和setter()方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;/Page.action&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@ResponseBody</span> PageBean&lt;&gt; SearchRecordPage(SearchRequest searchRequest, PageBean pagebean)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> totalRecord=service.getPageSize(searchRequest);</span><br><span class=\"line\">  pageBean.setTotalRecord(totalRecord);pageBean.setTotalPage((<span class=\"keyword\">int</span>) Math.ceil((pageBean.getTotalRecord()*<span class=\"number\">1.0</span>)/pageBean.getCurrentCount()));</span><br><span class=\"line\"><span class=\"comment\">//获取当前点击页面的数据（pageBean前台传错来一个页面显示多少条，和页码数）</span></span><br><span class=\"line\">List&lt;&gt; list = service.getRecord(searchRequest,pageBean);</span><br><span class=\"line\"><span class=\"comment\">//返回前台数据</span></span><br><span class=\"line\">  pageBean.setList(list);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pageBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Service的书写</p>\n<p>SearchRequest包含了From和pageSize</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;T&gt; <span class=\"title\">getRecord</span><span class=\"params\">(SearchRequest searchRequest, PageBean&lt;ResultClassName&gt; pageBean)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//数据库进行分页的方法searchrequest加入from 和to</span></span><br><span class=\"line\">        <span class=\"comment\">//当前页面</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentPage=pageBean.getCurrentPage();  </span><br><span class=\"line\">        <span class=\"comment\">//页面的显示个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentCount=pageBean.getCurrentCount();</span><br><span class=\"line\">        <span class=\"comment\">//根据页面算出数据库查询的起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> from=currentCount*(currentPage-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//获取的数据个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pageSize=currentCount;</span><br><span class=\"line\">        <span class=\"comment\">//将查询范围在查询条件里</span></span><br><span class=\"line\">\t\t\t\tsearchRequest.setFrom(From);</span><br><span class=\"line\">        searchRequest.setPageSize(pageSize);</span><br><span class=\"line\">        <span class=\"comment\">//根据以上条件返回目的对象</span></span><br><span class=\"line\">        pageBean.setList( Mapper.getRecord(searchRequest));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pageBean; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SQL的写法</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">&lt;</span><span class=\"keyword\">select</span> id<span class=\"operator\">=</span>&quot;getRepairRecord&quot; resultType<span class=\"operator\">=</span>&quot;ResultClassName&quot;</span><br><span class=\"line\">\t\tparameterType<span class=\"operator\">=</span>&quot;SearchRequest&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">FROM</span> 表名</span><br><span class=\"line\">\t\t<span class=\"operator\">&lt;</span><span class=\"keyword\">where</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;name!=null and name!=&#x27;&#x27;&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">and</span> name<span class=\"operator\">=</span>#&#123;name&#125;<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;age!=null and age!=&#x27;&#x27;&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">and</span> age<span class=\"operator\">=</span>#&#123;age&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">where</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"operator\">&lt;</span>if test<span class=\"operator\">=</span>&quot;From!=null  and pageSize!=null&quot;<span class=\"operator\">&gt;</span></span><br><span class=\"line\">            limit #&#123;<span class=\"keyword\">From</span>&#125;,#&#123;pageSize&#125;</span><br><span class=\"line\">         <span class=\"operator\">&lt;</span><span class=\"operator\">/</span>if<span class=\"operator\">&gt;</span></span><br><span class=\"line\">         <span class=\"operator\">&lt;</span><span class=\"operator\">/</span><span class=\"keyword\">select</span><span class=\"operator\">&gt;</span></span><br><span class=\"line\">\t\t\t\t</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"java8的lambda表达式：\"><a href=\"#java8的lambda表达式：\" class=\"headerlink\" title=\"java8的lambda表达式：\"></a>java8的lambda表达式：</h2><p>前世-匿名类</p>\n<p>举一个匿名类的例子：</p>\n<p>Comparator接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用匿名类创建排序的比较方法：注意new Comparator</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(words, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(),s2.length())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>匿名类适用于需要函数对象的经典面向对象设计模式，特别是策略模式，上面的匿名类是排序字符串的具体策略。<strong>然而，匿名类确实过于冗长。</strong></p>\n<p>起到的作用是，新new了一个接口，接口一个方法为compare，有两个参数s1，s2,</p>\n<h5 id=\"为什么sort里面要有一个Comparator接口，这么麻烦\"><a href=\"#为什么sort里面要有一个Comparator接口，这么麻烦\" class=\"headerlink\" title=\"为什么sort里面要有一个Comparator接口，这么麻烦\"></a>为什么sort里面要有一个Comparator接口，这么麻烦</h5><p>sort点进去有binarysort，不管Objcet实际是什么类型的，都可以使用接口中定义的方法。</p>\n<p>可能会有个疑问，为什么不在Object这个超类中定义这个方法然后子类重写，而是要用实现接口呢。这个嘛，是因为大部分用不着这个功能，写上去就会用浪费，我们就用接口来弥补，你要你就实现接口。</p>\n<h3 id=\"Lambda表达式的今生\"><a href=\"#Lambda表达式的今生\" class=\"headerlink\" title=\"Lambda表达式的今生\"></a>Lambda表达式的今生</h3><p>在 Java 8 中，语言形式化了这样的概念，即使用<strong>单个抽象方法的接口是特别的</strong>，应该得到特别的对待。即一个接口只有一个方法。</p>\n<p>这些接口现在称为<strong>函数式接口</strong>，并且该语言允许你<strong>使用lambda 表达式或简称 lambda 来创建这些接口的实例。</strong></p>\n<p>Lambdas 在功能上与匿名类相似，但更为简洁。下面的代码使用 lambdas 替换上面的匿名类。清晰明了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(words,(s1,s2)-&gt;</span><br><span class=\"line\">                Integer.compare(s1.length(),s2.length()))</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(s1.length(),s2.length())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(s1,s2)-&gt;Integer.compare(s1.length(),s2.length())</span><br></pre></td></tr></table></figure>\n\n<p>右边的东西形成了一个函数，这个函数需要两个参数，s1,s2.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">customSchemaRepository.findAll((root,criteriaQuery,criteriaBuilder) -&gt; QueryHelp.getPredicate(root,criteria,criteriaBuilder))</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\"><a href=\"#Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\" class=\"headerlink\" title=\"Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：\"></a>Lambda表达式的语法非常简洁，但是使用时有几个问题需要特别注意：</h3><ol>\n<li>使用Lambda表达式必须具有接口，且要求接口中有且仅有一个抽象方法。</li>\n<li>使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>\n</ol>\n<h3 id=\"Lambda标准形式\"><a href=\"#Lambda标准形式\" class=\"headerlink\" title=\"Lambda标准形式\"></a>Lambda标准形式</h3><h3 id=\"参数类型-参数名称-‐-gt-代码语句\"><a href=\"#参数类型-参数名称-‐-gt-代码语句\" class=\"headerlink\" title=\"(参数类型 参数名称) ‐&gt; { 代码语句 }\"></a>(参数类型 参数名称) ‐&gt; { 代码语句 }</h3><p>说明：</p>\n<ol>\n<li>小括号内：没有参数就留空（），多个参数就用逗号分隔。</li>\n<li>-&gt; 是新引入的语法格式，代表指向动作。</li>\n<li>大括号内的语法与传统方法体要求基本一致。</li>\n</ol>\n<h3 id=\"Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\"><a href=\"#Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\" class=\"headerlink\" title=\"Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略\"></a>Lambda的省略：凡是可以根据上下文推导得知的信息，都可以省略</h3><p>在Lambda表达式标准形式的基础上：</p>\n<ol>\n<li>小括号内参数的类型可以省略；</li>\n<li>如果小括号内只有一个参数，则小括号可以省略；</li>\n<li>如果大括号内只有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>\n</ol>\n<p>综上所述，从 Java 8 开始，lambda 是迄今为止表示小函数对象的最佳方式。除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象。</p>\n<p>备注：有且仅有一个抽象方法的接口，称为“函数式接口”。</p>\n<p>内连接（INNER JOIN）实例</p>\n<p><strong>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s) <span class=\"keyword\">FROM</span> table_name <span class=\"keyword\">WHERE</span> column_name <span class=\"keyword\">LIKE</span> <span class=\"keyword\">pattern</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt4rqhbp72j31b20fcmyw.jpg\"></p>\n<p>现在，我们希望从上面的 “Persons” 表中选取居住在以 “N” 开始的城市里的人：</p>\n<p>我们可以使用下面的 SELECT 语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> City <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;N%&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt4rr2kf49j31ak08q74y.jpg\"></p>\n<p>TF-IDF（term frequency–inverse document frequency）</p>\n<p>是一种用于<a href=\"https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/831904\">信息检索</a>与数据挖掘的常用加权技术。</p>\n<p>TF是词频(<strong>Term</strong> Frequency)，IDF是逆文本频率指数(Inverse Document Frequency)。</p>\n<h1 id=\"ES-elasticsearch-搜索引擎\"><a href=\"#ES-elasticsearch-搜索引擎\" class=\"headerlink\" title=\"ES(elasticsearch)搜索引擎\"></a>ES(elasticsearch)搜索引擎</h1><h4 id=\"什么是搜索\"><a href=\"#什么是搜索\" class=\"headerlink\" title=\"什么是搜索?\"></a>什么是搜索?</h4><p>根据一个搜索词，检索出所有包含该词的数据<br>例如：用户在搜索框输入一个词，客户端软件发送一个请求到后台，后台通过sql语句从数据库中找出相关条目(数据库会<strong>一条一条的对比</strong>)，这就是一个最简单搜索原型</p>\n<h4 id=\"普通搜索面临的问题\"><a href=\"#普通搜索面临的问题\" class=\"headerlink\" title=\"普通搜索面临的问题\"></a>普通搜索面临的问题</h4><p>1, 当数据量很大时，假如500G， 效率低。从用户角度，从点击搜索按钮到看到搜索结果可能要很长时间，1小时？2小时？用户疯掉</p>\n<p>2, 当数据量达到1T，一台电脑已经放不下了，这时候就需要多台，这就是分布式。这时候数据就在不同的服务器了，一个客户端不可能去请求每台机器，所以就需要一个管理员角色，负责把客户端请求分发到每台机器，同时汇总结果返回给客户端</p>\n<h4 id=\"普通搜索速度简单优化-倒排索引\"><a href=\"#普通搜索速度简单优化-倒排索引\" class=\"headerlink\" title=\"普通搜索速度简单优化(倒排索引)\"></a>普通搜索速度简单优化(倒排索引)</h4><p>数据库每个条目的名称进行分词，形成一个key为词，value为条目id的数据表。同时对用户输入的搜索词进行分词，检索出每个词在数据库中的id，求个交集，然后把这些id查不出返回就行了。</p>\n<p>输入 复仇者联盟， 经过分词后变成<br>[复仇者，联盟]<br>倒排索引表也已经建好了，可能长这样<br>复仇者 4，5，6，11 数字为文档编号<br>联盟 5，9，11</p>\n<h4 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h4><p>需要根据属性的值来查找记录，这种<strong>索引表中的每一项</strong>都包括一个[属性值, 具有该属性值的各个记录的地址]。</p>\n<p>由于不是由记录来确定属性值，而是由<strong>属性值来确定记录的位置</strong>，因而称为倒排索引(inverted index)。</p>\n<p>带有倒排索引的文件我们称为倒排<a href=\"https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6\">索引文件</a>，简称<a href=\"https://baike.baidu.com/item/%E5%80%92%E6%8E%92%E6%96%87%E4%BB%B6/4137688\">倒排文件</a>(inverted file)。</p>\n<p>倒排列表用来记录有<strong>哪些文档</strong>包含了<strong>某个单词</strong>，一般在文档集合里会有很多文档 <strong>包含</strong>某个单词，每个文档会记录<strong>文档编号（DocID)</strong>,单词在这个文档中出现的<strong>次数（TF）</strong>及单词在文档中<strong>哪些位置出现过等信息</strong>.这样与一个文档相关的信息被称做倒排索引项（Posting）。并不存储倒排索引项中的实际文档编号，而是代之以文档编号差值（D-Gap），原始的 3个文档编号分别是187、196和199，通过编号差值计算，在实际存储的时候就转化成了：187、9、3。</p>\n<p>之所以要对文档编号进行差值计算，主要原因是为了更好地对数据进行压缩，原始文档编号一般都是大数值，通过差值计算，就有效地将大数值转换为了小数值，而这有助于增加数据的压缩率。</p>\n<h5 id=\"索引构建方法\"><a href=\"#索引构建方法\" class=\"headerlink\" title=\"索引构建方法\"></a>索引构建方法</h5><h6 id=\"简单法\"><a href=\"#简单法\" class=\"headerlink\" title=\"简单法\"></a>简单法</h6><p>索引的构建相当于从正排表到倒排表的建立过程。当我们分析完网页时 ,得到的是以网页为主码的索引表。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt4zlokt0sj30j205pgly.jpg\"></p>\n<p>流程描述如下：</p>\n<p>1）将文档分析成单词term标记，</p>\n<p>2）使用hash去重单词term</p>\n<p>3）对单词生成倒排列表</p>\n<p>倒排列表就是文档编号DocID，没有包含其他的信息（如词频，单词位置等），这就是简单的索引。</p>\n<p>这个简单索引功能可以用于小数据，例如索引几千个文档。然而它有两点限制：</p>\n<p>1）需要有足够的内存来存储倒排表，对于搜索引擎来说， 都是G级别数据，特别是当规模不断扩大时 ,我们根本不可能提供这么多的内存。</p>\n<p>2）算法是顺序执行，不便于并行处理。</p>\n<h6 id=\"合并法\"><a href=\"#合并法\" class=\"headerlink\" title=\"合并法\"></a>合并法</h6><p>归并法,即每次将内存中数据写入磁盘时，包括词典在内的所有中间结果信息都被写入磁盘，这样内存所有内容都可以被清空，后续建立索引可以使用全部的定额内存。</p>\n<p><a href=\"https://baike.baidu.com/pic/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/11001569/0/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?fr=lemma&ct=single\"><img src=\"https://bkimg.cdn.bcebos.com/pic/7e3e6709c93d70cf4f56d547f9dcd100bba12bcf?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto\" alt=\"图4归并索引\"></a>图4归并索引</p>\n<p>如图4归并示意图：</p>\n<p><strong>合并流程：</strong></p>\n<p>1）页面分析，生成临时倒排数据索引A，B，当临时倒排数据索引A，B占满内存后，将内存索引A，B写入临时文件生成临时倒排文件，</p>\n<p>\\2) 对生成的多个临时倒排文件 ,执行多路归并 ,输出得到最终的倒排文件 ( inverted file)。</p>\n<p><a href=\"https://baike.baidu.com/pic/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/11001569/0/91529822720e0cf3226631b10b46f21fbf09aae3?fr=lemma&ct=single\"><img src=\"https://bkimg.cdn.bcebos.com/pic/91529822720e0cf3226631b10b46f21fbf09aae3?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto\" alt=\"合并流程\"></a>合并流程</p>\n<p>索引创建过程中的页面分析 ,特别是中文分词为主要时间开销。算法的第二步相对很快。这样创建算法的优化集中在中文分词效率上。</p>\n<p>假设只存在正向索引（forward index），那么就需要扫描索引库中的所有文档，找出所有包含关键词“华为手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。</p>\n<p>得到<strong>正向索引</strong>的结构如下：</p>\n<p>​    “文档1”的ID &gt; 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。</p>\n<p>​    “文档2”的ID &gt; 此文档出现的关键词列表。</p>\n<p>[文档ID,关键词]</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt507hvr8qj30kb092q3f.jpg\"></p>\n<p>因为互联网上收录在搜索引擎中的文档的数目是个天文数字，<strong>这样的索引结构根本无法满足实时返回排名结果的要求。</strong></p>\n<p>就是每个关键词都要去扫描库中的所有文档</p>\n<p><strong>所以，搜索引擎会将正向索引重新构建为倒排索引</strong>，即把文件ID对应到关键词的映射转换为<strong>关键词到文件ID的映射</strong></p>\n<p>[关键词,文件ID]</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/855959/201707/855959-20170706154505378-610589524.png\" alt=\"img\"></p>\n<p>　　从词的关键字，去找文档。</p>\n<h6 id=\"单词-文档矩阵\"><a href=\"#单词-文档矩阵\" class=\"headerlink\" title=\"单词-文档矩阵\"></a>单词-文档矩阵</h6><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt508mmtcdj30co076mxg.jpg\"></p>\n"},{"title":"8月5日","date":"2021-08-05T01:32:58.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt5pw80z48j31900u0wuz.jpg","_content":"\n凌晨导师给我安排的任务，\n\n热搜统计-服务端\n\n热搜配置-服务端\n\n搜索框管理-服务端\n\n屏蔽词管理-服务端\n\n关键词管理-服务端\n\n理财搜索API\n\n股票搜索API\n\n\n\n\n\n请求头，\n\n\n\n### ResponseEntity概念\n\n**简单粗暴理解**：\nResponseEntity继承了HttpEntity，是HttpEntity的子类且可以添加HttpStatus状态码（推测HttpEntity不能添加HttpStatus状态码）。被用于RestTemplate和Controller层方法\n\nResponseEntity.ok API\n\n在ResponseEntity中有两个ok方法；一个无参，一个有参\n\n**直译**：\n创建一个设置了OK状态的builder\n**简单粗暴理解**：\n这个方法若被调用的话，返回OK状态\n\\* public static ResponseEntity ok(T body)\n\n通过源码，我们不难发现\n\\* 与API中的描述一致，**无参ok方法**返回OK状态，**有参ok方法**返回**body内容**和**OK状态**\n\\* body类型 是 泛型T，也就是我们不确定body是什么类型，可以向ok方法传递任意类型的值\n\\* **有参ok方法**其实有调用**无参ok方法**\n\n\n\n\n\n**@Qualifier的参数名称为我们之前定义@Service注解的名称之一。**\n\n@Qualifier注解的用处：当一个接口有多个实现的时候，为了指名具体调用哪个类的实现。\n\n@Resource 可以通过 **byName** 和 **byType**的方式注入， 默认先按 **byName**的方式进行匹配，\n\n如果匹配不到，再按 byType的方式进行匹配。可以为 @Service和@Resource 添加 name 这个属性来区分不同的实现\n\n一个接口有多个实现类，@Qualifier指明@Autowired具体注入哪个实现类\n\n","source":"_posts/8月5日.md","raw":"---\ntitle: 8月5日\ndate: 2021-08-05 09:32:58\ncategories:\n- 工作日志\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt5pw80z48j31900u0wuz.jpg\n---\n\n凌晨导师给我安排的任务，\n\n热搜统计-服务端\n\n热搜配置-服务端\n\n搜索框管理-服务端\n\n屏蔽词管理-服务端\n\n关键词管理-服务端\n\n理财搜索API\n\n股票搜索API\n\n\n\n\n\n请求头，\n\n\n\n### ResponseEntity概念\n\n**简单粗暴理解**：\nResponseEntity继承了HttpEntity，是HttpEntity的子类且可以添加HttpStatus状态码（推测HttpEntity不能添加HttpStatus状态码）。被用于RestTemplate和Controller层方法\n\nResponseEntity.ok API\n\n在ResponseEntity中有两个ok方法；一个无参，一个有参\n\n**直译**：\n创建一个设置了OK状态的builder\n**简单粗暴理解**：\n这个方法若被调用的话，返回OK状态\n\\* public static ResponseEntity ok(T body)\n\n通过源码，我们不难发现\n\\* 与API中的描述一致，**无参ok方法**返回OK状态，**有参ok方法**返回**body内容**和**OK状态**\n\\* body类型 是 泛型T，也就是我们不确定body是什么类型，可以向ok方法传递任意类型的值\n\\* **有参ok方法**其实有调用**无参ok方法**\n\n\n\n\n\n**@Qualifier的参数名称为我们之前定义@Service注解的名称之一。**\n\n@Qualifier注解的用处：当一个接口有多个实现的时候，为了指名具体调用哪个类的实现。\n\n@Resource 可以通过 **byName** 和 **byType**的方式注入， 默认先按 **byName**的方式进行匹配，\n\n如果匹配不到，再按 byType的方式进行匹配。可以为 @Service和@Resource 添加 name 这个属性来区分不同的实现\n\n一个接口有多个实现类，@Qualifier指明@Autowired具体注入哪个实现类\n\n","slug":"8月5日","published":1,"updated":"2021-08-05T11:48:56.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8r000xc37660bn7w9h","content":"<p>凌晨导师给我安排的任务，</p>\n<p>热搜统计-服务端</p>\n<p>热搜配置-服务端</p>\n<p>搜索框管理-服务端</p>\n<p>屏蔽词管理-服务端</p>\n<p>关键词管理-服务端</p>\n<p>理财搜索API</p>\n<p>股票搜索API</p>\n<p>请求头，</p>\n<h3 id=\"ResponseEntity概念\"><a href=\"#ResponseEntity概念\" class=\"headerlink\" title=\"ResponseEntity概念\"></a>ResponseEntity概念</h3><p><strong>简单粗暴理解</strong>：<br>ResponseEntity继承了HttpEntity，是HttpEntity的子类且可以添加HttpStatus状态码（推测HttpEntity不能添加HttpStatus状态码）。被用于RestTemplate和Controller层方法</p>\n<p>ResponseEntity.ok API</p>\n<p>在ResponseEntity中有两个ok方法；一个无参，一个有参</p>\n<p><strong>直译</strong>：<br>创建一个设置了OK状态的builder<br><strong>简单粗暴理解</strong>：<br>这个方法若被调用的话，返回OK状态<br>* public static ResponseEntity ok(T body)</p>\n<p>通过源码，我们不难发现<br>* 与API中的描述一致，<strong>无参ok方法</strong>返回OK状态，<strong>有参ok方法</strong>返回<strong>body内容</strong>和<strong>OK状态</strong><br>* body类型 是 泛型T，也就是我们不确定body是什么类型，可以向ok方法传递任意类型的值<br>* <strong>有参ok方法</strong>其实有调用<strong>无参ok方法</strong></p>\n<p><strong>@Qualifier的参数名称为我们之前定义@Service注解的名称之一。</strong></p>\n<p>@Qualifier注解的用处：当一个接口有多个实现的时候，为了指名具体调用哪个类的实现。</p>\n<p>@Resource 可以通过 <strong>byName</strong> 和 <strong>byType</strong>的方式注入， 默认先按 <strong>byName</strong>的方式进行匹配，</p>\n<p>如果匹配不到，再按 byType的方式进行匹配。可以为 @Service和@Resource 添加 name 这个属性来区分不同的实现</p>\n<p>一个接口有多个实现类，@Qualifier指明@Autowired具体注入哪个实现类</p>\n","site":{"data":{}},"excerpt":"","more":"<p>凌晨导师给我安排的任务，</p>\n<p>热搜统计-服务端</p>\n<p>热搜配置-服务端</p>\n<p>搜索框管理-服务端</p>\n<p>屏蔽词管理-服务端</p>\n<p>关键词管理-服务端</p>\n<p>理财搜索API</p>\n<p>股票搜索API</p>\n<p>请求头，</p>\n<h3 id=\"ResponseEntity概念\"><a href=\"#ResponseEntity概念\" class=\"headerlink\" title=\"ResponseEntity概念\"></a>ResponseEntity概念</h3><p><strong>简单粗暴理解</strong>：<br>ResponseEntity继承了HttpEntity，是HttpEntity的子类且可以添加HttpStatus状态码（推测HttpEntity不能添加HttpStatus状态码）。被用于RestTemplate和Controller层方法</p>\n<p>ResponseEntity.ok API</p>\n<p>在ResponseEntity中有两个ok方法；一个无参，一个有参</p>\n<p><strong>直译</strong>：<br>创建一个设置了OK状态的builder<br><strong>简单粗暴理解</strong>：<br>这个方法若被调用的话，返回OK状态<br>* public static ResponseEntity ok(T body)</p>\n<p>通过源码，我们不难发现<br>* 与API中的描述一致，<strong>无参ok方法</strong>返回OK状态，<strong>有参ok方法</strong>返回<strong>body内容</strong>和<strong>OK状态</strong><br>* body类型 是 泛型T，也就是我们不确定body是什么类型，可以向ok方法传递任意类型的值<br>* <strong>有参ok方法</strong>其实有调用<strong>无参ok方法</strong></p>\n<p><strong>@Qualifier的参数名称为我们之前定义@Service注解的名称之一。</strong></p>\n<p>@Qualifier注解的用处：当一个接口有多个实现的时候，为了指名具体调用哪个类的实现。</p>\n<p>@Resource 可以通过 <strong>byName</strong> 和 <strong>byType</strong>的方式注入， 默认先按 <strong>byName</strong>的方式进行匹配，</p>\n<p>如果匹配不到，再按 byType的方式进行匹配。可以为 @Service和@Resource 添加 name 这个属性来区分不同的实现</p>\n<p>一个接口有多个实现类，@Qualifier指明@Autowired具体注入哪个实现类</p>\n"},{"title":"8月6日","date":"2021-08-06T02:25:36.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt9ji9umigj30ci09ut94.jpg","_content":"\n前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。\n\n\n\n为什么要使用s l f4j\n\n我们自己的系统中使用了logback这个日志系统\n我们的系统使用了A.jar，A.jar中使用的日志系统为log4j\n我们的系统又使用了B.jar，B.jar中使用的日志系统为slf4j-simple\n\n这样，我们的系统就不得不同时支持并维护logback、log4j、slf4j-simple三种日志框架，非常不便。\n\n解决这个问题的方式就是引入一个适配层，由适配层决定使用哪一种日志系统，而调用端只需要做的事情就是打印日志而不需要关心如何打印日志，slf4j或者commons-logging就是这种适配层，slf4j是本文研究的对象。\n\n从上面的描述，我们必须清楚地知道一点：**slf4j只是一个日志标准，并不是日志系统的具体实现**。理解这句话非常重要，slf4j只做两件事情：\n\n- 提供日志接口\n- 提供获取具体日志对象的方法\n\n```kotlin\n#下面是配置将日志信息插入数据库，\n#配置输出目标为数据库（假如要将日志在控制台输出，配置为log4j.appender. stdout =org.apache.log4j.ConsoleAppender；将日志写入文件，配置为log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppender\n#这样的配置在许多地方都要有，需要可查有关资料）,当然你也可以自己扩展org.apache.log4j.jdbc.JDBCAppender这个类，只需要在这里配置就可以了例如我们配置我自己扩展的MyJDBCAppender，配置为#log4j.appender.db=com.neam.commons.MyJDBCAppender\nlog4j.appender.datasource=org.apache.log4j.jdbc.JDBCAppender\nlog4j.appender.datasource.layout=org.apache.log4j.PatternLayout\nlog4j.appender.datasource.driver=com.mysql.jdbc.Driver\n#定义什么级别的错误将写入到数据库中\nlog4j.appender.datasource.BufferSize=1\n#设置缓存大小，就是当有1条日志信息是才忘数据库插一次，我设置的数据库名和表名均为user\nlog4j.appender.datasource.URL=jdbc\\:mysql\\://localhost\\:3306/user?characterEncoding\\=UTF8&zeroDateTimeBehavior\\=convertToNull\nlog4j.appender.datasource.user=root\nlog4j.appender.datasource.password=root\nlog4j.appender.datasource.sql=insert into user (class,method,create_time,log_level,log_line,msg) values ('%C','%M','%d{yyyy-MM-dd HH:mm:ss}','%p','%l','%m')\n```\n\n\n\n```\n同义词在去重校验逻辑中的业务编码为2\n```\n\n@Query注解：\n 这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。\n\n如果是 @Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %\n\n还可以使用@Query来指定**本地查询**，只要设置**nativeQuery为true**，\n\n\n\n简明扼要的介绍一下@Data注解的**功能与使用方法**\n   **注解功能**\n    1、@Data可以为类提供读写功能，从而不用写get、set方法。\n    2、@Data提供 equals()、hashCode()、toString() 方法。\n\n\n\nLombok项目是一种自动接通你的编辑器和构建工具的一个Java库。不用再一次写额外的getter或者equals方法。由此可以看出，lombok会帮我们自动生成getter和euqals方法,但是更有意思的是,当我们的变量发生改变时,我们不再需要修改对的getter、setter方法,lombok帮我们在运行的过程中自动生成上述方法,编码更灵活.\n\n所以,使用lombok的优点: 1、简化long冗余的javabean代码;\n\n​                                    2、提高执行效率\n\n### lombok中的常用注解\n\n- @Setter ：在JavaBean或类JavaBean中使用，使用此注解会生成对应的setter方法；\n- @Getter：在JavaBean或类JavaBean中使用，使用此注解会生成对应的getter方法；\n- @ToString：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法；\n- @NoArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的无参构造方法；\n- @HashCode：\n- @Equals：\n- @CanEqual：\n- @Data：在JavaBean或类JavaBean中使用，这个注解包含范围最广，它包含上述注解，即当使用当前注解时，会自动生成包含的所有方法；\n- @AllArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的有参构造方法；\n- @Log(这是一个泛型注解，具体有很多种形式)\n- @EqualsAndHashCode：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的equals方法和hashCode方法；\n\n1. 此注解会生成`equals(Object other)` 和 `hashCode()`方法。\n2. 它默认使用非静态，非瞬态的属性\n3. 可通过参数`exclude`排除一些属性\n4. 可通过参数`of`指定仅使用哪些属性\n5. 它默认仅使用该类中定义的属性且不调用父类的方法\n6. 可通过`callSuper=true`解决上一点问题。让其生成的方法中调用父类的方法。\n7. @Slf4j：在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可；\n\n@ToString(exclude=\"column\")\n\n意义：排除column列所对应的元素，即在生成toString方法时不包含column参数；\n\n@ToString(exclude={\"column1\",\"column2\"})\n\n意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数；\n@ToString(of=\"column\")\n\n意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；\n\n@ToString(of={\"column1\",\"column2\"})\n\n意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；\n\n\n\nJava中的::是Java8的新特性的应用。\n\n\n\nforeach是属于Java集合的一个方法，准确来说，集合中Java8拥有一个stream方法，可以得到一个流对象，这个对象拥有很多方法，这些方法可以很方便的对集合进行例如排序，分组，计数，遍历，转换等操作，而遍历是比较常见的一种，forEach就是用来做这个的，这里的forEach就是stream的forEach。\n\njava此时还有另外一个特性叫做lambda表达式和函数式接口，仅仅有一个未实现方法的接口，可以直接写作**(参数列表)** -> {**方法体**}这种形式。\n\n**省去了之前需要专为他编写一个实现类或者匿名内部类的代码，直接对接口进行实现。**\n\nforEach方法提供一个某种类型的Object，（具体是什么类型是要看**Stream类的泛型参数**<T>的，不过一般就是这个集合提供的那种类型），\n\n而System.out.println可以接受一个Object，因此，forEach提供的参数和System.out.println的参数类型是一致的，可以进行这种简写。\n\n\n\n具体来说就是：原本应该写为：\n\n.forEach(**element** -> {\n\nSystem.out.println(**element**)\n\n})\n\n\n\n但是**System.out.println的参数**和**传递的参数element** 的类型完全匹配，所以这样的时候就可以简化为：\n\n.forEach(System.out::println)\n\n即forEach将会使用**System.out对象**的**println方法**进行接下来的操作。\n\n\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"a\");\nlist.add(\"b\");\nlist.add(\"c\");\nlist.forEach(System.out::println);\n```\n\n其中list.forEach可以改写成以下代码：\n\n```Java\nfor(int i = 0; i < list.size(); i++) {\n    System.out.println(list.get(i));\n}\n```\n\n或者等于以下代码：\n\n```Java\nfor(String s : list) {\n    System.out.println(s);\n}\n```\n\n## 实际场景\n\n有一个集合：List users = getList(); //从数据库查询的用户集合\n\n现在想获取User的身份证号码；在后续的逻辑处理中要用,\n\n常用的方法我们大家都知道，**用for循环**，\n\n```java\nList idcards=new ArrayList();//定义一个集合来装身份证号码\n\nfor(int i=0;i<users.size();i++){\n\n\tidcards.add(users.get(i).getIdcard());\n\n}\n```\n\n\n\n这种方法要写好几行代码，有没有简单点的，有，java8 API能一行搞定：\n\n```java\nList idcards= users.stream().map(User::getIdcard).collect(Collectors.toList());\n```\n\n### Arrays.stream()\n\n#### 为什么需要 Stream\n\nStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Java 8 中的 Stream 是对集合（Collection）**对象功能的增强**，它专注于对**集合对象**进行各种非常便利、**高效的聚合操作**（aggregate operation），或者大批量数据操作 (bulk data operation)。\n\nStream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供**串行**和**并行**两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 **fork/join 并行方式**来拆分任务和加速处理过程。\n\n\n\n**通常编写并行代码很难而且容易出错**，但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.**stream** 是一个函数式语言+多核时代综合影响的产物。\n\n### 什么是流\n\nStream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；\n\n高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。\n\nStream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，**遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。**\n\n而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。**而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，**然后将结果一起输出。\n\nJava 的并行 API 演变历程基本如下：\n\n1. 1.0-1.4 中的 java.lang.Thread\n2. 5.0 中的 java.util.concurrent\n3. 6.0 中的 Phasers 等\n4. 7.0 中的 Fork/Join 框架\n5. 8.0 中的 Lambda\n\n","source":"_posts/8月6日.md","raw":"---\ntitle: 8月6日\ndate: 2021-08-06 10:25:36\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt9ji9umigj30ci09ut94.jpg\n---\n\n前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。\n\n\n\n为什么要使用s l f4j\n\n我们自己的系统中使用了logback这个日志系统\n我们的系统使用了A.jar，A.jar中使用的日志系统为log4j\n我们的系统又使用了B.jar，B.jar中使用的日志系统为slf4j-simple\n\n这样，我们的系统就不得不同时支持并维护logback、log4j、slf4j-simple三种日志框架，非常不便。\n\n解决这个问题的方式就是引入一个适配层，由适配层决定使用哪一种日志系统，而调用端只需要做的事情就是打印日志而不需要关心如何打印日志，slf4j或者commons-logging就是这种适配层，slf4j是本文研究的对象。\n\n从上面的描述，我们必须清楚地知道一点：**slf4j只是一个日志标准，并不是日志系统的具体实现**。理解这句话非常重要，slf4j只做两件事情：\n\n- 提供日志接口\n- 提供获取具体日志对象的方法\n\n```kotlin\n#下面是配置将日志信息插入数据库，\n#配置输出目标为数据库（假如要将日志在控制台输出，配置为log4j.appender. stdout =org.apache.log4j.ConsoleAppender；将日志写入文件，配置为log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppender\n#这样的配置在许多地方都要有，需要可查有关资料）,当然你也可以自己扩展org.apache.log4j.jdbc.JDBCAppender这个类，只需要在这里配置就可以了例如我们配置我自己扩展的MyJDBCAppender，配置为#log4j.appender.db=com.neam.commons.MyJDBCAppender\nlog4j.appender.datasource=org.apache.log4j.jdbc.JDBCAppender\nlog4j.appender.datasource.layout=org.apache.log4j.PatternLayout\nlog4j.appender.datasource.driver=com.mysql.jdbc.Driver\n#定义什么级别的错误将写入到数据库中\nlog4j.appender.datasource.BufferSize=1\n#设置缓存大小，就是当有1条日志信息是才忘数据库插一次，我设置的数据库名和表名均为user\nlog4j.appender.datasource.URL=jdbc\\:mysql\\://localhost\\:3306/user?characterEncoding\\=UTF8&zeroDateTimeBehavior\\=convertToNull\nlog4j.appender.datasource.user=root\nlog4j.appender.datasource.password=root\nlog4j.appender.datasource.sql=insert into user (class,method,create_time,log_level,log_line,msg) values ('%C','%M','%d{yyyy-MM-dd HH:mm:ss}','%p','%l','%m')\n```\n\n\n\n```\n同义词在去重校验逻辑中的业务编码为2\n```\n\n@Query注解：\n 这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。\n\n如果是 @Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %\n\n还可以使用@Query来指定**本地查询**，只要设置**nativeQuery为true**，\n\n\n\n简明扼要的介绍一下@Data注解的**功能与使用方法**\n   **注解功能**\n    1、@Data可以为类提供读写功能，从而不用写get、set方法。\n    2、@Data提供 equals()、hashCode()、toString() 方法。\n\n\n\nLombok项目是一种自动接通你的编辑器和构建工具的一个Java库。不用再一次写额外的getter或者equals方法。由此可以看出，lombok会帮我们自动生成getter和euqals方法,但是更有意思的是,当我们的变量发生改变时,我们不再需要修改对的getter、setter方法,lombok帮我们在运行的过程中自动生成上述方法,编码更灵活.\n\n所以,使用lombok的优点: 1、简化long冗余的javabean代码;\n\n​                                    2、提高执行效率\n\n### lombok中的常用注解\n\n- @Setter ：在JavaBean或类JavaBean中使用，使用此注解会生成对应的setter方法；\n- @Getter：在JavaBean或类JavaBean中使用，使用此注解会生成对应的getter方法；\n- @ToString：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法；\n- @NoArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的无参构造方法；\n- @HashCode：\n- @Equals：\n- @CanEqual：\n- @Data：在JavaBean或类JavaBean中使用，这个注解包含范围最广，它包含上述注解，即当使用当前注解时，会自动生成包含的所有方法；\n- @AllArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的有参构造方法；\n- @Log(这是一个泛型注解，具体有很多种形式)\n- @EqualsAndHashCode：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的equals方法和hashCode方法；\n\n1. 此注解会生成`equals(Object other)` 和 `hashCode()`方法。\n2. 它默认使用非静态，非瞬态的属性\n3. 可通过参数`exclude`排除一些属性\n4. 可通过参数`of`指定仅使用哪些属性\n5. 它默认仅使用该类中定义的属性且不调用父类的方法\n6. 可通过`callSuper=true`解决上一点问题。让其生成的方法中调用父类的方法。\n7. @Slf4j：在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可；\n\n@ToString(exclude=\"column\")\n\n意义：排除column列所对应的元素，即在生成toString方法时不包含column参数；\n\n@ToString(exclude={\"column1\",\"column2\"})\n\n意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数；\n@ToString(of=\"column\")\n\n意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；\n\n@ToString(of={\"column1\",\"column2\"})\n\n意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；\n\n\n\nJava中的::是Java8的新特性的应用。\n\n\n\nforeach是属于Java集合的一个方法，准确来说，集合中Java8拥有一个stream方法，可以得到一个流对象，这个对象拥有很多方法，这些方法可以很方便的对集合进行例如排序，分组，计数，遍历，转换等操作，而遍历是比较常见的一种，forEach就是用来做这个的，这里的forEach就是stream的forEach。\n\njava此时还有另外一个特性叫做lambda表达式和函数式接口，仅仅有一个未实现方法的接口，可以直接写作**(参数列表)** -> {**方法体**}这种形式。\n\n**省去了之前需要专为他编写一个实现类或者匿名内部类的代码，直接对接口进行实现。**\n\nforEach方法提供一个某种类型的Object，（具体是什么类型是要看**Stream类的泛型参数**<T>的，不过一般就是这个集合提供的那种类型），\n\n而System.out.println可以接受一个Object，因此，forEach提供的参数和System.out.println的参数类型是一致的，可以进行这种简写。\n\n\n\n具体来说就是：原本应该写为：\n\n.forEach(**element** -> {\n\nSystem.out.println(**element**)\n\n})\n\n\n\n但是**System.out.println的参数**和**传递的参数element** 的类型完全匹配，所以这样的时候就可以简化为：\n\n.forEach(System.out::println)\n\n即forEach将会使用**System.out对象**的**println方法**进行接下来的操作。\n\n\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"a\");\nlist.add(\"b\");\nlist.add(\"c\");\nlist.forEach(System.out::println);\n```\n\n其中list.forEach可以改写成以下代码：\n\n```Java\nfor(int i = 0; i < list.size(); i++) {\n    System.out.println(list.get(i));\n}\n```\n\n或者等于以下代码：\n\n```Java\nfor(String s : list) {\n    System.out.println(s);\n}\n```\n\n## 实际场景\n\n有一个集合：List users = getList(); //从数据库查询的用户集合\n\n现在想获取User的身份证号码；在后续的逻辑处理中要用,\n\n常用的方法我们大家都知道，**用for循环**，\n\n```java\nList idcards=new ArrayList();//定义一个集合来装身份证号码\n\nfor(int i=0;i<users.size();i++){\n\n\tidcards.add(users.get(i).getIdcard());\n\n}\n```\n\n\n\n这种方法要写好几行代码，有没有简单点的，有，java8 API能一行搞定：\n\n```java\nList idcards= users.stream().map(User::getIdcard).collect(Collectors.toList());\n```\n\n### Arrays.stream()\n\n#### 为什么需要 Stream\n\nStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Java 8 中的 Stream 是对集合（Collection）**对象功能的增强**，它专注于对**集合对象**进行各种非常便利、**高效的聚合操作**（aggregate operation），或者大批量数据操作 (bulk data operation)。\n\nStream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供**串行**和**并行**两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 **fork/join 并行方式**来拆分任务和加速处理过程。\n\n\n\n**通常编写并行代码很难而且容易出错**，但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.**stream** 是一个函数式语言+多核时代综合影响的产物。\n\n### 什么是流\n\nStream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；\n\n高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。\n\nStream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，**遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。**\n\n而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。**而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，**然后将结果一起输出。\n\nJava 的并行 API 演变历程基本如下：\n\n1. 1.0-1.4 中的 java.lang.Thread\n2. 5.0 中的 java.util.concurrent\n3. 6.0 中的 Phasers 等\n4. 7.0 中的 Fork/Join 框架\n5. 8.0 中的 Lambda\n\n","slug":"8月6日","published":1,"updated":"2021-08-08T10:07:45.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8s000yc3761ptdabc9","content":"<p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p>\n<p>为什么要使用s l f4j</p>\n<p>我们自己的系统中使用了logback这个日志系统<br>我们的系统使用了A.jar，A.jar中使用的日志系统为log4j<br>我们的系统又使用了B.jar，B.jar中使用的日志系统为slf4j-simple</p>\n<p>这样，我们的系统就不得不同时支持并维护logback、log4j、slf4j-simple三种日志框架，非常不便。</p>\n<p>解决这个问题的方式就是引入一个适配层，由适配层决定使用哪一种日志系统，而调用端只需要做的事情就是打印日志而不需要关心如何打印日志，slf4j或者commons-logging就是这种适配层，slf4j是本文研究的对象。</p>\n<p>从上面的描述，我们必须清楚地知道一点：<strong>slf4j只是一个日志标准，并不是日志系统的具体实现</strong>。理解这句话非常重要，slf4j只做两件事情：</p>\n<ul>\n<li>提供日志接口</li>\n<li>提供获取具体日志对象的方法</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#下面是配置将日志信息插入数据库，</span><br><span class=\"line\">#配置输出目标为数据库（假如要将日志在控制台输出，配置为log4j.appender. stdout =org.apache.log4j.ConsoleAppender；将日志写入文件，配置为log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">#这样的配置在许多地方都要有，需要可查有关资料）,当然你也可以自己扩展org.apache.log4j.jdbc.JDBCAppender这个类，只需要在这里配置就可以了例如我们配置我自己扩展的MyJDBCAppender，配置为#log4j.appender.db=com.neam.commons.MyJDBCAppender</span><br><span class=\"line\">log4j.appender.datasource=org.apache.log4j.jdbc.JDBCAppender</span><br><span class=\"line\">log4j.appender.datasource.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.datasource.driver=com.mysql.jdbc.Driver</span><br><span class=\"line\">#定义什么级别的错误将写入到数据库中</span><br><span class=\"line\">log4j.appender.datasource.BufferSize=<span class=\"number\">1</span></span><br><span class=\"line\">#设置缓存大小，就是当有<span class=\"number\">1</span>条日志信息是才忘数据库插一次，我设置的数据库名和表名均为user</span><br><span class=\"line\">log4j.appender.datasource.URL=jdbc\\:mysql\\:<span class=\"comment\">//localhost\\:3306/user?characterEncoding\\=UTF8&amp;zeroDateTimeBehavior\\=convertToNull</span></span><br><span class=\"line\">log4j.appender.datasource.user=root</span><br><span class=\"line\">log4j.appender.datasource.password=root</span><br><span class=\"line\">log4j.appender.datasource.sql=insert into user (<span class=\"class\"><span class=\"keyword\">class</span>,<span class=\"type\">method</span>,<span class=\"type\">create_time</span>,<span class=\"type\">log_level</span>,<span class=\"type\">log_line</span>,<span class=\"type\">msg) values </span></span>(<span class=\"string\">&#x27;%C&#x27;</span>,<span class=\"string\">&#x27;%M&#x27;</span>,<span class=\"string\">&#x27;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&#x27;</span>,<span class=\"string\">&#x27;%p&#x27;</span>,<span class=\"string\">&#x27;%l&#x27;</span>,<span class=\"string\">&#x27;%m&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同义词在去重校验逻辑中的业务编码为2</span><br></pre></td></tr></table></figure>\n\n<p>@Query注解：<br> 这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。</p>\n<p>如果是 @Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %</p>\n<p>还可以使用@Query来指定<strong>本地查询</strong>，只要设置<strong>nativeQuery为true</strong>，</p>\n<p>简明扼要的介绍一下@Data注解的<strong>功能与使用方法</strong><br>   <strong>注解功能</strong><br>    1、@Data可以为类提供读写功能，从而不用写get、set方法。<br>    2、@Data提供 equals()、hashCode()、toString() 方法。</p>\n<p>Lombok项目是一种自动接通你的编辑器和构建工具的一个Java库。不用再一次写额外的getter或者equals方法。由此可以看出，lombok会帮我们自动生成getter和euqals方法,但是更有意思的是,当我们的变量发生改变时,我们不再需要修改对的getter、setter方法,lombok帮我们在运行的过程中自动生成上述方法,编码更灵活.</p>\n<p>所以,使用lombok的优点: 1、简化long冗余的javabean代码;</p>\n<p>​                                    2、提高执行效率</p>\n<h3 id=\"lombok中的常用注解\"><a href=\"#lombok中的常用注解\" class=\"headerlink\" title=\"lombok中的常用注解\"></a>lombok中的常用注解</h3><ul>\n<li>@Setter ：在JavaBean或类JavaBean中使用，使用此注解会生成对应的setter方法；</li>\n<li>@Getter：在JavaBean或类JavaBean中使用，使用此注解会生成对应的getter方法；</li>\n<li>@ToString：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法；</li>\n<li>@NoArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的无参构造方法；</li>\n<li>@HashCode：</li>\n<li>@Equals：</li>\n<li>@CanEqual：</li>\n<li>@Data：在JavaBean或类JavaBean中使用，这个注解包含范围最广，它包含上述注解，即当使用当前注解时，会自动生成包含的所有方法；</li>\n<li>@AllArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的有参构造方法；</li>\n<li>@Log(这是一个泛型注解，具体有很多种形式)</li>\n<li>@EqualsAndHashCode：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的equals方法和hashCode方法；</li>\n</ul>\n<ol>\n<li>此注解会生成<code>equals(Object other)</code> 和 <code>hashCode()</code>方法。</li>\n<li>它默认使用非静态，非瞬态的属性</li>\n<li>可通过参数<code>exclude</code>排除一些属性</li>\n<li>可通过参数<code>of</code>指定仅使用哪些属性</li>\n<li>它默认仅使用该类中定义的属性且不调用父类的方法</li>\n<li>可通过<code>callSuper=true</code>解决上一点问题。让其生成的方法中调用父类的方法。</li>\n<li>@Slf4j：在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可；</li>\n</ol>\n<p>@ToString(exclude=”column”)</p>\n<p>意义：排除column列所对应的元素，即在生成toString方法时不包含column参数；</p>\n<p>@ToString(exclude={“column1”,”column2”})</p>\n<p>意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数；<br>@ToString(of=”column”)</p>\n<p>意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；</p>\n<p>@ToString(of={“column1”,”column2”})</p>\n<p>意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；</p>\n<p>Java中的::是Java8的新特性的应用。</p>\n<p>foreach是属于Java集合的一个方法，准确来说，集合中Java8拥有一个stream方法，可以得到一个流对象，这个对象拥有很多方法，这些方法可以很方便的对集合进行例如排序，分组，计数，遍历，转换等操作，而遍历是比较常见的一种，forEach就是用来做这个的，这里的forEach就是stream的forEach。</p>\n<p>java此时还有另外一个特性叫做lambda表达式和函数式接口，仅仅有一个未实现方法的接口，可以直接写作**(参数列表)** -&gt; {<strong>方法体</strong>}这种形式。</p>\n<p><strong>省去了之前需要专为他编写一个实现类或者匿名内部类的代码，直接对接口进行实现。</strong></p>\n<p>forEach方法提供一个某种类型的Object，（具体是什么类型是要看<strong>Stream类的泛型参数</strong><T>的，不过一般就是这个集合提供的那种类型），</p>\n<p>而System.out.println可以接受一个Object，因此，forEach提供的参数和System.out.println的参数类型是一致的，可以进行这种简写。</p>\n<p>具体来说就是：原本应该写为：</p>\n<p>.forEach(<strong>element</strong> -&gt; {</p>\n<p>System.out.println(<strong>element</strong>)</p>\n<p>})</p>\n<p>但是<strong>System.out.println的参数</strong>和<strong>传递的参数element</strong> 的类型完全匹配，所以这样的时候就可以简化为：</p>\n<p>.forEach(System.out::println)</p>\n<p>即forEach将会使用<strong>System.out对象</strong>的<strong>println方法</strong>进行接下来的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p>其中list.forEach可以改写成以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">    System.out.println(list.get(i));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者等于以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String s : list) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实际场景\"><a href=\"#实际场景\" class=\"headerlink\" title=\"实际场景\"></a>实际场景</h2><p>有一个集合：List users = getList(); //从数据库查询的用户集合</p>\n<p>现在想获取User的身份证号码；在后续的逻辑处理中要用,</p>\n<p>常用的方法我们大家都知道，<strong>用for循环</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List idcards=<span class=\"keyword\">new</span> ArrayList();<span class=\"comment\">//定义一个集合来装身份证号码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;users.size();i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tidcards.add(users.get(i).getIdcard());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种方法要写好几行代码，有没有简单点的，有，java8 API能一行搞定：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List idcards= users.stream().map(User::getIdcard).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arrays-stream\"><a href=\"#Arrays-stream\" class=\"headerlink\" title=\"Arrays.stream()\"></a>Arrays.stream()</h3><h4 id=\"为什么需要-Stream\"><a href=\"#为什么需要-Stream\" class=\"headerlink\" title=\"为什么需要 Stream\"></a>为什么需要 Stream</h4><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Java 8 中的 Stream 是对集合（Collection）<strong>对象功能的增强</strong>，它专注于对<strong>集合对象</strong>进行各种非常便利、<strong>高效的聚合操作</strong>（aggregate operation），或者大批量数据操作 (bulk data operation)。</p>\n<p>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供<strong>串行</strong>和<strong>并行</strong>两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 <strong>fork/join 并行方式</strong>来拆分任务和加速处理过程。</p>\n<p><strong>通常编写并行代码很难而且容易出错</strong>，但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.<strong>stream</strong> 是一个函数式语言+多核时代综合影响的产物。</p>\n<h3 id=\"什么是流\"><a href=\"#什么是流\" class=\"headerlink\" title=\"什么是流\"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；</p>\n<p>高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，<strong>遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</strong></p>\n<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。<strong>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，</strong>然后将结果一起输出。</p>\n<p>Java 的并行 API 演变历程基本如下：</p>\n<ol>\n<li>1.0-1.4 中的 java.lang.Thread</li>\n<li>5.0 中的 java.util.concurrent</li>\n<li>6.0 中的 Phasers 等</li>\n<li>7.0 中的 Fork/Join 框架</li>\n<li>8.0 中的 Lambda</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p>\n<p>为什么要使用s l f4j</p>\n<p>我们自己的系统中使用了logback这个日志系统<br>我们的系统使用了A.jar，A.jar中使用的日志系统为log4j<br>我们的系统又使用了B.jar，B.jar中使用的日志系统为slf4j-simple</p>\n<p>这样，我们的系统就不得不同时支持并维护logback、log4j、slf4j-simple三种日志框架，非常不便。</p>\n<p>解决这个问题的方式就是引入一个适配层，由适配层决定使用哪一种日志系统，而调用端只需要做的事情就是打印日志而不需要关心如何打印日志，slf4j或者commons-logging就是这种适配层，slf4j是本文研究的对象。</p>\n<p>从上面的描述，我们必须清楚地知道一点：<strong>slf4j只是一个日志标准，并不是日志系统的具体实现</strong>。理解这句话非常重要，slf4j只做两件事情：</p>\n<ul>\n<li>提供日志接口</li>\n<li>提供获取具体日志对象的方法</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#下面是配置将日志信息插入数据库，</span><br><span class=\"line\">#配置输出目标为数据库（假如要将日志在控制台输出，配置为log4j.appender. stdout =org.apache.log4j.ConsoleAppender；将日志写入文件，配置为log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">#这样的配置在许多地方都要有，需要可查有关资料）,当然你也可以自己扩展org.apache.log4j.jdbc.JDBCAppender这个类，只需要在这里配置就可以了例如我们配置我自己扩展的MyJDBCAppender，配置为#log4j.appender.db=com.neam.commons.MyJDBCAppender</span><br><span class=\"line\">log4j.appender.datasource=org.apache.log4j.jdbc.JDBCAppender</span><br><span class=\"line\">log4j.appender.datasource.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.datasource.driver=com.mysql.jdbc.Driver</span><br><span class=\"line\">#定义什么级别的错误将写入到数据库中</span><br><span class=\"line\">log4j.appender.datasource.BufferSize=<span class=\"number\">1</span></span><br><span class=\"line\">#设置缓存大小，就是当有<span class=\"number\">1</span>条日志信息是才忘数据库插一次，我设置的数据库名和表名均为user</span><br><span class=\"line\">log4j.appender.datasource.URL=jdbc\\:mysql\\:<span class=\"comment\">//localhost\\:3306/user?characterEncoding\\=UTF8&amp;zeroDateTimeBehavior\\=convertToNull</span></span><br><span class=\"line\">log4j.appender.datasource.user=root</span><br><span class=\"line\">log4j.appender.datasource.password=root</span><br><span class=\"line\">log4j.appender.datasource.sql=insert into user (<span class=\"class\"><span class=\"keyword\">class</span>,<span class=\"type\">method</span>,<span class=\"type\">create_time</span>,<span class=\"type\">log_level</span>,<span class=\"type\">log_line</span>,<span class=\"type\">msg) values </span></span>(<span class=\"string\">&#x27;%C&#x27;</span>,<span class=\"string\">&#x27;%M&#x27;</span>,<span class=\"string\">&#x27;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&#x27;</span>,<span class=\"string\">&#x27;%p&#x27;</span>,<span class=\"string\">&#x27;%l&#x27;</span>,<span class=\"string\">&#x27;%m&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同义词在去重校验逻辑中的业务编码为2</span><br></pre></td></tr></table></figure>\n\n<p>@Query注解：<br> 这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。</p>\n<p>如果是 @Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %</p>\n<p>还可以使用@Query来指定<strong>本地查询</strong>，只要设置<strong>nativeQuery为true</strong>，</p>\n<p>简明扼要的介绍一下@Data注解的<strong>功能与使用方法</strong><br>   <strong>注解功能</strong><br>    1、@Data可以为类提供读写功能，从而不用写get、set方法。<br>    2、@Data提供 equals()、hashCode()、toString() 方法。</p>\n<p>Lombok项目是一种自动接通你的编辑器和构建工具的一个Java库。不用再一次写额外的getter或者equals方法。由此可以看出，lombok会帮我们自动生成getter和euqals方法,但是更有意思的是,当我们的变量发生改变时,我们不再需要修改对的getter、setter方法,lombok帮我们在运行的过程中自动生成上述方法,编码更灵活.</p>\n<p>所以,使用lombok的优点: 1、简化long冗余的javabean代码;</p>\n<p>​                                    2、提高执行效率</p>\n<h3 id=\"lombok中的常用注解\"><a href=\"#lombok中的常用注解\" class=\"headerlink\" title=\"lombok中的常用注解\"></a>lombok中的常用注解</h3><ul>\n<li>@Setter ：在JavaBean或类JavaBean中使用，使用此注解会生成对应的setter方法；</li>\n<li>@Getter：在JavaBean或类JavaBean中使用，使用此注解会生成对应的getter方法；</li>\n<li>@ToString：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法；</li>\n<li>@NoArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的无参构造方法；</li>\n<li>@HashCode：</li>\n<li>@Equals：</li>\n<li>@CanEqual：</li>\n<li>@Data：在JavaBean或类JavaBean中使用，这个注解包含范围最广，它包含上述注解，即当使用当前注解时，会自动生成包含的所有方法；</li>\n<li>@AllArgsConstructor：在JavaBean或类JavaBean中使用，使用此注解会生成对应的有参构造方法；</li>\n<li>@Log(这是一个泛型注解，具体有很多种形式)</li>\n<li>@EqualsAndHashCode：在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的equals方法和hashCode方法；</li>\n</ul>\n<ol>\n<li>此注解会生成<code>equals(Object other)</code> 和 <code>hashCode()</code>方法。</li>\n<li>它默认使用非静态，非瞬态的属性</li>\n<li>可通过参数<code>exclude</code>排除一些属性</li>\n<li>可通过参数<code>of</code>指定仅使用哪些属性</li>\n<li>它默认仅使用该类中定义的属性且不调用父类的方法</li>\n<li>可通过<code>callSuper=true</code>解决上一点问题。让其生成的方法中调用父类的方法。</li>\n<li>@Slf4j：在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可；</li>\n</ol>\n<p>@ToString(exclude=”column”)</p>\n<p>意义：排除column列所对应的元素，即在生成toString方法时不包含column参数；</p>\n<p>@ToString(exclude={“column1”,”column2”})</p>\n<p>意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数；<br>@ToString(of=”column”)</p>\n<p>意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；</p>\n<p>@ToString(of={“column1”,”column2”})</p>\n<p>意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；</p>\n<p>Java中的::是Java8的新特性的应用。</p>\n<p>foreach是属于Java集合的一个方法，准确来说，集合中Java8拥有一个stream方法，可以得到一个流对象，这个对象拥有很多方法，这些方法可以很方便的对集合进行例如排序，分组，计数，遍历，转换等操作，而遍历是比较常见的一种，forEach就是用来做这个的，这里的forEach就是stream的forEach。</p>\n<p>java此时还有另外一个特性叫做lambda表达式和函数式接口，仅仅有一个未实现方法的接口，可以直接写作**(参数列表)** -&gt; {<strong>方法体</strong>}这种形式。</p>\n<p><strong>省去了之前需要专为他编写一个实现类或者匿名内部类的代码，直接对接口进行实现。</strong></p>\n<p>forEach方法提供一个某种类型的Object，（具体是什么类型是要看<strong>Stream类的泛型参数</strong><T>的，不过一般就是这个集合提供的那种类型），</p>\n<p>而System.out.println可以接受一个Object，因此，forEach提供的参数和System.out.println的参数类型是一致的，可以进行这种简写。</p>\n<p>具体来说就是：原本应该写为：</p>\n<p>.forEach(<strong>element</strong> -&gt; {</p>\n<p>System.out.println(<strong>element</strong>)</p>\n<p>})</p>\n<p>但是<strong>System.out.println的参数</strong>和<strong>传递的参数element</strong> 的类型完全匹配，所以这样的时候就可以简化为：</p>\n<p>.forEach(System.out::println)</p>\n<p>即forEach将会使用<strong>System.out对象</strong>的<strong>println方法</strong>进行接下来的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p>其中list.forEach可以改写成以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">    System.out.println(list.get(i));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者等于以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String s : list) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实际场景\"><a href=\"#实际场景\" class=\"headerlink\" title=\"实际场景\"></a>实际场景</h2><p>有一个集合：List users = getList(); //从数据库查询的用户集合</p>\n<p>现在想获取User的身份证号码；在后续的逻辑处理中要用,</p>\n<p>常用的方法我们大家都知道，<strong>用for循环</strong>，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List idcards=<span class=\"keyword\">new</span> ArrayList();<span class=\"comment\">//定义一个集合来装身份证号码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;users.size();i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tidcards.add(users.get(i).getIdcard());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这种方法要写好几行代码，有没有简单点的，有，java8 API能一行搞定：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List idcards= users.stream().map(User::getIdcard).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arrays-stream\"><a href=\"#Arrays-stream\" class=\"headerlink\" title=\"Arrays.stream()\"></a>Arrays.stream()</h3><h4 id=\"为什么需要-Stream\"><a href=\"#为什么需要-Stream\" class=\"headerlink\" title=\"为什么需要 Stream\"></a>为什么需要 Stream</h4><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Java 8 中的 Stream 是对集合（Collection）<strong>对象功能的增强</strong>，它专注于对<strong>集合对象</strong>进行各种非常便利、<strong>高效的聚合操作</strong>（aggregate operation），或者大批量数据操作 (bulk data operation)。</p>\n<p>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供<strong>串行</strong>和<strong>并行</strong>两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 <strong>fork/join 并行方式</strong>来拆分任务和加速处理过程。</p>\n<p><strong>通常编写并行代码很难而且容易出错</strong>，但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.<strong>stream</strong> 是一个函数式语言+多核时代综合影响的产物。</p>\n<h3 id=\"什么是流\"><a href=\"#什么是流\" class=\"headerlink\" title=\"什么是流\"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；</p>\n<p>高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，<strong>遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</strong></p>\n<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。<strong>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，</strong>然后将结果一起输出。</p>\n<p>Java 的并行 API 演变历程基本如下：</p>\n<ol>\n<li>1.0-1.4 中的 java.lang.Thread</li>\n<li>5.0 中的 java.util.concurrent</li>\n<li>6.0 中的 Phasers 等</li>\n<li>7.0 中的 Fork/Join 框架</li>\n<li>8.0 中的 Lambda</li>\n</ol>\n"},{"title":"8月7日","date":"2021-08-07T02:46:31.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt8a7den98j318z0u049r.jpg","_content":"\n\npostman测试的时候遇到一些坑，\n\n管理系统需要authorization，这里需要了解一下authorization和cookie，以后面试还是能用上的。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt8bhhsbljj31ho0jaq4v.jpg)\n\n\n\n\n\n写代码的时候，有时候同样的名字的包容易调错，而且整个系统都不报错，在测试的时候就很难排查，比如pageable，有JPA的pageable和jwt的pageable。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt8bfmkixuj31k40ikmz0.jpg)\n\n\n\n测试删除，传入idx数组的方式。\n\n\n\n\"could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement\",\n\n\n\n是因为有非空字段请求体中没有，\n\n","source":"_posts/8月7日.md","raw":"---\ntitle: 8月7日\ndate: 2021-08-07 10:46:31\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt8a7den98j318z0u049r.jpg\n---\n\n\npostman测试的时候遇到一些坑，\n\n管理系统需要authorization，这里需要了解一下authorization和cookie，以后面试还是能用上的。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt8bhhsbljj31ho0jaq4v.jpg)\n\n\n\n\n\n写代码的时候，有时候同样的名字的包容易调错，而且整个系统都不报错，在测试的时候就很难排查，比如pageable，有JPA的pageable和jwt的pageable。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt8bfmkixuj31k40ikmz0.jpg)\n\n\n\n测试删除，传入idx数组的方式。\n\n\n\n\"could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement\",\n\n\n\n是因为有非空字段请求体中没有，\n\n","slug":"8月7日","published":1,"updated":"2021-08-09T06:17:40.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8t0011c376gd4b1pv4","content":"<p>postman测试的时候遇到一些坑，</p>\n<p>管理系统需要authorization，这里需要了解一下authorization和cookie，以后面试还是能用上的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt8bhhsbljj31ho0jaq4v.jpg\"></p>\n<p>写代码的时候，有时候同样的名字的包容易调错，而且整个系统都不报错，在测试的时候就很难排查，比如pageable，有JPA的pageable和jwt的pageable。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt8bfmkixuj31k40ikmz0.jpg\"></p>\n<p>测试删除，传入idx数组的方式。</p>\n<p>“could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement”,</p>\n<p>是因为有非空字段请求体中没有，</p>\n","site":{"data":{}},"excerpt":"","more":"<p>postman测试的时候遇到一些坑，</p>\n<p>管理系统需要authorization，这里需要了解一下authorization和cookie，以后面试还是能用上的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt8bhhsbljj31ho0jaq4v.jpg\"></p>\n<p>写代码的时候，有时候同样的名字的包容易调错，而且整个系统都不报错，在测试的时候就很难排查，比如pageable，有JPA的pageable和jwt的pageable。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt8bfmkixuj31k40ikmz0.jpg\"></p>\n<p>测试删除，传入idx数组的方式。</p>\n<p>“could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement”,</p>\n<p>是因为有非空字段请求体中没有，</p>\n"},{"title":"8月9日","date":"2021-08-09T01:17:44.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gta9uurcdqj31900u0drc.jpg","_content":"\n貌似大巴黎把8月10号也就是明天的埃菲尔铁塔的包下来了，签约梅西应该十拿九稳了。\n\n梅西+姆巴佩+内马尔+迪马利亚，这波是宇宙飞船\n\n谢希科的论文才写了一半，公司的业务挣扎中，\n\n今天先写完词典管理吧\n\n有nativeQuery = true时，是可以执行原生sql语句，所谓原生sql，也就是说这段sql拷贝到数据库中，然后把参数值给一下就能运行了\n\n热搜统计：\n\n说明\n\n1、默认统计各个频道下最近一个月相关搜索标的的排名和搜索量,推荐开关默认都是开启的\n\n2、关闭推荐按钮，则此标的不会被推荐到热搜栏位\n\n3、标的可能存在同名的，可以通过ID区分\n\n4、再推荐到H5的热搜栏位时，如果热搜配置中，经配置了重名的标的，则取热搜统计中后一位的标的名称\n\n5、如果所有的热搜标的都关闭了推荐，**则只显示热搜配置里面配置的标的**，如果热搜配置里面也没有配置，则整个H5上整个热搜板块都不显示\n\n```java\n@Modifying\n    @Query(value = \"update search_config_hot set status = 0 where level = ?1 and type = ?2 and status = 1\", nativeQuery = true)\n    void updateByLevelAndType(Integer level, String type);\n```\nlevel=?1 相当于把sql的第一个参数传入后面的update函数\n\n反射不支持基本类型\n\nJpaRepository 接口的三个父接口中，CrudRepository 接口定义了最基本的 CRUD 方法；\n\nPagingAndSortingRepository 接口定义了分页和排序要用到的方法； \n\nQueryByExampleExecutor 接口定义的是按实例进行查询的方法。\n\n（2）JpaSpecificationExecutor 接口：自定义查询的接口\n比如模糊查询、表关联查询等都通过它来完成，业务接口 CfgPhysicalDbRepository 同样实现了它，我们在代码中调用的 findAll(Specification<T> spec, Pageable pageable) 方法就是由它定义的。\n\n（3）SimpleJpaRepository 类：常用 CRUD 方法的真正实现类\n\n当业务接口 CfgPhysicalDbRepository 调用 JpaRepository 接口中的 CRUD 方法，或者 JpaSpecificationExecutor 接口中的 findAll 方法时，\n\n应该有一个业务实现类 CfgPhysicalDbRepositoryImpl 来实现这些方法，\n\n所以我们可以在同一个包下定义一个实现类 CfgPhysicalDbRepositoryImpl 来重写这些方法。\n\n但是我们很少看见有人这样写，这样写就是和普通的 Dao、DaoImpl 没有两样了。 \n\nJPA 有它自己的玩法，这些常用的方法， JPA 都通过接口定义好并且在 SimpleJpaRepository 中替你一一实现了，\n\n所以说当代码执行找不到 CfgPhysicalDbRepositoryImpl 的时候，就会一直向下找，\n\n最终找到 SimpleJpaRepository 中的实现方法为止，此处是一个委派模式。\n\n2、详解 SimpleJpaRepository 的 findAll(Specification<T> spec, Pageable pageable) 方法\n\n（1）JPA的复杂查询都必须经历四个步骤：\n\n1、获取 builder => CriteriaBuilder builder = em.getCriteriaBuilder();\n2、获取 Query =>CriteriaQuery<Student> query = builder.createQuery(CfgPhysicalDb.class);\n3、在 Query 中构造查询条件 => Predicate predicate = spec.toPredicate(root, query, builder);\n4、执行查询 => query.getResultList()\n\n我们只需要在方法的参数中直接定义一个pageable类型的参数，当Spring发现这个参数时，Spring会自动的根据request的参数来组装该pageable对象\n\nSpring支持的request参数如下：\n\npage，第几页，从0开始，默认为第0页\nsize，每一页的大小，默认为20\nsort，排序相关的信息，例如sort=firstname&sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列\n\n\n\n```\nrollbackFor = Exception.class\n```\n\n一个注解@Transactional(rollbackFor = Exception.class)，今天就和大家分享一下，这个注解的用法；\n\n## 异常\n\n如下图所示，我们都知道Exception分为运行时异常RuntimeException和非运行时异常\n\nerror是一定会回滚的\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtaizcnc5jj30fj0elaar.jpg)\n\n如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。\n\n如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，**正常的处理应该是把异常数据舍弃，然后记录日志。**不应该由于异常数据而影响下面对正常数据的处理。\n\n非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。\n\n### 使用说明\n\n当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。\n\n在项目中，@Transactional(rollbackFor=Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。\n\n在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚\n\n数据库如果不是从1自增，可以把表内数据都删了。\n\n本地测试没问题，前端那边测试有问题肯定要么事仓库代码没更新，要么是部署没更新。\n\n\n\n改数据，请求能成功，但是数据库没反应，是sql语句的表名复制粘贴没改过来\n\n\n\n\n\n","source":"_posts/8月9日.md","raw":"---\ntitle: 8月9日\ndate: 2021-08-09 09:17:44\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gta9uurcdqj31900u0drc.jpg\n---\n\n貌似大巴黎把8月10号也就是明天的埃菲尔铁塔的包下来了，签约梅西应该十拿九稳了。\n\n梅西+姆巴佩+内马尔+迪马利亚，这波是宇宙飞船\n\n谢希科的论文才写了一半，公司的业务挣扎中，\n\n今天先写完词典管理吧\n\n有nativeQuery = true时，是可以执行原生sql语句，所谓原生sql，也就是说这段sql拷贝到数据库中，然后把参数值给一下就能运行了\n\n热搜统计：\n\n说明\n\n1、默认统计各个频道下最近一个月相关搜索标的的排名和搜索量,推荐开关默认都是开启的\n\n2、关闭推荐按钮，则此标的不会被推荐到热搜栏位\n\n3、标的可能存在同名的，可以通过ID区分\n\n4、再推荐到H5的热搜栏位时，如果热搜配置中，经配置了重名的标的，则取热搜统计中后一位的标的名称\n\n5、如果所有的热搜标的都关闭了推荐，**则只显示热搜配置里面配置的标的**，如果热搜配置里面也没有配置，则整个H5上整个热搜板块都不显示\n\n```java\n@Modifying\n    @Query(value = \"update search_config_hot set status = 0 where level = ?1 and type = ?2 and status = 1\", nativeQuery = true)\n    void updateByLevelAndType(Integer level, String type);\n```\nlevel=?1 相当于把sql的第一个参数传入后面的update函数\n\n反射不支持基本类型\n\nJpaRepository 接口的三个父接口中，CrudRepository 接口定义了最基本的 CRUD 方法；\n\nPagingAndSortingRepository 接口定义了分页和排序要用到的方法； \n\nQueryByExampleExecutor 接口定义的是按实例进行查询的方法。\n\n（2）JpaSpecificationExecutor 接口：自定义查询的接口\n比如模糊查询、表关联查询等都通过它来完成，业务接口 CfgPhysicalDbRepository 同样实现了它，我们在代码中调用的 findAll(Specification<T> spec, Pageable pageable) 方法就是由它定义的。\n\n（3）SimpleJpaRepository 类：常用 CRUD 方法的真正实现类\n\n当业务接口 CfgPhysicalDbRepository 调用 JpaRepository 接口中的 CRUD 方法，或者 JpaSpecificationExecutor 接口中的 findAll 方法时，\n\n应该有一个业务实现类 CfgPhysicalDbRepositoryImpl 来实现这些方法，\n\n所以我们可以在同一个包下定义一个实现类 CfgPhysicalDbRepositoryImpl 来重写这些方法。\n\n但是我们很少看见有人这样写，这样写就是和普通的 Dao、DaoImpl 没有两样了。 \n\nJPA 有它自己的玩法，这些常用的方法， JPA 都通过接口定义好并且在 SimpleJpaRepository 中替你一一实现了，\n\n所以说当代码执行找不到 CfgPhysicalDbRepositoryImpl 的时候，就会一直向下找，\n\n最终找到 SimpleJpaRepository 中的实现方法为止，此处是一个委派模式。\n\n2、详解 SimpleJpaRepository 的 findAll(Specification<T> spec, Pageable pageable) 方法\n\n（1）JPA的复杂查询都必须经历四个步骤：\n\n1、获取 builder => CriteriaBuilder builder = em.getCriteriaBuilder();\n2、获取 Query =>CriteriaQuery<Student> query = builder.createQuery(CfgPhysicalDb.class);\n3、在 Query 中构造查询条件 => Predicate predicate = spec.toPredicate(root, query, builder);\n4、执行查询 => query.getResultList()\n\n我们只需要在方法的参数中直接定义一个pageable类型的参数，当Spring发现这个参数时，Spring会自动的根据request的参数来组装该pageable对象\n\nSpring支持的request参数如下：\n\npage，第几页，从0开始，默认为第0页\nsize，每一页的大小，默认为20\nsort，排序相关的信息，例如sort=firstname&sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列\n\n\n\n```\nrollbackFor = Exception.class\n```\n\n一个注解@Transactional(rollbackFor = Exception.class)，今天就和大家分享一下，这个注解的用法；\n\n## 异常\n\n如下图所示，我们都知道Exception分为运行时异常RuntimeException和非运行时异常\n\nerror是一定会回滚的\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtaizcnc5jj30fj0elaar.jpg)\n\n如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。\n\n如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，**正常的处理应该是把异常数据舍弃，然后记录日志。**不应该由于异常数据而影响下面对正常数据的处理。\n\n非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。\n\n### 使用说明\n\n当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。\n\n在项目中，@Transactional(rollbackFor=Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。\n\n在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚\n\n数据库如果不是从1自增，可以把表内数据都删了。\n\n本地测试没问题，前端那边测试有问题肯定要么事仓库代码没更新，要么是部署没更新。\n\n\n\n改数据，请求能成功，但是数据库没反应，是sql语句的表名复制粘贴没改过来\n\n\n\n\n\n","slug":"8月9日","published":1,"updated":"2021-08-09T12:49:17.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8u0013c376cghy6zo4","content":"<p>貌似大巴黎把8月10号也就是明天的埃菲尔铁塔的包下来了，签约梅西应该十拿九稳了。</p>\n<p>梅西+姆巴佩+内马尔+迪马利亚，这波是宇宙飞船</p>\n<p>谢希科的论文才写了一半，公司的业务挣扎中，</p>\n<p>今天先写完词典管理吧</p>\n<p>有nativeQuery = true时，是可以执行原生sql语句，所谓原生sql，也就是说这段sql拷贝到数据库中，然后把参数值给一下就能运行了</p>\n<p>热搜统计：</p>\n<p>说明</p>\n<p>1、默认统计各个频道下最近一个月相关搜索标的的排名和搜索量,推荐开关默认都是开启的</p>\n<p>2、关闭推荐按钮，则此标的不会被推荐到热搜栏位</p>\n<p>3、标的可能存在同名的，可以通过ID区分</p>\n<p>4、再推荐到H5的热搜栏位时，如果热搜配置中，经配置了重名的标的，则取热搜统计中后一位的标的名称</p>\n<p>5、如果所有的热搜标的都关闭了推荐，<strong>则只显示热搜配置里面配置的标的</strong>，如果热搜配置里面也没有配置，则整个H5上整个热搜板块都不显示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Modifying</span></span><br><span class=\"line\">    <span class=\"meta\">@Query(value = &quot;update search_config_hot set status = 0 where level = ?1 and type = ?2 and status = 1&quot;, nativeQuery = true)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateByLevelAndType</span><span class=\"params\">(Integer level, String type)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>level=?1 相当于把sql的第一个参数传入后面的update函数</p>\n<p>反射不支持基本类型</p>\n<p>JpaRepository 接口的三个父接口中，CrudRepository 接口定义了最基本的 CRUD 方法；</p>\n<p>PagingAndSortingRepository 接口定义了分页和排序要用到的方法； </p>\n<p>QueryByExampleExecutor 接口定义的是按实例进行查询的方法。</p>\n<p>（2）JpaSpecificationExecutor 接口：自定义查询的接口<br>比如模糊查询、表关联查询等都通过它来完成，业务接口 CfgPhysicalDbRepository 同样实现了它，我们在代码中调用的 findAll(Specification<T> spec, Pageable pageable) 方法就是由它定义的。</p>\n<p>（3）SimpleJpaRepository 类：常用 CRUD 方法的真正实现类</p>\n<p>当业务接口 CfgPhysicalDbRepository 调用 JpaRepository 接口中的 CRUD 方法，或者 JpaSpecificationExecutor 接口中的 findAll 方法时，</p>\n<p>应该有一个业务实现类 CfgPhysicalDbRepositoryImpl 来实现这些方法，</p>\n<p>所以我们可以在同一个包下定义一个实现类 CfgPhysicalDbRepositoryImpl 来重写这些方法。</p>\n<p>但是我们很少看见有人这样写，这样写就是和普通的 Dao、DaoImpl 没有两样了。 </p>\n<p>JPA 有它自己的玩法，这些常用的方法， JPA 都通过接口定义好并且在 SimpleJpaRepository 中替你一一实现了，</p>\n<p>所以说当代码执行找不到 CfgPhysicalDbRepositoryImpl 的时候，就会一直向下找，</p>\n<p>最终找到 SimpleJpaRepository 中的实现方法为止，此处是一个委派模式。</p>\n<p>2、详解 SimpleJpaRepository 的 findAll(Specification<T> spec, Pageable pageable) 方法</p>\n<p>（1）JPA的复杂查询都必须经历四个步骤：</p>\n<p>1、获取 builder =&gt; CriteriaBuilder builder = em.getCriteriaBuilder();<br>2、获取 Query =&gt;CriteriaQuery<Student> query = builder.createQuery(CfgPhysicalDb.class);<br>3、在 Query 中构造查询条件 =&gt; Predicate predicate = spec.toPredicate(root, query, builder);<br>4、执行查询 =&gt; query.getResultList()</p>\n<p>我们只需要在方法的参数中直接定义一个pageable类型的参数，当Spring发现这个参数时，Spring会自动的根据request的参数来组装该pageable对象</p>\n<p>Spring支持的request参数如下：</p>\n<p>page，第几页，从0开始，默认为第0页<br>size，每一页的大小，默认为20<br>sort，排序相关的信息，例如sort=firstname&amp;sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rollbackFor = Exception.class</span><br></pre></td></tr></table></figure>\n\n<p>一个注解@Transactional(rollbackFor = Exception.class)，今天就和大家分享一下，这个注解的用法；</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>如下图所示，我们都知道Exception分为运行时异常RuntimeException和非运行时异常</p>\n<p>error是一定会回滚的</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtaizcnc5jj30fj0elaar.jpg\"></p>\n<p>如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。</p>\n<p>如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，<strong>正常的处理应该是把异常数据舍弃，然后记录日志。</strong>不应该由于异常数据而影响下面对正常数据的处理。</p>\n<p>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</p>\n<h3 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h3><p>当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>\n<p>在项目中，@Transactional(rollbackFor=Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>\n<p>在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚</p>\n<p>数据库如果不是从1自增，可以把表内数据都删了。</p>\n<p>本地测试没问题，前端那边测试有问题肯定要么事仓库代码没更新，要么是部署没更新。</p>\n<p>改数据，请求能成功，但是数据库没反应，是sql语句的表名复制粘贴没改过来</p>\n","site":{"data":{}},"excerpt":"","more":"<p>貌似大巴黎把8月10号也就是明天的埃菲尔铁塔的包下来了，签约梅西应该十拿九稳了。</p>\n<p>梅西+姆巴佩+内马尔+迪马利亚，这波是宇宙飞船</p>\n<p>谢希科的论文才写了一半，公司的业务挣扎中，</p>\n<p>今天先写完词典管理吧</p>\n<p>有nativeQuery = true时，是可以执行原生sql语句，所谓原生sql，也就是说这段sql拷贝到数据库中，然后把参数值给一下就能运行了</p>\n<p>热搜统计：</p>\n<p>说明</p>\n<p>1、默认统计各个频道下最近一个月相关搜索标的的排名和搜索量,推荐开关默认都是开启的</p>\n<p>2、关闭推荐按钮，则此标的不会被推荐到热搜栏位</p>\n<p>3、标的可能存在同名的，可以通过ID区分</p>\n<p>4、再推荐到H5的热搜栏位时，如果热搜配置中，经配置了重名的标的，则取热搜统计中后一位的标的名称</p>\n<p>5、如果所有的热搜标的都关闭了推荐，<strong>则只显示热搜配置里面配置的标的</strong>，如果热搜配置里面也没有配置，则整个H5上整个热搜板块都不显示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Modifying</span></span><br><span class=\"line\">    <span class=\"meta\">@Query(value = &quot;update search_config_hot set status = 0 where level = ?1 and type = ?2 and status = 1&quot;, nativeQuery = true)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateByLevelAndType</span><span class=\"params\">(Integer level, String type)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>level=?1 相当于把sql的第一个参数传入后面的update函数</p>\n<p>反射不支持基本类型</p>\n<p>JpaRepository 接口的三个父接口中，CrudRepository 接口定义了最基本的 CRUD 方法；</p>\n<p>PagingAndSortingRepository 接口定义了分页和排序要用到的方法； </p>\n<p>QueryByExampleExecutor 接口定义的是按实例进行查询的方法。</p>\n<p>（2）JpaSpecificationExecutor 接口：自定义查询的接口<br>比如模糊查询、表关联查询等都通过它来完成，业务接口 CfgPhysicalDbRepository 同样实现了它，我们在代码中调用的 findAll(Specification<T> spec, Pageable pageable) 方法就是由它定义的。</p>\n<p>（3）SimpleJpaRepository 类：常用 CRUD 方法的真正实现类</p>\n<p>当业务接口 CfgPhysicalDbRepository 调用 JpaRepository 接口中的 CRUD 方法，或者 JpaSpecificationExecutor 接口中的 findAll 方法时，</p>\n<p>应该有一个业务实现类 CfgPhysicalDbRepositoryImpl 来实现这些方法，</p>\n<p>所以我们可以在同一个包下定义一个实现类 CfgPhysicalDbRepositoryImpl 来重写这些方法。</p>\n<p>但是我们很少看见有人这样写，这样写就是和普通的 Dao、DaoImpl 没有两样了。 </p>\n<p>JPA 有它自己的玩法，这些常用的方法， JPA 都通过接口定义好并且在 SimpleJpaRepository 中替你一一实现了，</p>\n<p>所以说当代码执行找不到 CfgPhysicalDbRepositoryImpl 的时候，就会一直向下找，</p>\n<p>最终找到 SimpleJpaRepository 中的实现方法为止，此处是一个委派模式。</p>\n<p>2、详解 SimpleJpaRepository 的 findAll(Specification<T> spec, Pageable pageable) 方法</p>\n<p>（1）JPA的复杂查询都必须经历四个步骤：</p>\n<p>1、获取 builder =&gt; CriteriaBuilder builder = em.getCriteriaBuilder();<br>2、获取 Query =&gt;CriteriaQuery<Student> query = builder.createQuery(CfgPhysicalDb.class);<br>3、在 Query 中构造查询条件 =&gt; Predicate predicate = spec.toPredicate(root, query, builder);<br>4、执行查询 =&gt; query.getResultList()</p>\n<p>我们只需要在方法的参数中直接定义一个pageable类型的参数，当Spring发现这个参数时，Spring会自动的根据request的参数来组装该pageable对象</p>\n<p>Spring支持的request参数如下：</p>\n<p>page，第几页，从0开始，默认为第0页<br>size，每一页的大小，默认为20<br>sort，排序相关的信息，例如sort=firstname&amp;sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rollbackFor = Exception.class</span><br></pre></td></tr></table></figure>\n\n<p>一个注解@Transactional(rollbackFor = Exception.class)，今天就和大家分享一下，这个注解的用法；</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>如下图所示，我们都知道Exception分为运行时异常RuntimeException和非运行时异常</p>\n<p>error是一定会回滚的</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtaizcnc5jj30fj0elaar.jpg\"></p>\n<p>如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。</p>\n<p>如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，<strong>正常的处理应该是把异常数据舍弃，然后记录日志。</strong>不应该由于异常数据而影响下面对正常数据的处理。</p>\n<p>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</p>\n<h3 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h3><p>当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>\n<p>在项目中，@Transactional(rollbackFor=Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>\n<p>在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚</p>\n<p>数据库如果不是从1自增，可以把表内数据都删了。</p>\n<p>本地测试没问题，前端那边测试有问题肯定要么事仓库代码没更新，要么是部署没更新。</p>\n<p>改数据，请求能成功，但是数据库没反应，是sql语句的表名复制粘贴没改过来</p>\n"},{"title":"周末的上海-前置摄像头给自己理个发","date":"2021-08-01T03:06:58.000Z","type":"个人生活","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt14d2z4q0j31900u0tb5.jpg","_content":"以下内容隐藏\n\n[comment]: <> (我强烈支持理发店的tony老师应该先考个证才能上岗，一点审美都没有。)\n\n[comment]: <> (去年也就是2020年我留的是板寸，已经快忘记自己寸头的样子了。那时候刚研一，脸圆圆的，顶着个寸头见新同学哈哈哈哈，)\n\n[comment]: <> (后来今年也见是21张龙问我，怎么你头发这么多了，班级轰趴的时候还一起合影了哈哈哈。。我说不是头发多，是我头发长长了，)\n\n[comment]: <> (我比较喜欢这种风格的发型，)\n\n[comment]: <> (由于本人不是很好看，所以照片是不可能放在朋友圈的，影响圈容圈貌哈哈哈)\n\n[comment]: <> (![]&#40;https://tva1.sinaimg.cn/large/008i3skNgy1gt13x56y2sj30xg0u00wj.jpg&#41;)\n\n\n\n[comment]: <> (、镜子不好操作，用Mac还行)\n\n[comment]: <> (现在实习公司里都是男的多，有时候还是没注意自己的形象，)\n\n[comment]: <> (单身久了，有时候确实顾不上，长得不算好看的人，不积极努力去寻找能接受这样的自己的人，是不可能摆脱单身的，尤其是男的23333)\n\n[comment]: <> (不过我这个人有个好处是，不知道为啥我很喜欢自己的样子，而有一些长得很好看的男的，还是经常对自己长相不满意，我觉得duck不必了)\n\n[comment]: <> (![]&#40;https://tva1.sinaimg.cn/large/008i3skNgy1gt13ywrnfcj30xg0u0dk0.jpg&#41;)\n\n\n\n\n\n[comment]: <> (大功告成)\n\n\n\n[comment]: <> (![]&#40;https://tva1.sinaimg.cn/large/008i3skNgy1gt13xa92ulj30xg0u078a.jpg&#41;)\n\n\n\n[comment]: <> (去公司应该头发不会翘起一小撮了)\n\n","source":"_posts/周末的上海.md","raw":"---\ntitle: 周末的上海-前置摄像头给自己理个发\ndate: 2021-08-01 11:06:58\ntype: \"个人生活\"\ncategories: \n- 个人生活\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt14d2z4q0j31900u0tb5.jpg\n---\n以下内容隐藏\n\n[comment]: <> (我强烈支持理发店的tony老师应该先考个证才能上岗，一点审美都没有。)\n\n[comment]: <> (去年也就是2020年我留的是板寸，已经快忘记自己寸头的样子了。那时候刚研一，脸圆圆的，顶着个寸头见新同学哈哈哈哈，)\n\n[comment]: <> (后来今年也见是21张龙问我，怎么你头发这么多了，班级轰趴的时候还一起合影了哈哈哈。。我说不是头发多，是我头发长长了，)\n\n[comment]: <> (我比较喜欢这种风格的发型，)\n\n[comment]: <> (由于本人不是很好看，所以照片是不可能放在朋友圈的，影响圈容圈貌哈哈哈)\n\n[comment]: <> (![]&#40;https://tva1.sinaimg.cn/large/008i3skNgy1gt13x56y2sj30xg0u00wj.jpg&#41;)\n\n\n\n[comment]: <> (、镜子不好操作，用Mac还行)\n\n[comment]: <> (现在实习公司里都是男的多，有时候还是没注意自己的形象，)\n\n[comment]: <> (单身久了，有时候确实顾不上，长得不算好看的人，不积极努力去寻找能接受这样的自己的人，是不可能摆脱单身的，尤其是男的23333)\n\n[comment]: <> (不过我这个人有个好处是，不知道为啥我很喜欢自己的样子，而有一些长得很好看的男的，还是经常对自己长相不满意，我觉得duck不必了)\n\n[comment]: <> (![]&#40;https://tva1.sinaimg.cn/large/008i3skNgy1gt13ywrnfcj30xg0u0dk0.jpg&#41;)\n\n\n\n\n\n[comment]: <> (大功告成)\n\n\n\n[comment]: <> (![]&#40;https://tva1.sinaimg.cn/large/008i3skNgy1gt13xa92ulj30xg0u078a.jpg&#41;)\n\n\n\n[comment]: <> (去公司应该头发不会翘起一小撮了)\n\n","slug":"周末的上海","published":1,"updated":"2021-08-03T01:30:48.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8v0016c3767s3se0hu","content":"<p>以下内容隐藏</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以下内容隐藏</p>\n"},{"title":"盘点我从无到有搭建一个Springboot遇到的坑","date":"2021-07-31T08:46:33.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt0a709vq7j318z0u043r.jpg","_content":"\n\n\n以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg)\n\n\n\npost模拟写入请求：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg)\n\n\n\n## 坑盘点\n\n### 整个流程不清楚\n\n写代码就没有办法有清晰的思路，例如本次请求： http://localhost:8080/user/add\n\n### URL\n\n传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg)\n\n\n\n之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，\n\n http://localhost:8080+/ 之后，是找到了项目开始的地方，\n\n### controller\n\n去controller匹配我后面的路径\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg)\n\n\n\nhttp://localhost:8080/user/add 分发到了adduserRestful方法，这个方法需要调用服务层，\n\n### service\n\n即\n\nuserService.addUer(user)\n\n这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg)\n\n这里逐一解释那些注解，\n\n- @Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个**表在数据库中**是可以一一映射的。\n- @Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字\n- Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错\n- GeneratedValue是主键自增，括号内自增的方式也是必不可少，**如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配**！否则报错。\n- @Column就是类属性和数据库中字段相匹配，name即是数据库中的名字\n- @Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增\n\n请求体中提交的json：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg)\n\njson本质上是一个字符串，变成现成的类对象给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n需要解析出来，\n\n### domain\n\n这个过程是由user类的注解协助完成的\n\n再返回给addUserRestful，然后调用service，\n\n![image-20210731171750135](/Users/wuzhenren/myblog/source/_posts/盘点我从无到有搭建一个Springboot遇到的坑.assets/image-20210731171750135.png)\n\n\n\n@Service注解是告知，服务层在这里，\n\n 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：\n\n```xml\n<!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 -->\n<context:component-scan base-package=\"com.study.persistent\" />\n```\n\n在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，\n\n如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，\n\n类似的还包括@Component、@Repository、@Controller。\n\n```java\n@Service(\"courseDAO\")\n@Scope(\"prototype\")\npublic class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO{\n......\n}\n```\n\n 其作用就相当于在applicationContext.xml配置文件里配置如下信息：\n\n```xml\n<bean id=\"courseDAO\"\n      class=\"com.study.persistent.CourseDAOImpl\" scope=\"prototype\">\n      ......    \n</bean>\n```\n\n如果Service括号的参数不写的话，默认是跟类名字是一样的，\n\n```java\n@Service\n\npublic class UserServiceimpl implements UserService {\n```\n\n\n\n写了的话，相当于给这个类起了个别名，\n\n### 交给controlled->service\n\njson解析完成后，返回给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n\n\nservice层的方法\n\n```java\n@Override\n    @Transactional(rollbackFor = Exception.class)\n    public void addUser(User user) {\n        userApiRepository.save(user);\n    }\n```\n\n### 写入数据库\n\nuserApiRepository是继承了JPA的方法的，有save方法。\n\n```java\npublic interface UserApiRepository extends JpaRepository<User,Integer>, JpaSpecificationExecutor<User> {\n}\n```\n\n通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa\n\n最终这条记录在数据库中躺着\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg)\n\n\n\n","source":"_posts/盘点我从无到有搭建一个Springboot遇到的坑.md","raw":"---\ntitle: 盘点我从无到有搭建一个Springboot遇到的坑\ndate: 2021-07-31 16:46:33\ncategories: \n- Spring Boot\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt0a709vq7j318z0u043r.jpg\n---\n\n\n\n以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg)\n\n\n\npost模拟写入请求：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg)\n\n\n\n## 坑盘点\n\n### 整个流程不清楚\n\n写代码就没有办法有清晰的思路，例如本次请求： http://localhost:8080/user/add\n\n### URL\n\n传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg)\n\n\n\n之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，\n\n http://localhost:8080+/ 之后，是找到了项目开始的地方，\n\n### controller\n\n去controller匹配我后面的路径\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg)\n\n\n\nhttp://localhost:8080/user/add 分发到了adduserRestful方法，这个方法需要调用服务层，\n\n### service\n\n即\n\nuserService.addUer(user)\n\n这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg)\n\n这里逐一解释那些注解，\n\n- @Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个**表在数据库中**是可以一一映射的。\n- @Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字\n- Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错\n- GeneratedValue是主键自增，括号内自增的方式也是必不可少，**如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配**！否则报错。\n- @Column就是类属性和数据库中字段相匹配，name即是数据库中的名字\n- @Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增\n\n请求体中提交的json：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg)\n\njson本质上是一个字符串，变成现成的类对象给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n需要解析出来，\n\n### domain\n\n这个过程是由user类的注解协助完成的\n\n再返回给addUserRestful，然后调用service，\n\n![image-20210731171750135](/Users/wuzhenren/myblog/source/_posts/盘点我从无到有搭建一个Springboot遇到的坑.assets/image-20210731171750135.png)\n\n\n\n@Service注解是告知，服务层在这里，\n\n 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：\n\n```xml\n<!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 -->\n<context:component-scan base-package=\"com.study.persistent\" />\n```\n\n在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，\n\n如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，\n\n类似的还包括@Component、@Repository、@Controller。\n\n```java\n@Service(\"courseDAO\")\n@Scope(\"prototype\")\npublic class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO{\n......\n}\n```\n\n 其作用就相当于在applicationContext.xml配置文件里配置如下信息：\n\n```xml\n<bean id=\"courseDAO\"\n      class=\"com.study.persistent.CourseDAOImpl\" scope=\"prototype\">\n      ......    \n</bean>\n```\n\n如果Service括号的参数不写的话，默认是跟类名字是一样的，\n\n```java\n@Service\n\npublic class UserServiceimpl implements UserService {\n```\n\n\n\n写了的话，相当于给这个类起了个别名，\n\n### 交给controlled->service\n\njson解析完成后，返回给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n\n\nservice层的方法\n\n```java\n@Override\n    @Transactional(rollbackFor = Exception.class)\n    public void addUser(User user) {\n        userApiRepository.save(user);\n    }\n```\n\n### 写入数据库\n\nuserApiRepository是继承了JPA的方法的，有save方法。\n\n```java\npublic interface UserApiRepository extends JpaRepository<User,Integer>, JpaSpecificationExecutor<User> {\n}\n```\n\n通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa\n\n最终这条记录在数据库中躺着\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg)\n\n\n\n","slug":"盘点我从无到有搭建一个Springboot遇到的坑","published":1,"updated":"2021-08-08T10:02:22.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo8x0018c376haj31x4q","content":"<p>以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg\"></p>\n<p>post模拟写入请求：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg\"></p>\n<h2 id=\"坑盘点\"><a href=\"#坑盘点\" class=\"headerlink\" title=\"坑盘点\"></a>坑盘点</h2><h3 id=\"整个流程不清楚\"><a href=\"#整个流程不清楚\" class=\"headerlink\" title=\"整个流程不清楚\"></a>整个流程不清楚</h3><p>写代码就没有办法有清晰的思路，例如本次请求： <a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a></p>\n<h3 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h3><p>传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg\"></p>\n<p>之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，</p>\n<p> <a href=\"http://localhost:8080+/\">http://localhost:8080+/</a> 之后，是找到了项目开始的地方，</p>\n<h3 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h3><p>去controller匹配我后面的路径</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg\"></p>\n<p><a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a> 分发到了adduserRestful方法，这个方法需要调用服务层，</p>\n<h3 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h3><p>即</p>\n<p>userService.addUer(user)</p>\n<p>这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg\"></p>\n<p>这里逐一解释那些注解，</p>\n<ul>\n<li>@Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个<strong>表在数据库中</strong>是可以一一映射的。</li>\n<li>@Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字</li>\n<li>Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错</li>\n<li>GeneratedValue是主键自增，括号内自增的方式也是必不可少，<strong>如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配</strong>！否则报错。</li>\n<li>@Column就是类属性和数据库中字段相匹配，name即是数据库中的名字</li>\n<li>@Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增</li>\n</ul>\n<p>请求体中提交的json：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg\"></p>\n<p>json本质上是一个字符串，变成现成的类对象给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要解析出来，</p>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>这个过程是由user类的注解协助完成的</p>\n<p>再返回给addUserRestful，然后调用service，</p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E7%9B%98%E7%82%B9%E6%88%91%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AASpringboot%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.assets/image-20210731171750135.png\" alt=\"image-20210731171750135\"></p>\n<p>@Service注解是告知，服务层在这里，</p>\n<p> 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.study.persistent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，</p>\n<p>如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，</p>\n<p>类似的还包括@Component、@Repository、@Controller。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service(&quot;courseDAO&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CourseDAOImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">CourseDAO</span></span>&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 其作用就相当于在applicationContext.xml配置文件里配置如下信息：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;courseDAO&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.persistent.CourseDAOImpl&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;prototype&quot;</span>&gt;</span></span><br><span class=\"line\">      ......    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果Service括号的参数不写的话，默认是跟类名字是一样的，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceimpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>写了的话，相当于给这个类起了个别名，</p>\n<h3 id=\"交给controlled-gt-service\"><a href=\"#交给controlled-gt-service\" class=\"headerlink\" title=\"交给controlled-&gt;service\"></a>交给controlled-&gt;service</h3><p>json解析完成后，返回给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>service层的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        userApiRepository.save(user);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写入数据库\"><a href=\"#写入数据库\" class=\"headerlink\" title=\"写入数据库\"></a>写入数据库</h3><p>userApiRepository是继承了JPA的方法的，有save方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserApiRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>,<span class=\"title\">Integer</span>&gt;, <span class=\"title\">JpaSpecificationExecutor</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa</p>\n<p>最终这条记录在数据库中躺着</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg\"></p>\n<p>post模拟写入请求：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg\"></p>\n<h2 id=\"坑盘点\"><a href=\"#坑盘点\" class=\"headerlink\" title=\"坑盘点\"></a>坑盘点</h2><h3 id=\"整个流程不清楚\"><a href=\"#整个流程不清楚\" class=\"headerlink\" title=\"整个流程不清楚\"></a>整个流程不清楚</h3><p>写代码就没有办法有清晰的思路，例如本次请求： <a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a></p>\n<h3 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h3><p>传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg\"></p>\n<p>之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，</p>\n<p> <a href=\"http://localhost:8080+/\">http://localhost:8080+/</a> 之后，是找到了项目开始的地方，</p>\n<h3 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h3><p>去controller匹配我后面的路径</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg\"></p>\n<p><a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a> 分发到了adduserRestful方法，这个方法需要调用服务层，</p>\n<h3 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h3><p>即</p>\n<p>userService.addUer(user)</p>\n<p>这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg\"></p>\n<p>这里逐一解释那些注解，</p>\n<ul>\n<li>@Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个<strong>表在数据库中</strong>是可以一一映射的。</li>\n<li>@Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字</li>\n<li>Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错</li>\n<li>GeneratedValue是主键自增，括号内自增的方式也是必不可少，<strong>如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配</strong>！否则报错。</li>\n<li>@Column就是类属性和数据库中字段相匹配，name即是数据库中的名字</li>\n<li>@Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增</li>\n</ul>\n<p>请求体中提交的json：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg\"></p>\n<p>json本质上是一个字符串，变成现成的类对象给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要解析出来，</p>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>这个过程是由user类的注解协助完成的</p>\n<p>再返回给addUserRestful，然后调用service，</p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E7%9B%98%E7%82%B9%E6%88%91%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AASpringboot%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.assets/image-20210731171750135.png\" alt=\"image-20210731171750135\"></p>\n<p>@Service注解是告知，服务层在这里，</p>\n<p> 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.study.persistent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，</p>\n<p>如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，</p>\n<p>类似的还包括@Component、@Repository、@Controller。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service(&quot;courseDAO&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CourseDAOImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">CourseDAO</span></span>&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 其作用就相当于在applicationContext.xml配置文件里配置如下信息：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;courseDAO&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.persistent.CourseDAOImpl&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;prototype&quot;</span>&gt;</span></span><br><span class=\"line\">      ......    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果Service括号的参数不写的话，默认是跟类名字是一样的，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceimpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>写了的话，相当于给这个类起了个别名，</p>\n<h3 id=\"交给controlled-gt-service\"><a href=\"#交给controlled-gt-service\" class=\"headerlink\" title=\"交给controlled-&gt;service\"></a>交给controlled-&gt;service</h3><p>json解析完成后，返回给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>service层的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        userApiRepository.save(user);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写入数据库\"><a href=\"#写入数据库\" class=\"headerlink\" title=\"写入数据库\"></a>写入数据库</h3><p>userApiRepository是继承了JPA的方法的，有save方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserApiRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>,<span class=\"title\">Integer</span>&gt;, <span class=\"title\">JpaSpecificationExecutor</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa</p>\n<p>最终这条记录在数据库中躺着</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg\"></p>\n"},{"title":"谢希科老师数据库前沿课的论文pre","date":"2021-07-31T10:40:08.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/website-programming-code-free-photo-2210x1473.jpg","_content":"之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好\n\n## pre要求\n全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。\n\n要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。\n\nppt的讲诉，不能太长，要突出重点，\n\n讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。\n\n## 论文选题\n相比研究之前的skyline，我更希望看点对我有用的东西，\n\n所以我准备选取数据库方向的文章。\n\nSPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020\n\n离谱，wps新版的划词翻译的地方还不好找，\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg)\n\n如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。\n\n短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法\n复杂OLAP查询的快速n元连接查询处理方法\n\n<<<<<<< HEAD\n=======\n##### 超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键\n\n##### 候选键(candidate key):不含有多余属性的超键称为候选键\n\n##### 主键(primary key):用户选作元组标识的一个候选键程序主键\n\n**外键 (FK)** 是用于建立和加强两个表数据之间的链接的**一列**或**多列**\n\n通过将保存表中主键值的一列或多列添加到另一个表中，可创建两个表之间的链接。这个列就成为第二个表的外键。\n\n**一张表外键的值一般来说是另一张表主键的值。因此，外键的存在使得表与表之间可以联系起来**\n\nFOREIGN KEY 约束防止这种情况的发生。如果主键表中数据的更改使之与外键表中数据的链接失效，则这种更改是不能实现的，从而确保了引用完整性。如果试图删除主键表中的行或更改主键值，而该主键值与另一个表的 FOREIGN KEY 约束值相关，则该操作不可实现。若要成功更改或删除FOREIGN KEY 约束的行，可以先在外键表中删除外键数据或更改外键数据，然后将外键链接到不同的主键数据上去。\n\n**OLAP**联机分析处理是一种软件技术，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。\n\n随着市场竞争的日趋激烈，企业更加强调决策的及时性和准确性，这使得以**支持决策管理分析**为主要目的的应用迅速崛起，这类应用被称为**联机分析处理**，它所存储的数据被称为信息数据。\n\n数据仓库：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），**支持复杂的分析操作，侧重决策支持，并且提供直观易懂**的查询结果。\n\n基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。\n\n- 电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。\n- 第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成**多台服务器**和多个业务数据库（**量大+分库分表**），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。\n- 第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到**非常精细化**和**具体的用户的集群分析**，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。\n\n这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：\n\n1. 业务数据库中的数据结构是**为了完成交易而设计**的，不是为了而查询和分析的便利设计的。\n2. 业务数据库大多是**读写优化的**，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。\n\n而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：\n\n1. 数据结构为了分析和查询的便利；\n2. 只读优化的数据库，即**不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。**\n\n数据库 比较流行的有：MySQL, Oracle, SqlServer等\n\n数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等\n\n**本OLAP查询**，基于成本模型 生成包含 **n 元连接运算符**的 查询计划。\n\n**+：a+b所以‘+’就是二元运算符。\n++：a++所以++就是一元运算符。**\n\nn元就是n个元素，n个表做连接运算\n\n### 本文结论：SPRINTER 的性能优于最先进的 OLAP 系统。\n\nkeywords: n元连接运算符，查询规划，查询优化，FK-FK连接，复杂OLAP查询处理，协同处理\n\n现有系统利用了各种技术，例如中间结果的流水线\n\nOLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学\n\nIn particular, the number of queries which\n\ncontain join operations between a pair of foreign (or non\u0002\n\nunique) keys rather than a conventional pair of primary and\n\nforeign keys increases in the applications. \n\n!尤其是，查询的数量**包括了外键之间的连接操作**，而不是增加在应用程序的**传统主键和外键**\n\n本文将这种连接操作表示为FK-FK连接，一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。\n\n**流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。**\n\n!它可能对PK-FK连接的查询有效，但对于**事实表中包含FK-FK连接的复杂查询**可能无效\n\n**内连接**实际上就是利用 **where 子句**对两张(多表)表形成的笛卡尔积进行筛选,**我们前面学习的查询都是内连接,也是在开发过程中用的最多的连接查询。**\n\n**外连接，如果是全外连接，左*右含有的行** \n\n数据库视图：\n\n视图是一种**虚拟**的表（逻辑表），具有和**物理表**相同的功能。\n可以对视图进行**增，改，查**，操作，\n试图通常是有**一个表或者多个表的行或列的子集**。\n对视图的修改**不影响**基本表。\n它使得我们获取数据**更容易**，相比多表查询\n\n视图是一个虚拟表，**其查询的数据来自于视图定义时的 as select xx 查询语句**。视图的列来自于一个表或多个表，所以视图不可以和表名重名。\n数据多用作查询，一般不会通过视图去修改数据。\n\n\n\n**!因为存在以下两个问题：**许多key比较 以及大量的内存使用量。\n\n首先，探测关系中每个元组的连接键值需要与哈希表中的**所有重复键值相匹配**。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。\n\nn元连接操作和二元连接操作相比，可以减少中间结果数量，大多数情况下更有效，\n\n**多路连接处理**(归并？）已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 ，**因为在内存内的处理环境中，哈希连接通常优于归并排序连接**，并且不同于OLAY图形模式查询，OLAY查询是ad-hoc(点对点)和acyclic(无环)；\n\n!我们提出了一种方法，可以生成n元连接的查询，而不是传统的二元操作，\n\n生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，相比较二元 搜索空间变得更大，\n\n我们**提出了所使用的成本模型**和一种**查询优化方法 t**允许查询规划方法\n\n\n\n!实际应用环境很少 出现简单的二元连接,而**更多的是复杂的多元连接**(multi-mays join)\n\nn 元连接可以以多种方式分解成 n−1 个二 元连接，每二元连接又可以采用多种算法,因此存在大量执行计划。\n\n!算法代价以 I/O 为主,**CPU 因等待 I/O 而空闲**,因此,优化连接 **性能最有效的方法是减少 I/O 操作**\n\n\n\n**等值连接**与**自然连接**是应用最广泛的连接操作,自然连接与等值连接无本质区别,可以通过修改属性名把 等值连接操作转化为自然连接操作,所以研究自然连接具有普遍意义.本节以自然连接(ڇ(为例,设 R 和 S 是两个 数据集,attr(⋅)表示数据集的属性集\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtaut6tcsnj31160nuadm.jpg)\n\n\n\n### 与等值连接的区别\n\n\\1. 等值连接中不要求属性值完全相同，而自然连接要求两个关系中进行比较的必须是相同的属性组（属性名可以不同），即要求必须有相同的值域。\n\n\\2. 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接（如图所示）\n\n\n\n!由于连接运算结果是确定的,因此无论采用何种顺序执行多元连接,**结果集大小是一致的**.因此,我们需找 到这些执行计划中 **I/O 代价最小的作为最优执行计划.**\n\n\n\n较直接的算法为逐一计算每个执行计划的 I/O 代价,搜索 I/O 代价最小的执行计划\n\n\n\n首先,对于任意一个执行计划,需要逐一计算 SiڇSj 的结果集大小Φij 和 6 种算法的 I/O代价,选取 I/O 代价最小的算法作为 SiڇSj 的执行算法.那么对于一个 n 元连接的执行计划选择,至少要计算![](https://tva1.sinaimg.cn/large/008i3skNgy1gtauvy654lj308002cdfq.jpg)\n\n次连接代价。并在这么多代价里面搜索最小代价。\n\n\n\n只有在与传统的二进制左深连接树相比**有益时**才生成n-ary连接树\n\n\n\n保证 多作业的并行性同时会降低每个作业的并行性,多作业并行并没有带来额外的性能提升\n\n若 I/O 密集型和 CPU 密集型作业并行执行,则有助于提高资源利用率,提高性能\n\n若多个 I/O 密集型作业并行执行,每个作业需要 的资源不能互补,而且会争抢 I/O 资源\n\n\n\nFK总是和PK相连接\n当两个表中间有了PK-FK连接，那么这两个表就有了关系\n\n\n\n单向连接啥基于最坏情况最优连接算法， the worst\u0002 case optimal join algorithm，\n\nwe have demonstrated that SPRINTER significantly outperforms the state-of-the-art OLAP query processing systems in terms of both processing speed and data size that can be **processed without our of memory**.\n\n我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以在内存不溢出的情况下处理\n\n本文贡献如下：\n\n- 我们提出了一种查询方法，可以生成复杂的OLAY查询的n元连接树包含FK-FK\n- 我们提出了成本模型和查询优化n路连接树的方法\n- n元n路处理方法：基于最坏情况最优连接算法\n- 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。\n- 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。\n\n\n\n### 2.2 sprinter 中使用最坏情况下最优连接算法\n\n当n-ary连接操作符的输入大小非常大时，使用**GPU进行排序**可以进一步提高查询性能。因此，SPRINTER使用不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。\n\n!**表1中基于比较的算法**意味着，它们需要在排序的key值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n。它们不需要这样的比较来进行排序（例如，radix排序。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.logN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。\n\n\n\n**在那个case，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。**\n\nwe assume that *X* is too large to fit in GPU memory, and so, we need to split it into six subar\u0002 rays {*X*1, · · · ,*X*6}. \n\n虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。\n\n异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本。 y尽可能通过重叠**三种低级GPU操作**，**H2D拷贝**、**radix排序**和**D2H拷贝**。\n\n两两合并成一个新的这下一个x2   **在x1排序的时候对x2进行排序**\n\n![image-20210805223429708](/Users/wuzhenren/myblog/source/_posts/谢希科老师数据库前沿课的论文pre.assets/image-20210805223429708.png)\n\n\n\n#### 最坏情况最优连接算法\n\n通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询），一些算法[1,31,44]**需要对输入关系和存储进行预处理，预处理作为数据结构的结果，如B+-tree，**\n\n![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)\n\n当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二分查找，因此，单个搜索的成本是O(logN),如果一个查询有L个连接变量，**则可能的全局变量顺序的数量为L！，排列组合**。 虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于**每个变量顺序的搜索成本不同**IO成本，可能远非最优。因此，**TJ估计每个可能顺序的连接处理成本**（这就是TJ），并选择最好的顺序。\n\n### 3 一个激励例子\n\n在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS(?)基准数据库[30]上的一个查询，**广泛用于t 测试OLAP系统[18]的查询性能**。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点**关注连接**操作。图3显示了的连接图 该查询包含蓝色矩形的**三个事实表{SS、SR、CS}** （事实表，记录具体事件，如用户交易流水表）和绿色矩形的**三维表{D、I、C}**。（每个维度可能包含多个属性 比如时间维度看有插入时间 更新时间）为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有**2个FK-FK连接**操作，**绿线有5个PK-FK连接**操作。 外键连接越少越好？\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg)\n\n\n\n\n\n\n\n\n\n\n\n图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。 \n\n系统-x是一个功能齐全的最先进的商业化的**内存数据库系统**,支持**索引驱动**的查询执行和查询优化技术，如bloom过滤器和自适应连接。\n\n在图4(a)中，它为查询计划生成一个**左深连接树**相当于从左到右顺序结合，并以操作员一次**操作的方式**执行该计划。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n\n\n**C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。**【？】\n\n2.23B就是22.3亿\n\n图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数\n\n因为连接操作是FK-FK连接，并且在哈希表中有许多**重复的键值**，所以num 在**探测连接**过程中，哈希表中的key值被访问，我们称之为**探测成本**，这是探测成本，特别是160.9B倍。\n\nOmniSci[33]是一个开源的**协同处理数据库系统**，其中协同处理意味着**同时**利用**cpu**和**gpu**进行查询处理。\n\n如图b,它生成了一个左深连接的查询计划和a一样。\n\n但是是以**非阻塞**和**流水线的方式**执行计划，它**不会生成和存储**要连接的**中间结果**。\n\n详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。\n\n图b中SS和SR的第一个连接 ，**对SS的每一个元祖依次探测SR的29M元祖，即暴力遍历**、，哪个探测成本变成了4.1亿美元。\n\n然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B.\n\n我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.\n\nSPRINTER是系统原型，即我们提出的一种集成了跨所有相关层和模块无缝集成到OmniSci中的方法。\n\n我们选择OmniSci作为SPRINTER的基础系统，因为它是最先进的开源现代数据库系统\n\n虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。\n\n如图c，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。\n\n它分别执行三个连接子树，\n\n- S1={SS、C1、D， I}\n- S2={SR、C2}\n- S3={CS、C3}\n\n像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。\n\n当我们计算时 S1、S2、S3的探针总成本仅为758M\n\n此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.\n\n总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。\n\n图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。\n\n性能结果表明，OmniSci通过流水线方式消除了单个大块的连接，\n\nSPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 通过将单个大的连接树分割成多个较小的连接子树，并对连接子树的结果执行n个连接。\n\n\n\n### 4 n个连接树的查询规划方法\n\n我们首先将在第4.1节中介绍用于生成包含**单个n-ary连接操作符**的查询计划的查询规划方法。然后，我们将该方法**推广**到更复杂的查询中，这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。\n\n我们考虑一个来自给定查询Q的连接图\n\n查询Q的连接图G=(V、E、f(v∈V)、g(e∈E)、h(e∈E))是一个无向多重图。\n\n顶点v∈V表示Q中连接的关系，\n\n边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。\n\n有三个标记功能f(v)、g(e)和h(e)。\n\n函数f(v)返回 关系v的类型，即事实或维数，\n\n函数g(e）连接操作的类型，即PK-FK或FK-FK，\n\n以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).\n\n在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图**表示为核心子图**\n\n连接图G的核心子图，即核心=(Vc，Ec)⊆G，**s.t.是subject to 的缩写，表示约束条件。在。。。的情况下**。\n\n其中任何两个顶点X和Y在X∈Vc和Y∈Vc的情况下，通过as连接 *E**X*,*Y* ⊆ *E**c**E**c* s.t. *g*(*e* ∈ *E**X*,*Y* )\n\n= FK-FK, *f* (*X*) = *f act* and *f* (*Y*) = *f act*.\n\n在图3中，一个子图{SS，SR，CS}是一个核心子图，因为**所有的顶点都是事实表**，\n\n事实数据表是包含描述业务内特定事件的数据。是发生在现实世界中的操作型事件所产生的可度量数据，**通常包含大量的行。**日常查询请求的主要目标就是基于事实表展开计算和聚合操作。\n从最低粒度级别来看，事实表行对应一个度量事件，也可以说，一个度量事件必然对应一个最低粒度的事实行为。\n\n我们认为的一行数据是什么样的，粒度。\n\n事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与维度表中对应项的相关索引字段除外的任何数据。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\n\n\n​\t\t\t\t\t\t\t\t\t\t\t图5：激励性查询的分解。\n\n如果一个连接图G只有**一个**核心子图**核心**，那么我们可以将G分解为核心子图核心和一组彼此在**边不相交的非核心子图**。\n\n我们就可以使用r 将上述两种分解方法分别表示为D1={core、G1、G2、G3}和D2={core、G1}。\n\n算法1提供了仅包含单个核心子图的查询的基本查询规划方法。\n\n<<<<<<< HEAD\n这种方法背后的直觉是使一个**核心子图**成为一个**查询计划**和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。\n\n\n\n\n\n#### 4.3 搜索空间\n\n分解的数量取决于选择哪个核心子图作为根节点，我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图。\n\n\n\n计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtc3zlb5u1j30uo074dfy.jpg)\n\n如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划\n\n对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)**非核心子图** hs\n\n对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的\n\n\n=======\n这种方法背后的直觉是使一个**核心子图**成为一个**查询计划**和mak**的root**根节点 用非核心子图表示查询计划中的根节点的子节点。用非核心子图表示查询计划中的根节点的**子节点。**\n\n**从每个分解Di中生成一个查询计划Pi 3-9)**从每个分解Di中生成一个查询计划Pi 3-9)从每个分解Di中生成一个查询计划Pi 3-9)\n\n当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。\n\n！！我们只考虑为一个**非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间**。前面有证明，至于为什么 需要搞一搞\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n图b为左深二元连接树\n\n将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。\n\n背后的直觉是 通过在查询计划的最后一步**处理事实表上的FK-FK连接**，从而减少从非核心子图中的连接操作生成的中间结果量。\n\n**代码5-7对于每一个分解方法Di计算代价，第九行做排序**\n\n第11行选择最好的方案，\n\n背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg)\n\n图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。\n\n图6中的每个二进制连接运算符都对应于一条绿色的边\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg)\n\n\n\n相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\nFor example, *C* appears three times in Figure 6(a) since it is shared among three subgraphs {*G*1,*G*2,*G*3}三种颜色 in Figure 5.\n\nWhen comparing two query plans in Figure 6, we can say the plan *P*1 就是D1 usually has a lower cost than the plan *P*2 since *P*1 scans a dimension table *C* two more times, whereas *P*2 scans two fact tables *SR* and *CS* one more time.\n\n#### 4.2 针对激励性查询的查询计划\n\n我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。这种查询的一种朴素的查询规划方法是将连接图中的特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。\n\n一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。\n\n**我们只需要进行修改算法1中的第6行。**\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg)\n\nNdcmp 是以ci为子图核心时，分解数，Ncore个核心子图，\n\n如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。\n\n对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，Nsubg(Dj)非核心子图，\n\nin Figure 6,\n\n*Nsubg(*D*1) = 3, and *Nsubg(*D*2) = 1.\n\n**对于每个子图Gk，都存在Nrecur(Gk)查询计划。**\n\n因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq.2\n\n![](C:\\Users\\wzr\\Desktop\\myblog\\source\\_posts\\谢希科老师数据库前沿课的论文pre\\008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。\n\n我们不考虑连接子树之间的顺序，因为**总处理时间 连接子树是相同的**，不管顺序如何。\n\n## 5 n-ARY JOIN处理方法\n\n在本节中，我们将介绍SPRINTER的n连接处理方法。\n\n我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法\n\n请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。Si为连接子树\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：估计连接变量的每个全局顺序的成本。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n对于一个n-ary连接操作符，子节点的可能顺序数变为n！\n\n在原则上。我们假设n个连接运算符的子级从左到右计算。\n\n对于朴素方法，无论处理子节点的顺序如何，处理n-ary连接运算符的时间都变得相同\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n图7(a)显示了一个用于评估三个连接子树的示例时间线.\n\n\n\n我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。\n\n图7(a)显示了一个用于评估三个连接子的示例时间线\n\n我们将将Si计算为Teval(Si)的**经过时间**，以及**对其结果进行排序**的经过时间表示为Tsort(Si)。\n\n我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)<Teval(Sj)(i<j)。经过时间按ij递增\n\n**步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。**\n\n步骤5根据全局顺序对每个结果进行排序，\n\n步骤6在时间t2时使用**第2节2.2中所述的TJ(Tributary Join)算法**完成。\n\n我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)>TSort(Si)或Teval(Si)<Tsort(Si)。\n\n\n\n时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n\n\n\n\n\n### 5 自动连接处理方法和优化方法，提供查询性能\n\n在本节中，我们将介绍SPRINTER的n连接处理方法。\n\n我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。 Si为连接子树\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：**估计连接变量的每个全局顺序的成本**。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n对于一个n-ary连接操作符，子节点的可能顺序数变为n！\n\n对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。\n\n步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。\n\n朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠\n\n因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n\n **图7(b)显示了修改后的方法的时间线。**\n\n步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)**。因为先计算 ，就达不到评估和排序的重叠效果**\n\n在步骤3中，它重叠了使用**CPU评估S**i，并使用GPU(i，j)对**Sj**的结果进行排序。\n\n在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变**（箭头的总长度没有改变）**\n\n我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。\n\n**由于SPRINTER可以同时使用CPU和GPU，**并且同时使用流水线技术，在评估si的时候，排序sj，我们假设s1,s2,s3分别为gpu一次可处理数据大小的1倍，2倍，3倍。\n\n图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n\n\n### 确定全局顺序\n\n一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。\n\n本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg)\n\n给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备三个变量的组合<w,|Ew|,Cw>\n\nw是一个连接变量，Ew是w的连接条件数，Cw是w连接的约束的数量，Cw是关系中有w的数量，\n\n图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg)\n\n对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。\n\n然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。\n\n则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。\n\n则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。\n\n直观地，算法选择**具有更多连接条件**和**可能有更多元组**作为**更高优先级处理的连接变量**，以减少对**排序关系进行二分搜索**的总量。\n\n\n\n#### 5.2 排序策略\n\n三个因素：**GPU的可用性**，**待排序的数据量的大小**，**数据字段的量**，\n\n如果GPU不可用，则sprinter使用cpu非比较排序number of sorting columns is only one，\n\n其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较或基于比较的GPU排序算法，具体取决于**排序列的数量**。\n\n第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择\n\n一个排序算法 **GPU排序缺乏良好实现的问题**\n\nGPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg)\n\n\n\n如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。**类似外部排序**\n\n用GPU排序，再用cpu合并比很多情况下都要慢。**因此我们直接用cpu比较排序**。\n\n If a relation has only a single sorting column,we just use heterogeneous sorting in Section 2.1 since there is a very fast implementation of a non-comparison based algorithm for GPU, and **the cost of merging subarrays is not so large.** \n\n#### 合并加入排序 排序啥？\n\nitem、cust和ticket表示为i、c和 t\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg)\n\n如果4放在最后面，是不是代价就会少很多？\n\n\n\n#### 进行查询优化的成本模型\n\n我们认为查询计划 P old 由 M-1 个二元连接运算符组成\n\n使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。\n\n\n\n因此，我们建立了成本模型成本(PNew)和成本(P old)，以确定成本(Pnew)<成本(Pold)。\n\n我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。\n\n **Cost model of the base system**\n\nWe consider that a query plan *P**old* consists of *M* M 1 binary join operators for *M* relations.\n\n我们考虑PK-FK连接或FK-FK连接的**每个二进制连接运算符都使用主内存哈希连接算法**进行计算，该算法不仅在OmniSci[33]（GPU）排序中很常见，而且在其他内存查询中也很常见 处理系统\n\n 我们假设查询处理探测**最左关系的每个元组**，\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg)\n\nEQ3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数，EQ4\n\n探测(F1)探测元组的成本函数 F1 EQ5\n\n\n\n我们可以假设F1的每个元组都与F2的哈希表中的dup2元素进行比较，而不管哈希表的类型如何（例如，开放寻址、单独的链接）。\n\n谓词：属于函数的一种，但其返回值是真值(true/false/unknown) \n\n\n\n#### SPRINTER的成本模型\n\n一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。\n\n我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。\n\nEq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg)\n\n\n\n如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg)\n\n\n\n### 7 介绍了实验评价的结果\n\n**SPRINTER**与**现有的OLAP查询处理系统**所经过的复杂OLAP查询时间i进行比较,in the TPC-DS benchmark\n\n。详细地，我们通过实证验证了选择第5节中描述的排序算法的策略，\n\n在第6节中提出的成本模型，以及排序算法的性能。\n\n##### 实验设置\n\n查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]\n\n环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，\n\n512GB主存和一个11GB的NVIDIAGTX1080TiGPU。 操作系统OS7.5\n\n\n\n系统比较：与sprinter系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg)\n\n对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，\n\n这类似于System-X。但是，它生成了一个二进制（更加平衡的树，区别于作深树）的查询计划，这是与System-x的主要区别之一。\n\n此外，**Sys tem-Y以流水线的方式处理查询计划**，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。\n\nusing only CPU as SPRINTER(C) and the one of SPRINTER\n\nusing both CPU and GPU as SPRINTER(G). \n\n我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。\n\n此外，sprinter(C)和sprinter(G)的大多数查询的性能都优于所有系统，这是由于它们不同的查询计划和不同的连接处理\n\n对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍\n\nSPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。\n\nWe note that the current SPRINTER does not use ad\u0002vanced query optimization techniques that System-X and System-Y use, since its base system, OmniSci, does not sup\u0002port them yet. Thus, the performance of SPRINTER can be further **improved by applying the optimization techniques** to OmniSci or SPRINTER.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg)\n\n对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理时有更多的故障，通常性能更差。\n\n这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。\n\n然而，图11中的TPC-DS查询通常具有较低的fi值（即，接近于0），因此，Sissem-X配备了支持索引驱动的查询执行和查询优化技术 执行OmniSci。 fi是什么\n\n对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。\n\n相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表\nEXPERIMENTAL EVALUATION\n\n### 相关工作\n\n\n\n### 总结全文\n\n<<<<<<< HEAD\n本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。\n\n它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的**传统的左深二进制连接树**\n\n该计划可以通过将事实表格上的**FK-FK连接**放入一个n-ary连接操作符中，从而**显著降低探测成本**。\n\nWe also have proposed an effi\u0002cient *n*-ary join processing method which is based on the TJ algorithm and heuristic algorithm selecting a good global variable order. \n\n我们提出的sprinter已经可以集成到开源的内存OLAP系统，OmniSci，跨所有相关的层和模块。\n\n通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。\n\n算法执行过程：\n\n算法1，确定了一个核心子图，然后对它的非核心子图一般是维表进行遍历，最后计算事实表的计算，尽量减少中间连接操作形成的结果量\n\n算法2就是算法1的推广，有多个核心子图，对它进行遍历\n\n=======\n>>>>>>> 659ab8ab41e0f048755673e552dec5884206a142\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n","source":"_posts/谢希科老师数据库前沿课的论文pre.md","raw":"---\ntitle: 谢希科老师数据库前沿课的论文pre\ndate: 2021-07-31 18:40:08\ncategories:\n- ustc\n- 个人生活\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/website-programming-code-free-photo-2210x1473.jpg\n---\n之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好\n\n## pre要求\n全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。\n\n要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。\n\nppt的讲诉，不能太长，要突出重点，\n\n讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。\n\n## 论文选题\n相比研究之前的skyline，我更希望看点对我有用的东西，\n\n所以我准备选取数据库方向的文章。\n\nSPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020\n\n离谱，wps新版的划词翻译的地方还不好找，\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg)\n\n如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。\n\n短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法\n复杂OLAP查询的快速n元连接查询处理方法\n\n<<<<<<< HEAD\n=======\n##### 超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键\n\n##### 候选键(candidate key):不含有多余属性的超键称为候选键\n\n##### 主键(primary key):用户选作元组标识的一个候选键程序主键\n\n**外键 (FK)** 是用于建立和加强两个表数据之间的链接的**一列**或**多列**\n\n通过将保存表中主键值的一列或多列添加到另一个表中，可创建两个表之间的链接。这个列就成为第二个表的外键。\n\n**一张表外键的值一般来说是另一张表主键的值。因此，外键的存在使得表与表之间可以联系起来**\n\nFOREIGN KEY 约束防止这种情况的发生。如果主键表中数据的更改使之与外键表中数据的链接失效，则这种更改是不能实现的，从而确保了引用完整性。如果试图删除主键表中的行或更改主键值，而该主键值与另一个表的 FOREIGN KEY 约束值相关，则该操作不可实现。若要成功更改或删除FOREIGN KEY 约束的行，可以先在外键表中删除外键数据或更改外键数据，然后将外键链接到不同的主键数据上去。\n\n**OLAP**联机分析处理是一种软件技术，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。\n\n随着市场竞争的日趋激烈，企业更加强调决策的及时性和准确性，这使得以**支持决策管理分析**为主要目的的应用迅速崛起，这类应用被称为**联机分析处理**，它所存储的数据被称为信息数据。\n\n数据仓库：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），**支持复杂的分析操作，侧重决策支持，并且提供直观易懂**的查询结果。\n\n基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。\n\n- 电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。\n- 第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成**多台服务器**和多个业务数据库（**量大+分库分表**），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。\n- 第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到**非常精细化**和**具体的用户的集群分析**，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。\n\n这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：\n\n1. 业务数据库中的数据结构是**为了完成交易而设计**的，不是为了而查询和分析的便利设计的。\n2. 业务数据库大多是**读写优化的**，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。\n\n而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：\n\n1. 数据结构为了分析和查询的便利；\n2. 只读优化的数据库，即**不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。**\n\n数据库 比较流行的有：MySQL, Oracle, SqlServer等\n\n数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等\n\n**本OLAP查询**，基于成本模型 生成包含 **n 元连接运算符**的 查询计划。\n\n**+：a+b所以‘+’就是二元运算符。\n++：a++所以++就是一元运算符。**\n\nn元就是n个元素，n个表做连接运算\n\n### 本文结论：SPRINTER 的性能优于最先进的 OLAP 系统。\n\nkeywords: n元连接运算符，查询规划，查询优化，FK-FK连接，复杂OLAP查询处理，协同处理\n\n现有系统利用了各种技术，例如中间结果的流水线\n\nOLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学\n\nIn particular, the number of queries which\n\ncontain join operations between a pair of foreign (or non\u0002\n\nunique) keys rather than a conventional pair of primary and\n\nforeign keys increases in the applications. \n\n!尤其是，查询的数量**包括了外键之间的连接操作**，而不是增加在应用程序的**传统主键和外键**\n\n本文将这种连接操作表示为FK-FK连接，一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。\n\n**流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。**\n\n!它可能对PK-FK连接的查询有效，但对于**事实表中包含FK-FK连接的复杂查询**可能无效\n\n**内连接**实际上就是利用 **where 子句**对两张(多表)表形成的笛卡尔积进行筛选,**我们前面学习的查询都是内连接,也是在开发过程中用的最多的连接查询。**\n\n**外连接，如果是全外连接，左*右含有的行** \n\n数据库视图：\n\n视图是一种**虚拟**的表（逻辑表），具有和**物理表**相同的功能。\n可以对视图进行**增，改，查**，操作，\n试图通常是有**一个表或者多个表的行或列的子集**。\n对视图的修改**不影响**基本表。\n它使得我们获取数据**更容易**，相比多表查询\n\n视图是一个虚拟表，**其查询的数据来自于视图定义时的 as select xx 查询语句**。视图的列来自于一个表或多个表，所以视图不可以和表名重名。\n数据多用作查询，一般不会通过视图去修改数据。\n\n\n\n**!因为存在以下两个问题：**许多key比较 以及大量的内存使用量。\n\n首先，探测关系中每个元组的连接键值需要与哈希表中的**所有重复键值相匹配**。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。\n\nn元连接操作和二元连接操作相比，可以减少中间结果数量，大多数情况下更有效，\n\n**多路连接处理**(归并？）已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 ，**因为在内存内的处理环境中，哈希连接通常优于归并排序连接**，并且不同于OLAY图形模式查询，OLAY查询是ad-hoc(点对点)和acyclic(无环)；\n\n!我们提出了一种方法，可以生成n元连接的查询，而不是传统的二元操作，\n\n生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，相比较二元 搜索空间变得更大，\n\n我们**提出了所使用的成本模型**和一种**查询优化方法 t**允许查询规划方法\n\n\n\n!实际应用环境很少 出现简单的二元连接,而**更多的是复杂的多元连接**(multi-mays join)\n\nn 元连接可以以多种方式分解成 n−1 个二 元连接，每二元连接又可以采用多种算法,因此存在大量执行计划。\n\n!算法代价以 I/O 为主,**CPU 因等待 I/O 而空闲**,因此,优化连接 **性能最有效的方法是减少 I/O 操作**\n\n\n\n**等值连接**与**自然连接**是应用最广泛的连接操作,自然连接与等值连接无本质区别,可以通过修改属性名把 等值连接操作转化为自然连接操作,所以研究自然连接具有普遍意义.本节以自然连接(ڇ(为例,设 R 和 S 是两个 数据集,attr(⋅)表示数据集的属性集\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtaut6tcsnj31160nuadm.jpg)\n\n\n\n### 与等值连接的区别\n\n\\1. 等值连接中不要求属性值完全相同，而自然连接要求两个关系中进行比较的必须是相同的属性组（属性名可以不同），即要求必须有相同的值域。\n\n\\2. 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接（如图所示）\n\n\n\n!由于连接运算结果是确定的,因此无论采用何种顺序执行多元连接,**结果集大小是一致的**.因此,我们需找 到这些执行计划中 **I/O 代价最小的作为最优执行计划.**\n\n\n\n较直接的算法为逐一计算每个执行计划的 I/O 代价,搜索 I/O 代价最小的执行计划\n\n\n\n首先,对于任意一个执行计划,需要逐一计算 SiڇSj 的结果集大小Φij 和 6 种算法的 I/O代价,选取 I/O 代价最小的算法作为 SiڇSj 的执行算法.那么对于一个 n 元连接的执行计划选择,至少要计算![](https://tva1.sinaimg.cn/large/008i3skNgy1gtauvy654lj308002cdfq.jpg)\n\n次连接代价。并在这么多代价里面搜索最小代价。\n\n\n\n只有在与传统的二进制左深连接树相比**有益时**才生成n-ary连接树\n\n\n\n保证 多作业的并行性同时会降低每个作业的并行性,多作业并行并没有带来额外的性能提升\n\n若 I/O 密集型和 CPU 密集型作业并行执行,则有助于提高资源利用率,提高性能\n\n若多个 I/O 密集型作业并行执行,每个作业需要 的资源不能互补,而且会争抢 I/O 资源\n\n\n\nFK总是和PK相连接\n当两个表中间有了PK-FK连接，那么这两个表就有了关系\n\n\n\n单向连接啥基于最坏情况最优连接算法， the worst\u0002 case optimal join algorithm，\n\nwe have demonstrated that SPRINTER significantly outperforms the state-of-the-art OLAP query processing systems in terms of both processing speed and data size that can be **processed without our of memory**.\n\n我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以在内存不溢出的情况下处理\n\n本文贡献如下：\n\n- 我们提出了一种查询方法，可以生成复杂的OLAY查询的n元连接树包含FK-FK\n- 我们提出了成本模型和查询优化n路连接树的方法\n- n元n路处理方法：基于最坏情况最优连接算法\n- 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。\n- 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。\n\n\n\n### 2.2 sprinter 中使用最坏情况下最优连接算法\n\n当n-ary连接操作符的输入大小非常大时，使用**GPU进行排序**可以进一步提高查询性能。因此，SPRINTER使用不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。\n\n!**表1中基于比较的算法**意味着，它们需要在排序的key值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n。它们不需要这样的比较来进行排序（例如，radix排序。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.logN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。\n\n\n\n**在那个case，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。**\n\nwe assume that *X* is too large to fit in GPU memory, and so, we need to split it into six subar\u0002 rays {*X*1, · · · ,*X*6}. \n\n虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。\n\n异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本。 y尽可能通过重叠**三种低级GPU操作**，**H2D拷贝**、**radix排序**和**D2H拷贝**。\n\n两两合并成一个新的这下一个x2   **在x1排序的时候对x2进行排序**\n\n![image-20210805223429708](/Users/wuzhenren/myblog/source/_posts/谢希科老师数据库前沿课的论文pre.assets/image-20210805223429708.png)\n\n\n\n#### 最坏情况最优连接算法\n\n通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询），一些算法[1,31,44]**需要对输入关系和存储进行预处理，预处理作为数据结构的结果，如B+-tree，**\n\n![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)\n\n当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二分查找，因此，单个搜索的成本是O(logN),如果一个查询有L个连接变量，**则可能的全局变量顺序的数量为L！，排列组合**。 虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于**每个变量顺序的搜索成本不同**IO成本，可能远非最优。因此，**TJ估计每个可能顺序的连接处理成本**（这就是TJ），并选择最好的顺序。\n\n### 3 一个激励例子\n\n在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS(?)基准数据库[30]上的一个查询，**广泛用于t 测试OLAP系统[18]的查询性能**。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点**关注连接**操作。图3显示了的连接图 该查询包含蓝色矩形的**三个事实表{SS、SR、CS}** （事实表，记录具体事件，如用户交易流水表）和绿色矩形的**三维表{D、I、C}**。（每个维度可能包含多个属性 比如时间维度看有插入时间 更新时间）为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有**2个FK-FK连接**操作，**绿线有5个PK-FK连接**操作。 外键连接越少越好？\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg)\n\n\n\n\n\n\n\n\n\n\n\n图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。 \n\n系统-x是一个功能齐全的最先进的商业化的**内存数据库系统**,支持**索引驱动**的查询执行和查询优化技术，如bloom过滤器和自适应连接。\n\n在图4(a)中，它为查询计划生成一个**左深连接树**相当于从左到右顺序结合，并以操作员一次**操作的方式**执行该计划。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n\n\n**C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。**【？】\n\n2.23B就是22.3亿\n\n图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数\n\n因为连接操作是FK-FK连接，并且在哈希表中有许多**重复的键值**，所以num 在**探测连接**过程中，哈希表中的key值被访问，我们称之为**探测成本**，这是探测成本，特别是160.9B倍。\n\nOmniSci[33]是一个开源的**协同处理数据库系统**，其中协同处理意味着**同时**利用**cpu**和**gpu**进行查询处理。\n\n如图b,它生成了一个左深连接的查询计划和a一样。\n\n但是是以**非阻塞**和**流水线的方式**执行计划，它**不会生成和存储**要连接的**中间结果**。\n\n详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。\n\n图b中SS和SR的第一个连接 ，**对SS的每一个元祖依次探测SR的29M元祖，即暴力遍历**、，哪个探测成本变成了4.1亿美元。\n\n然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B.\n\n我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.\n\nSPRINTER是系统原型，即我们提出的一种集成了跨所有相关层和模块无缝集成到OmniSci中的方法。\n\n我们选择OmniSci作为SPRINTER的基础系统，因为它是最先进的开源现代数据库系统\n\n虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。\n\n如图c，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。\n\n它分别执行三个连接子树，\n\n- S1={SS、C1、D， I}\n- S2={SR、C2}\n- S3={CS、C3}\n\n像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。\n\n当我们计算时 S1、S2、S3的探针总成本仅为758M\n\n此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.\n\n总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。\n\n图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。\n\n性能结果表明，OmniSci通过流水线方式消除了单个大块的连接，\n\nSPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 通过将单个大的连接树分割成多个较小的连接子树，并对连接子树的结果执行n个连接。\n\n\n\n### 4 n个连接树的查询规划方法\n\n我们首先将在第4.1节中介绍用于生成包含**单个n-ary连接操作符**的查询计划的查询规划方法。然后，我们将该方法**推广**到更复杂的查询中，这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。\n\n我们考虑一个来自给定查询Q的连接图\n\n查询Q的连接图G=(V、E、f(v∈V)、g(e∈E)、h(e∈E))是一个无向多重图。\n\n顶点v∈V表示Q中连接的关系，\n\n边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。\n\n有三个标记功能f(v)、g(e)和h(e)。\n\n函数f(v)返回 关系v的类型，即事实或维数，\n\n函数g(e）连接操作的类型，即PK-FK或FK-FK，\n\n以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).\n\n在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图**表示为核心子图**\n\n连接图G的核心子图，即核心=(Vc，Ec)⊆G，**s.t.是subject to 的缩写，表示约束条件。在。。。的情况下**。\n\n其中任何两个顶点X和Y在X∈Vc和Y∈Vc的情况下，通过as连接 *E**X*,*Y* ⊆ *E**c**E**c* s.t. *g*(*e* ∈ *E**X*,*Y* )\n\n= FK-FK, *f* (*X*) = *f act* and *f* (*Y*) = *f act*.\n\n在图3中，一个子图{SS，SR，CS}是一个核心子图，因为**所有的顶点都是事实表**，\n\n事实数据表是包含描述业务内特定事件的数据。是发生在现实世界中的操作型事件所产生的可度量数据，**通常包含大量的行。**日常查询请求的主要目标就是基于事实表展开计算和聚合操作。\n从最低粒度级别来看，事实表行对应一个度量事件，也可以说，一个度量事件必然对应一个最低粒度的事实行为。\n\n我们认为的一行数据是什么样的，粒度。\n\n事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与维度表中对应项的相关索引字段除外的任何数据。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\n\n\n​\t\t\t\t\t\t\t\t\t\t\t图5：激励性查询的分解。\n\n如果一个连接图G只有**一个**核心子图**核心**，那么我们可以将G分解为核心子图核心和一组彼此在**边不相交的非核心子图**。\n\n我们就可以使用r 将上述两种分解方法分别表示为D1={core、G1、G2、G3}和D2={core、G1}。\n\n算法1提供了仅包含单个核心子图的查询的基本查询规划方法。\n\n<<<<<<< HEAD\n这种方法背后的直觉是使一个**核心子图**成为一个**查询计划**和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。\n\n\n\n\n\n#### 4.3 搜索空间\n\n分解的数量取决于选择哪个核心子图作为根节点，我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图。\n\n\n\n计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtc3zlb5u1j30uo074dfy.jpg)\n\n如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划\n\n对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)**非核心子图** hs\n\n对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的\n\n\n=======\n这种方法背后的直觉是使一个**核心子图**成为一个**查询计划**和mak**的root**根节点 用非核心子图表示查询计划中的根节点的子节点。用非核心子图表示查询计划中的根节点的**子节点。**\n\n**从每个分解Di中生成一个查询计划Pi 3-9)**从每个分解Di中生成一个查询计划Pi 3-9)从每个分解Di中生成一个查询计划Pi 3-9)\n\n当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。\n\n！！我们只考虑为一个**非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间**。前面有证明，至于为什么 需要搞一搞\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n图b为左深二元连接树\n\n将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。\n\n背后的直觉是 通过在查询计划的最后一步**处理事实表上的FK-FK连接**，从而减少从非核心子图中的连接操作生成的中间结果量。\n\n**代码5-7对于每一个分解方法Di计算代价，第九行做排序**\n\n第11行选择最好的方案，\n\n背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg)\n\n图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。\n\n图6中的每个二进制连接运算符都对应于一条绿色的边\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg)\n\n\n\n相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\nFor example, *C* appears three times in Figure 6(a) since it is shared among three subgraphs {*G*1,*G*2,*G*3}三种颜色 in Figure 5.\n\nWhen comparing two query plans in Figure 6, we can say the plan *P*1 就是D1 usually has a lower cost than the plan *P*2 since *P*1 scans a dimension table *C* two more times, whereas *P*2 scans two fact tables *SR* and *CS* one more time.\n\n#### 4.2 针对激励性查询的查询计划\n\n我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。这种查询的一种朴素的查询规划方法是将连接图中的特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。\n\n一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。\n\n**我们只需要进行修改算法1中的第6行。**\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg)\n\nNdcmp 是以ci为子图核心时，分解数，Ncore个核心子图，\n\n如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。\n\n对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，Nsubg(Dj)非核心子图，\n\nin Figure 6,\n\n*Nsubg(*D*1) = 3, and *Nsubg(*D*2) = 1.\n\n**对于每个子图Gk，都存在Nrecur(Gk)查询计划。**\n\n因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq.2\n\n![](C:\\Users\\wzr\\Desktop\\myblog\\source\\_posts\\谢希科老师数据库前沿课的论文pre\\008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。\n\n我们不考虑连接子树之间的顺序，因为**总处理时间 连接子树是相同的**，不管顺序如何。\n\n## 5 n-ARY JOIN处理方法\n\n在本节中，我们将介绍SPRINTER的n连接处理方法。\n\n我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法\n\n请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。Si为连接子树\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：估计连接变量的每个全局顺序的成本。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n对于一个n-ary连接操作符，子节点的可能顺序数变为n！\n\n在原则上。我们假设n个连接运算符的子级从左到右计算。\n\n对于朴素方法，无论处理子节点的顺序如何，处理n-ary连接运算符的时间都变得相同\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n图7(a)显示了一个用于评估三个连接子树的示例时间线.\n\n\n\n我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。\n\n图7(a)显示了一个用于评估三个连接子的示例时间线\n\n我们将将Si计算为Teval(Si)的**经过时间**，以及**对其结果进行排序**的经过时间表示为Tsort(Si)。\n\n我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)<Teval(Sj)(i<j)。经过时间按ij递增\n\n**步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。**\n\n步骤5根据全局顺序对每个结果进行排序，\n\n步骤6在时间t2时使用**第2节2.2中所述的TJ(Tributary Join)算法**完成。\n\n我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)>TSort(Si)或Teval(Si)<Tsort(Si)。\n\n\n\n时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n\n\n\n\n\n### 5 自动连接处理方法和优化方法，提供查询性能\n\n在本节中，我们将介绍SPRINTER的n连接处理方法。\n\n我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。 Si为连接子树\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：**估计连接变量的每个全局顺序的成本**。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n对于一个n-ary连接操作符，子节点的可能顺序数变为n！\n\n对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。\n\n步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。\n\n朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠\n\n因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n\n **图7(b)显示了修改后的方法的时间线。**\n\n步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)**。因为先计算 ，就达不到评估和排序的重叠效果**\n\n在步骤3中，它重叠了使用**CPU评估S**i，并使用GPU(i，j)对**Sj**的结果进行排序。\n\n在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变**（箭头的总长度没有改变）**\n\n我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。\n\n**由于SPRINTER可以同时使用CPU和GPU，**并且同时使用流水线技术，在评估si的时候，排序sj，我们假设s1,s2,s3分别为gpu一次可处理数据大小的1倍，2倍，3倍。\n\n图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n\n\n### 确定全局顺序\n\n一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。\n\n本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg)\n\n给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备三个变量的组合<w,|Ew|,Cw>\n\nw是一个连接变量，Ew是w的连接条件数，Cw是w连接的约束的数量，Cw是关系中有w的数量，\n\n图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg)\n\n对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。\n\n然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。\n\n则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。\n\n则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。\n\n直观地，算法选择**具有更多连接条件**和**可能有更多元组**作为**更高优先级处理的连接变量**，以减少对**排序关系进行二分搜索**的总量。\n\n\n\n#### 5.2 排序策略\n\n三个因素：**GPU的可用性**，**待排序的数据量的大小**，**数据字段的量**，\n\n如果GPU不可用，则sprinter使用cpu非比较排序number of sorting columns is only one，\n\n其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较或基于比较的GPU排序算法，具体取决于**排序列的数量**。\n\n第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择\n\n一个排序算法 **GPU排序缺乏良好实现的问题**\n\nGPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg)\n\n\n\n如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。**类似外部排序**\n\n用GPU排序，再用cpu合并比很多情况下都要慢。**因此我们直接用cpu比较排序**。\n\n If a relation has only a single sorting column,we just use heterogeneous sorting in Section 2.1 since there is a very fast implementation of a non-comparison based algorithm for GPU, and **the cost of merging subarrays is not so large.** \n\n#### 合并加入排序 排序啥？\n\nitem、cust和ticket表示为i、c和 t\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg)\n\n如果4放在最后面，是不是代价就会少很多？\n\n\n\n#### 进行查询优化的成本模型\n\n我们认为查询计划 P old 由 M-1 个二元连接运算符组成\n\n使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。\n\n\n\n因此，我们建立了成本模型成本(PNew)和成本(P old)，以确定成本(Pnew)<成本(Pold)。\n\n我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。\n\n **Cost model of the base system**\n\nWe consider that a query plan *P**old* consists of *M* M 1 binary join operators for *M* relations.\n\n我们考虑PK-FK连接或FK-FK连接的**每个二进制连接运算符都使用主内存哈希连接算法**进行计算，该算法不仅在OmniSci[33]（GPU）排序中很常见，而且在其他内存查询中也很常见 处理系统\n\n 我们假设查询处理探测**最左关系的每个元组**，\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg)\n\nEQ3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数，EQ4\n\n探测(F1)探测元组的成本函数 F1 EQ5\n\n\n\n我们可以假设F1的每个元组都与F2的哈希表中的dup2元素进行比较，而不管哈希表的类型如何（例如，开放寻址、单独的链接）。\n\n谓词：属于函数的一种，但其返回值是真值(true/false/unknown) \n\n\n\n#### SPRINTER的成本模型\n\n一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。\n\n我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。\n\nEq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg)\n\n\n\n如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg)\n\n\n\n### 7 介绍了实验评价的结果\n\n**SPRINTER**与**现有的OLAP查询处理系统**所经过的复杂OLAP查询时间i进行比较,in the TPC-DS benchmark\n\n。详细地，我们通过实证验证了选择第5节中描述的排序算法的策略，\n\n在第6节中提出的成本模型，以及排序算法的性能。\n\n##### 实验设置\n\n查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]\n\n环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，\n\n512GB主存和一个11GB的NVIDIAGTX1080TiGPU。 操作系统OS7.5\n\n\n\n系统比较：与sprinter系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg)\n\n对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，\n\n这类似于System-X。但是，它生成了一个二进制（更加平衡的树，区别于作深树）的查询计划，这是与System-x的主要区别之一。\n\n此外，**Sys tem-Y以流水线的方式处理查询计划**，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。\n\nusing only CPU as SPRINTER(C) and the one of SPRINTER\n\nusing both CPU and GPU as SPRINTER(G). \n\n我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。\n\n此外，sprinter(C)和sprinter(G)的大多数查询的性能都优于所有系统，这是由于它们不同的查询计划和不同的连接处理\n\n对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍\n\nSPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。\n\nWe note that the current SPRINTER does not use ad\u0002vanced query optimization techniques that System-X and System-Y use, since its base system, OmniSci, does not sup\u0002port them yet. Thus, the performance of SPRINTER can be further **improved by applying the optimization techniques** to OmniSci or SPRINTER.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg)\n\n对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理时有更多的故障，通常性能更差。\n\n这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。\n\n然而，图11中的TPC-DS查询通常具有较低的fi值（即，接近于0），因此，Sissem-X配备了支持索引驱动的查询执行和查询优化技术 执行OmniSci。 fi是什么\n\n对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。\n\n相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表\nEXPERIMENTAL EVALUATION\n\n### 相关工作\n\n\n\n### 总结全文\n\n<<<<<<< HEAD\n本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。\n\n它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的**传统的左深二进制连接树**\n\n该计划可以通过将事实表格上的**FK-FK连接**放入一个n-ary连接操作符中，从而**显著降低探测成本**。\n\nWe also have proposed an effi\u0002cient *n*-ary join processing method which is based on the TJ algorithm and heuristic algorithm selecting a good global variable order. \n\n我们提出的sprinter已经可以集成到开源的内存OLAP系统，OmniSci，跨所有相关的层和模块。\n\n通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。\n\n算法执行过程：\n\n算法1，确定了一个核心子图，然后对它的非核心子图一般是维表进行遍历，最后计算事实表的计算，尽量减少中间连接操作形成的结果量\n\n算法2就是算法1的推广，有多个核心子图，对它进行遍历\n\n=======\n>>>>>>> 659ab8ab41e0f048755673e552dec5884206a142\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n","slug":"谢希科老师数据库前沿课的论文pre","published":1,"updated":"2021-08-18T01:02:59.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksiamo9b001lc37612yj4hbz","content":"<p>之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好</p>\n<h2 id=\"pre要求\"><a href=\"#pre要求\" class=\"headerlink\" title=\"pre要求\"></a>pre要求</h2><p>全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。</p>\n<p>要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。</p>\n<p>ppt的讲诉，不能太长，要突出重点，</p>\n<p>讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。</p>\n<h2 id=\"论文选题\"><a href=\"#论文选题\" class=\"headerlink\" title=\"论文选题\"></a>论文选题</h2><p>相比研究之前的skyline，我更希望看点对我有用的东西，</p>\n<p>所以我准备选取数据库方向的文章。</p>\n<p>SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020</p>\n<p>离谱，wps新版的划词翻译的地方还不好找，<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg\"></p>\n<p>如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。</p>\n<p>短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法<br>复杂OLAP查询的快速n元连接查询处理方法</p>\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h5 id=\"超键-super-key-在关系中能唯一标识元组的属性集称为关系模式的超键\"><a href=\"#超键-super-key-在关系中能唯一标识元组的属性集称为关系模式的超键\" class=\"headerlink\" title=\"超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键\"></a>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键</h5><h5 id=\"候选键-candidate-key-不含有多余属性的超键称为候选键\"><a href=\"#候选键-candidate-key-不含有多余属性的超键称为候选键\" class=\"headerlink\" title=\"候选键(candidate key):不含有多余属性的超键称为候选键\"></a>候选键(candidate key):不含有多余属性的超键称为候选键</h5><h5 id=\"主键-primary-key-用户选作元组标识的一个候选键程序主键\"><a href=\"#主键-primary-key-用户选作元组标识的一个候选键程序主键\" class=\"headerlink\" title=\"主键(primary key):用户选作元组标识的一个候选键程序主键\"></a>主键(primary key):用户选作元组标识的一个候选键程序主键</h5><p><strong>外键 (FK)</strong> 是用于建立和加强两个表数据之间的链接的<strong>一列</strong>或<strong>多列</strong></p>\n<p>通过将保存表中主键值的一列或多列添加到另一个表中，可创建两个表之间的链接。这个列就成为第二个表的外键。</p>\n<p><strong>一张表外键的值一般来说是另一张表主键的值。因此，外键的存在使得表与表之间可以联系起来</strong></p>\n<p>FOREIGN KEY 约束防止这种情况的发生。如果主键表中数据的更改使之与外键表中数据的链接失效，则这种更改是不能实现的，从而确保了引用完整性。如果试图删除主键表中的行或更改主键值，而该主键值与另一个表的 FOREIGN KEY 约束值相关，则该操作不可实现。若要成功更改或删除FOREIGN KEY 约束的行，可以先在外键表中删除外键数据或更改外键数据，然后将外键链接到不同的主键数据上去。</p>\n<p><strong>OLAP</strong>联机分析处理是一种软件技术，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。</p>\n<p>随着市场竞争的日趋激烈，企业更加强调决策的及时性和准确性，这使得以<strong>支持决策管理分析</strong>为主要目的的应用迅速崛起，这类应用被称为<strong>联机分析处理</strong>，它所存储的数据被称为信息数据。</p>\n<p>数据仓库：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），<strong>支持复杂的分析操作，侧重决策支持，并且提供直观易懂</strong>的查询结果。</p>\n<p>基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。</p>\n<ul>\n<li>电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。</li>\n<li>第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成<strong>多台服务器</strong>和多个业务数据库（<strong>量大+分库分表</strong>），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。</li>\n<li>第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到<strong>非常精细化</strong>和<strong>具体的用户的集群分析</strong>，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。</li>\n</ul>\n<p>这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：</p>\n<ol>\n<li>业务数据库中的数据结构是<strong>为了完成交易而设计</strong>的，不是为了而查询和分析的便利设计的。</li>\n<li>业务数据库大多是<strong>读写优化的</strong>，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。</li>\n</ol>\n<p>而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：</p>\n<ol>\n<li>数据结构为了分析和查询的便利；</li>\n<li>只读优化的数据库，即<strong>不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。</strong></li>\n</ol>\n<p>数据库 比较流行的有：MySQL, Oracle, SqlServer等</p>\n<p>数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等</p>\n<p><strong>本OLAP查询</strong>，基于成本模型 生成包含 <strong>n 元连接运算符</strong>的 查询计划。</p>\n<p><strong>+：a+b所以‘+’就是二元运算符。<br>++：a++所以++就是一元运算符。</strong></p>\n<p>n元就是n个元素，n个表做连接运算</p>\n<h3 id=\"本文结论：SPRINTER-的性能优于最先进的-OLAP-系统。\"><a href=\"#本文结论：SPRINTER-的性能优于最先进的-OLAP-系统。\" class=\"headerlink\" title=\"本文结论：SPRINTER 的性能优于最先进的 OLAP 系统。\"></a>本文结论：SPRINTER 的性能优于最先进的 OLAP 系统。</h3><p>keywords: n元连接运算符，查询规划，查询优化，FK-FK连接，复杂OLAP查询处理，协同处理</p>\n<p>现有系统利用了各种技术，例如中间结果的流水线</p>\n<p>OLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学</p>\n<p>In particular, the number of queries which</p>\n<p>contain join operations between a pair of foreign (or non\u0002</p>\n<p>unique) keys rather than a conventional pair of primary and</p>\n<p>foreign keys increases in the applications. </p>\n<p>!尤其是，查询的数量<strong>包括了外键之间的连接操作</strong>，而不是增加在应用程序的<strong>传统主键和外键</strong></p>\n<p>本文将这种连接操作表示为FK-FK连接，一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。</p>\n<p><strong>流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。</strong></p>\n<p>!它可能对PK-FK连接的查询有效，但对于<strong>事实表中包含FK-FK连接的复杂查询</strong>可能无效</p>\n<p><strong>内连接</strong>实际上就是利用 <strong>where 子句</strong>对两张(多表)表形成的笛卡尔积进行筛选,<strong>我们前面学习的查询都是内连接,也是在开发过程中用的最多的连接查询。</strong></p>\n<p><strong>外连接，如果是全外连接，左*右含有的行</strong> </p>\n<p>数据库视图：</p>\n<p>视图是一种<strong>虚拟</strong>的表（逻辑表），具有和<strong>物理表</strong>相同的功能。<br>可以对视图进行<strong>增，改，查</strong>，操作，<br>试图通常是有<strong>一个表或者多个表的行或列的子集</strong>。<br>对视图的修改<strong>不影响</strong>基本表。<br>它使得我们获取数据<strong>更容易</strong>，相比多表查询</p>\n<p>视图是一个虚拟表，<strong>其查询的数据来自于视图定义时的 as select xx 查询语句</strong>。视图的列来自于一个表或多个表，所以视图不可以和表名重名。<br>数据多用作查询，一般不会通过视图去修改数据。</p>\n<p><strong>!因为存在以下两个问题：</strong>许多key比较 以及大量的内存使用量。</p>\n<p>首先，探测关系中每个元组的连接键值需要与哈希表中的<strong>所有重复键值相匹配</strong>。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。</p>\n<p>n元连接操作和二元连接操作相比，可以减少中间结果数量，大多数情况下更有效，</p>\n<p><strong>多路连接处理</strong>(归并？）已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 ，<strong>因为在内存内的处理环境中，哈希连接通常优于归并排序连接</strong>，并且不同于OLAY图形模式查询，OLAY查询是ad-hoc(点对点)和acyclic(无环)；</p>\n<p>!我们提出了一种方法，可以生成n元连接的查询，而不是传统的二元操作，</p>\n<p>生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，相比较二元 搜索空间变得更大，</p>\n<p>我们<strong>提出了所使用的成本模型</strong>和一种<strong>查询优化方法 t</strong>允许查询规划方法</p>\n<p>!实际应用环境很少 出现简单的二元连接,而<strong>更多的是复杂的多元连接</strong>(multi-mays join)</p>\n<p>n 元连接可以以多种方式分解成 n−1 个二 元连接，每二元连接又可以采用多种算法,因此存在大量执行计划。</p>\n<p>!算法代价以 I/O 为主,<strong>CPU 因等待 I/O 而空闲</strong>,因此,优化连接 <strong>性能最有效的方法是减少 I/O 操作</strong></p>\n<p><strong>等值连接</strong>与<strong>自然连接</strong>是应用最广泛的连接操作,自然连接与等值连接无本质区别,可以通过修改属性名把 等值连接操作转化为自然连接操作,所以研究自然连接具有普遍意义.本节以自然连接(ڇ(为例,设 R 和 S 是两个 数据集,attr(⋅)表示数据集的属性集</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtaut6tcsnj31160nuadm.jpg\"></p>\n<h3 id=\"与等值连接的区别\"><a href=\"#与等值连接的区别\" class=\"headerlink\" title=\"与等值连接的区别\"></a>与等值连接的区别</h3><p>\\1. 等值连接中不要求属性值完全相同，而自然连接要求两个关系中进行比较的必须是相同的属性组（属性名可以不同），即要求必须有相同的值域。</p>\n<p>\\2. 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接（如图所示）</p>\n<p>!由于连接运算结果是确定的,因此无论采用何种顺序执行多元连接,<strong>结果集大小是一致的</strong>.因此,我们需找 到这些执行计划中 <strong>I/O 代价最小的作为最优执行计划.</strong></p>\n<p>较直接的算法为逐一计算每个执行计划的 I/O 代价,搜索 I/O 代价最小的执行计划</p>\n<p>首先,对于任意一个执行计划,需要逐一计算 SiڇSj 的结果集大小Φij 和 6 种算法的 I/O代价,选取 I/O 代价最小的算法作为 SiڇSj 的执行算法.那么对于一个 n 元连接的执行计划选择,至少要计算<img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtauvy654lj308002cdfq.jpg\"></p>\n<p>次连接代价。并在这么多代价里面搜索最小代价。</p>\n<p>只有在与传统的二进制左深连接树相比<strong>有益时</strong>才生成n-ary连接树</p>\n<p>保证 多作业的并行性同时会降低每个作业的并行性,多作业并行并没有带来额外的性能提升</p>\n<p>若 I/O 密集型和 CPU 密集型作业并行执行,则有助于提高资源利用率,提高性能</p>\n<p>若多个 I/O 密集型作业并行执行,每个作业需要 的资源不能互补,而且会争抢 I/O 资源</p>\n<p>FK总是和PK相连接<br>当两个表中间有了PK-FK连接，那么这两个表就有了关系</p>\n<p>单向连接啥基于最坏情况最优连接算法， the worst\u0002 case optimal join algorithm，</p>\n<p>we have demonstrated that SPRINTER significantly outperforms the state-of-the-art OLAP query processing systems in terms of both processing speed and data size that can be <strong>processed without our of memory</strong>.</p>\n<p>我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以在内存不溢出的情况下处理</p>\n<p>本文贡献如下：</p>\n<ul>\n<li>我们提出了一种查询方法，可以生成复杂的OLAY查询的n元连接树包含FK-FK</li>\n<li>我们提出了成本模型和查询优化n路连接树的方法</li>\n<li>n元n路处理方法：基于最坏情况最优连接算法</li>\n<li>我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。</li>\n<li>在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。</li>\n</ul>\n<h3 id=\"2-2-sprinter-中使用最坏情况下最优连接算法\"><a href=\"#2-2-sprinter-中使用最坏情况下最优连接算法\" class=\"headerlink\" title=\"2.2 sprinter 中使用最坏情况下最优连接算法\"></a>2.2 sprinter 中使用最坏情况下最优连接算法</h3><p>当n-ary连接操作符的输入大小非常大时，使用<strong>GPU进行排序</strong>可以进一步提高查询性能。因此，SPRINTER使用不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。</p>\n<p>!<strong>表1中基于比较的算法</strong>意味着，它们需要在排序的key值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n。它们不需要这样的比较来进行排序（例如，radix排序。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.logN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。</p>\n<p><strong>在那个case，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。</strong></p>\n<p>we assume that <em>X</em> is too large to fit in GPU memory, and so, we need to split it into six subar\u0002 rays {<em>X</em>1, · · · ,<em>X</em>6}. </p>\n<p>虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。</p>\n<p>异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本。 y尽可能通过重叠<strong>三种低级GPU操作</strong>，<strong>H2D拷贝</strong>、<strong>radix排序</strong>和<strong>D2H拷贝</strong>。</p>\n<p>两两合并成一个新的这下一个x2   <strong>在x1排序的时候对x2进行排序</strong></p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E8%B0%A2%E5%B8%8C%E7%A7%91%E8%80%81%E5%B8%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%89%8D%E6%B2%BF%E8%AF%BE%E7%9A%84%E8%AE%BA%E6%96%87pre.assets/image-20210805223429708.png\" alt=\"image-20210805223429708\"></p>\n<h4 id=\"最坏情况最优连接算法\"><a href=\"#最坏情况最优连接算法\" class=\"headerlink\" title=\"最坏情况最优连接算法\"></a>最坏情况最优连接算法</h4><p>通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询），一些算法[1,31,44]<strong>需要对输入关系和存储进行预处理，预处理作为数据结构的结果，如B+-tree，</strong></p>\n<p>![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)</p>\n<p>当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二分查找，因此，单个搜索的成本是O(logN),如果一个查询有L个连接变量，<strong>则可能的全局变量顺序的数量为L！，排列组合</strong>。 虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于<strong>每个变量顺序的搜索成本不同</strong>IO成本，可能远非最优。因此，<strong>TJ估计每个可能顺序的连接处理成本</strong>（这就是TJ），并选择最好的顺序。</p>\n<h3 id=\"3-一个激励例子\"><a href=\"#3-一个激励例子\" class=\"headerlink\" title=\"3 一个激励例子\"></a>3 一个激励例子</h3><p>在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS(?)基准数据库[30]上的一个查询，<strong>广泛用于t 测试OLAP系统[18]的查询性能</strong>。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点<strong>关注连接</strong>操作。图3显示了的连接图 该查询包含蓝色矩形的<strong>三个事实表{SS、SR、CS}</strong> （事实表，记录具体事件，如用户交易流水表）和绿色矩形的<strong>三维表{D、I、C}<strong>。（每个维度可能包含多个属性 比如时间维度看有插入时间 更新时间）为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有</strong>2个FK-FK连接</strong>操作，<strong>绿线有5个PK-FK连接</strong>操作。 外键连接越少越好？</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg\"></p>\n<p>图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。 </p>\n<p>系统-x是一个功能齐全的最先进的商业化的<strong>内存数据库系统</strong>,支持<strong>索引驱动</strong>的查询执行和查询优化技术，如bloom过滤器和自适应连接。</p>\n<p>在图4(a)中，它为查询计划生成一个<strong>左深连接树</strong>相当于从左到右顺序结合，并以操作员一次<strong>操作的方式</strong>执行该计划。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p><strong>C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。</strong>【？】</p>\n<p>2.23B就是22.3亿</p>\n<p>图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数</p>\n<p>因为连接操作是FK-FK连接，并且在哈希表中有许多<strong>重复的键值</strong>，所以num 在<strong>探测连接</strong>过程中，哈希表中的key值被访问，我们称之为<strong>探测成本</strong>，这是探测成本，特别是160.9B倍。</p>\n<p>OmniSci[33]是一个开源的<strong>协同处理数据库系统</strong>，其中协同处理意味着<strong>同时</strong>利用<strong>cpu</strong>和<strong>gpu</strong>进行查询处理。</p>\n<p>如图b,它生成了一个左深连接的查询计划和a一样。</p>\n<p>但是是以<strong>非阻塞</strong>和<strong>流水线的方式</strong>执行计划，它<strong>不会生成和存储</strong>要连接的<strong>中间结果</strong>。</p>\n<p>详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。</p>\n<p>图b中SS和SR的第一个连接 ，<strong>对SS的每一个元祖依次探测SR的29M元祖，即暴力遍历</strong>、，哪个探测成本变成了4.1亿美元。</p>\n<p>然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B.</p>\n<p>我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.</p>\n<p>SPRINTER是系统原型，即我们提出的一种集成了跨所有相关层和模块无缝集成到OmniSci中的方法。</p>\n<p>我们选择OmniSci作为SPRINTER的基础系统，因为它是最先进的开源现代数据库系统</p>\n<p>虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。</p>\n<p>如图c，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。</p>\n<p>它分别执行三个连接子树，</p>\n<ul>\n<li>S1={SS、C1、D， I}</li>\n<li>S2={SR、C2}</li>\n<li>S3={CS、C3}</li>\n</ul>\n<p>像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。</p>\n<p>当我们计算时 S1、S2、S3的探针总成本仅为758M</p>\n<p>此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.</p>\n<p>总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。</p>\n<p>图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。</p>\n<p>性能结果表明，OmniSci通过流水线方式消除了单个大块的连接，</p>\n<p>SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 通过将单个大的连接树分割成多个较小的连接子树，并对连接子树的结果执行n个连接。</p>\n<h3 id=\"4-n个连接树的查询规划方法\"><a href=\"#4-n个连接树的查询规划方法\" class=\"headerlink\" title=\"4 n个连接树的查询规划方法\"></a>4 n个连接树的查询规划方法</h3><p>我们首先将在第4.1节中介绍用于生成包含<strong>单个n-ary连接操作符</strong>的查询计划的查询规划方法。然后，我们将该方法<strong>推广</strong>到更复杂的查询中，这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。</p>\n<p>我们考虑一个来自给定查询Q的连接图</p>\n<p>查询Q的连接图G=(V、E、f(v∈V)、g(e∈E)、h(e∈E))是一个无向多重图。</p>\n<p>顶点v∈V表示Q中连接的关系，</p>\n<p>边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。</p>\n<p>有三个标记功能f(v)、g(e)和h(e)。</p>\n<p>函数f(v)返回 关系v的类型，即事实或维数，</p>\n<p>函数g(e）连接操作的类型，即PK-FK或FK-FK，</p>\n<p>以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).</p>\n<p>在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图<strong>表示为核心子图</strong></p>\n<p>连接图G的核心子图，即核心=(Vc，Ec)⊆G，<strong>s.t.是subject to 的缩写，表示约束条件。在。。。的情况下</strong>。</p>\n<p>其中任何两个顶点X和Y在X∈Vc和Y∈Vc的情况下，通过as连接 <em>E**X</em>,<em>Y</em> ⊆ <em>E<strong>c</strong>E**c</em> s.t. <em>g</em>(<em>e</em> ∈ <em>E**X</em>,<em>Y</em> )</p>\n<p>= FK-FK, <em>f</em> (<em>X</em>) = <em>f act</em> and <em>f</em> (<em>Y</em>) = <em>f act</em>.</p>\n<p>在图3中，一个子图{SS，SR，CS}是一个核心子图，因为<strong>所有的顶点都是事实表</strong>，</p>\n<p>事实数据表是包含描述业务内特定事件的数据。是发生在现实世界中的操作型事件所产生的可度量数据，<strong>通常包含大量的行。</strong>日常查询请求的主要目标就是基于事实表展开计算和聚合操作。<br>从最低粒度级别来看，事实表行对应一个度量事件，也可以说，一个度量事件必然对应一个最低粒度的事实行为。</p>\n<p>我们认为的一行数据是什么样的，粒度。</p>\n<p>事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与维度表中对应项的相关索引字段除外的任何数据。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>​                                            图5：激励性查询的分解。</p>\n<p>如果一个连接图G只有<strong>一个</strong>核心子图<strong>核心</strong>，那么我们可以将G分解为核心子图核心和一组彼此在<strong>边不相交的非核心子图</strong>。</p>\n<p>我们就可以使用r 将上述两种分解方法分别表示为D1={core、G1、G2、G3}和D2={core、G1}。</p>\n<p>算法1提供了仅包含单个核心子图的查询的基本查询规划方法。</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>这种方法背后的直觉是使一个<strong>核心子图</strong>成为一个<strong>查询计划</strong>和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。</p>\n<h4 id=\"4-3-搜索空间\"><a href=\"#4-3-搜索空间\" class=\"headerlink\" title=\"4.3 搜索空间\"></a>4.3 搜索空间</h4><p>分解的数量取决于选择哪个核心子图作为根节点，我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图。</p>\n<p>计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtc3zlb5u1j30uo074dfy.jpg\"></p>\n<p>如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划</p>\n<p>对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)<strong>非核心子图</strong> hs</p>\n<p>对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的</p>\n<p>=======<br>这种方法背后的直觉是使一个<strong>核心子图</strong>成为一个<strong>查询计划</strong>和mak<strong>的root</strong>根节点 用非核心子图表示查询计划中的根节点的子节点。用非核心子图表示查询计划中的根节点的<strong>子节点。</strong></p>\n<p>**从每个分解Di中生成一个查询计划Pi 3-9)**从每个分解Di中生成一个查询计划Pi 3-9)从每个分解Di中生成一个查询计划Pi 3-9)</p>\n<p>当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。</p>\n<p>！！我们只考虑为一个<strong>非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间</strong>。前面有证明，至于为什么 需要搞一搞</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p>图b为左深二元连接树</p>\n<p>将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。</p>\n<p>背后的直觉是 通过在查询计划的最后一步<strong>处理事实表上的FK-FK连接</strong>，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<p><strong>代码5-7对于每一个分解方法Di计算代价，第九行做排序</strong></p>\n<p>第11行选择最好的方案，</p>\n<p>背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg\"></p>\n<p>图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。</p>\n<p>图6中的每个二进制连接运算符都对应于一条绿色的边</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg\"></p>\n<p>相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>For example, <em>C</em> appears three times in Figure 6(a) since it is shared among three subgraphs {<em>G</em>1,<em>G</em>2,<em>G</em>3}三种颜色 in Figure 5.</p>\n<p>When comparing two query plans in Figure 6, we can say the plan <em>P</em>1 就是D1 usually has a lower cost than the plan <em>P</em>2 since <em>P</em>1 scans a dimension table <em>C</em> two more times, whereas <em>P</em>2 scans two fact tables <em>SR</em> and <em>CS</em> one more time.</p>\n<h4 id=\"4-2-针对激励性查询的查询计划\"><a href=\"#4-2-针对激励性查询的查询计划\" class=\"headerlink\" title=\"4.2 针对激励性查询的查询计划\"></a>4.2 针对激励性查询的查询计划</h4><p>我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。这种查询的一种朴素的查询规划方法是将连接图中的特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。</p>\n<p>一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。</p>\n<p><strong>我们只需要进行修改算法1中的第6行。</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg\"></p>\n<p>Ndcmp 是以ci为子图核心时，分解数，Ncore个核心子图，</p>\n<p>如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。</p>\n<p>对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，Nsubg(Dj)非核心子图，</p>\n<p>in Figure 6,</p>\n<p>*Nsubg(<em>D</em>1) = 3, and *Nsubg(<em>D</em>2) = 1.</p>\n<p><strong>对于每个子图Gk，都存在Nrecur(Gk)查询计划。</strong></p>\n<p>因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq.2</p>\n<p><img src=\"C:\\Users\\wzr\\Desktop\\myblog\\source_posts\\谢希科老师数据库前沿课的论文pre\\008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。</p>\n<p>我们不考虑连接子树之间的顺序，因为<strong>总处理时间 连接子树是相同的</strong>，不管顺序如何。</p>\n<h2 id=\"5-n-ARY-JOIN处理方法\"><a href=\"#5-n-ARY-JOIN处理方法\" class=\"headerlink\" title=\"5 n-ARY JOIN处理方法\"></a>5 n-ARY JOIN处理方法</h2><p>在本节中，我们将介绍SPRINTER的n连接处理方法。</p>\n<p>我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法</p>\n<p>请执行以下六个步骤。</p>\n<ul>\n<li>步骤1：逐个评估{S1、·、·、Sn}。Si为连接子树</li>\n<li>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</li>\n<li>步骤3：估计连接变量的每个全局顺序的成本。 </li>\n<li>步骤4：选择最佳的全局变量顺序。</li>\n<li>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</li>\n<li>第6步：在n个已排序的关系上合并连接。</li>\n</ul>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！</p>\n<p>在原则上。我们假设n个连接运算符的子级从左到右计算。</p>\n<p>对于朴素方法，无论处理子节点的顺序如何，处理n-ary连接运算符的时间都变得相同</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<p>图7(a)显示了一个用于评估三个连接子树的示例时间线.</p>\n<p>我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。</p>\n<p>图7(a)显示了一个用于评估三个连接子的示例时间线</p>\n<p>我们将将Si计算为Teval(Si)的<strong>经过时间</strong>，以及<strong>对其结果进行排序</strong>的经过时间表示为Tsort(Si)。</p>\n<p>我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)&lt;Teval(Sj)(i&lt;j)。经过时间按ij递增</p>\n<p><strong>步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。</strong></p>\n<p>步骤5根据全局顺序对每个结果进行排序，</p>\n<p>步骤6在时间t2时使用<strong>第2节2.2中所述的TJ(Tributary Join)算法</strong>完成。</p>\n<p>我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)&gt;TSort(Si)或Teval(Si)&lt;Tsort(Si)。</p>\n<p>时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5-自动连接处理方法和优化方法，提供查询性能\"><a href=\"#5-自动连接处理方法和优化方法，提供查询性能\" class=\"headerlink\" title=\"5 自动连接处理方法和优化方法，提供查询性能\"></a>5 自动连接处理方法和优化方法，提供查询性能</h3><p>在本节中，我们将介绍SPRINTER的n连接处理方法。</p>\n<p>我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。</p>\n<ul>\n<li>步骤1：逐个评估{S1、·、·、Sn}。 Si为连接子树</li>\n<li>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</li>\n<li>步骤3：<strong>估计连接变量的每个全局顺序的成本</strong>。 </li>\n<li>步骤4：选择最佳的全局变量顺序。</li>\n<li>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</li>\n<li>第6步：在n个已排序的关系上合并连接。</li>\n</ul>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！</p>\n<p>对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。</p>\n<p>步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。</p>\n<p>朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠</p>\n<p>因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。</li>\n</ul>\n<p> <strong>图7(b)显示了修改后的方法的时间线。</strong></p>\n<p>步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)<strong>。因为先计算 ，就达不到评估和排序的重叠效果</strong></p>\n<p>在步骤3中，它重叠了使用<strong>CPU评估S</strong>i，并使用GPU(i，j)对<strong>Sj</strong>的结果进行排序。</p>\n<p>在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变<strong>（箭头的总长度没有改变）</strong></p>\n<p>我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。</p>\n<p><strong>由于SPRINTER可以同时使用CPU和GPU，</strong>并且同时使用流水线技术，在评估si的时候，排序sj，我们假设s1,s2,s3分别为gpu一次可处理数据大小的1倍，2倍，3倍。</p>\n<p>图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<h3 id=\"确定全局顺序\"><a href=\"#确定全局顺序\" class=\"headerlink\" title=\"确定全局顺序\"></a>确定全局顺序</h3><p>一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。</p>\n<p>本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg\"></p>\n<p>给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备三个变量的组合&lt;w,|Ew|,Cw&gt;</p>\n<p>w是一个连接变量，Ew是w的连接条件数，Cw是w连接的约束的数量，Cw是关系中有w的数量，</p>\n<p>图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg\"></p>\n<p>对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。</p>\n<p>然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。</p>\n<p>则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。</p>\n<p>则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。</p>\n<p>直观地，算法选择<strong>具有更多连接条件</strong>和<strong>可能有更多元组</strong>作为<strong>更高优先级处理的连接变量</strong>，以减少对<strong>排序关系进行二分搜索</strong>的总量。</p>\n<h4 id=\"5-2-排序策略\"><a href=\"#5-2-排序策略\" class=\"headerlink\" title=\"5.2 排序策略\"></a>5.2 排序策略</h4><p>三个因素：<strong>GPU的可用性</strong>，<strong>待排序的数据量的大小</strong>，<strong>数据字段的量</strong>，</p>\n<p>如果GPU不可用，则sprinter使用cpu非比较排序number of sorting columns is only one，</p>\n<p>其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较或基于比较的GPU排序算法，具体取决于<strong>排序列的数量</strong>。</p>\n<p>第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择</p>\n<p>一个排序算法 <strong>GPU排序缺乏良好实现的问题</strong></p>\n<p>GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg\"></p>\n<p>如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。<strong>类似外部排序</strong></p>\n<p>用GPU排序，再用cpu合并比很多情况下都要慢。<strong>因此我们直接用cpu比较排序</strong>。</p>\n<p> If a relation has only a single sorting column,we just use heterogeneous sorting in Section 2.1 since there is a very fast implementation of a non-comparison based algorithm for GPU, and <strong>the cost of merging subarrays is not so large.</strong> </p>\n<h4 id=\"合并加入排序-排序啥？\"><a href=\"#合并加入排序-排序啥？\" class=\"headerlink\" title=\"合并加入排序 排序啥？\"></a>合并加入排序 排序啥？</h4><p>item、cust和ticket表示为i、c和 t</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg\"></p>\n<p>如果4放在最后面，是不是代价就会少很多？</p>\n<h4 id=\"进行查询优化的成本模型\"><a href=\"#进行查询优化的成本模型\" class=\"headerlink\" title=\"进行查询优化的成本模型\"></a>进行查询优化的成本模型</h4><p>我们认为查询计划 P old 由 M-1 个二元连接运算符组成</p>\n<p>使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。</p>\n<p>因此，我们建立了成本模型成本(PNew)和成本(P old)，以确定成本(Pnew)&lt;成本(Pold)。</p>\n<p>我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。</p>\n<p> <strong>Cost model of the base system</strong></p>\n<p>We consider that a query plan <em>P**old</em> consists of <em>M</em> M 1 binary join operators for <em>M</em> relations.</p>\n<p>我们考虑PK-FK连接或FK-FK连接的<strong>每个二进制连接运算符都使用主内存哈希连接算法</strong>进行计算，该算法不仅在OmniSci[33]（GPU）排序中很常见，而且在其他内存查询中也很常见 处理系统</p>\n<p> 我们假设查询处理探测<strong>最左关系的每个元组</strong>，</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg\"></p>\n<p>EQ3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数，EQ4</p>\n<p>探测(F1)探测元组的成本函数 F1 EQ5</p>\n<p>我们可以假设F1的每个元组都与F2的哈希表中的dup2元素进行比较，而不管哈希表的类型如何（例如，开放寻址、单独的链接）。</p>\n<p>谓词：属于函数的一种，但其返回值是真值(true/false/unknown) </p>\n<h4 id=\"SPRINTER的成本模型\"><a href=\"#SPRINTER的成本模型\" class=\"headerlink\" title=\"SPRINTER的成本模型\"></a>SPRINTER的成本模型</h4><p>一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。</p>\n<p>我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。</p>\n<p>Eq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg\"></p>\n<p>如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg\"></p>\n<h3 id=\"7-介绍了实验评价的结果\"><a href=\"#7-介绍了实验评价的结果\" class=\"headerlink\" title=\"7 介绍了实验评价的结果\"></a>7 介绍了实验评价的结果</h3><p><strong>SPRINTER</strong>与<strong>现有的OLAP查询处理系统</strong>所经过的复杂OLAP查询时间i进行比较,in the TPC-DS benchmark</p>\n<p>。详细地，我们通过实证验证了选择第5节中描述的排序算法的策略，</p>\n<p>在第6节中提出的成本模型，以及排序算法的性能。</p>\n<h5 id=\"实验设置\"><a href=\"#实验设置\" class=\"headerlink\" title=\"实验设置\"></a>实验设置</h5><p>查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]</p>\n<p>环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，</p>\n<p>512GB主存和一个11GB的NVIDIAGTX1080TiGPU。 操作系统OS7.5</p>\n<p>系统比较：与sprinter系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg\"></p>\n<p>对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，</p>\n<p>这类似于System-X。但是，它生成了一个二进制（更加平衡的树，区别于作深树）的查询计划，这是与System-x的主要区别之一。</p>\n<p>此外，<strong>Sys tem-Y以流水线的方式处理查询计划</strong>，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。</p>\n<p>using only CPU as SPRINTER(C) and the one of SPRINTER</p>\n<p>using both CPU and GPU as SPRINTER(G). </p>\n<p>我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。</p>\n<p>此外，sprinter(C)和sprinter(G)的大多数查询的性能都优于所有系统，这是由于它们不同的查询计划和不同的连接处理</p>\n<p>对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍</p>\n<p>SPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。</p>\n<p>We note that the current SPRINTER does not use ad\u0002vanced query optimization techniques that System-X and System-Y use, since its base system, OmniSci, does not sup\u0002port them yet. Thus, the performance of SPRINTER can be further <strong>improved by applying the optimization techniques</strong> to OmniSci or SPRINTER.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg\"></p>\n<p>对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理时有更多的故障，通常性能更差。</p>\n<p>这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。</p>\n<p>然而，图11中的TPC-DS查询通常具有较低的fi值（即，接近于0），因此，Sissem-X配备了支持索引驱动的查询执行和查询优化技术 执行OmniSci。 fi是什么</p>\n<p>对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。</p>\n<p>相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表<br>EXPERIMENTAL EVALUATION</p>\n<h3 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h3><h3 id=\"总结全文\"><a href=\"#总结全文\" class=\"headerlink\" title=\"总结全文\"></a>总结全文</h3><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。</p>\n<p>它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的<strong>传统的左深二进制连接树</strong></p>\n<p>该计划可以通过将事实表格上的<strong>FK-FK连接</strong>放入一个n-ary连接操作符中，从而<strong>显著降低探测成本</strong>。</p>\n<p>We also have proposed an effi\u0002cient <em>n</em>-ary join processing method which is based on the TJ algorithm and heuristic algorithm selecting a good global variable order. </p>\n<p>我们提出的sprinter已经可以集成到开源的内存OLAP系统，OmniSci，跨所有相关的层和模块。</p>\n<p>通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。</p>\n<p>算法执行过程：</p>\n<p>算法1，确定了一个核心子图，然后对它的非核心子图一般是维表进行遍历，最后计算事实表的计算，尽量减少中间连接操作形成的结果量</p>\n<p>算法2就是算法1的推广，有多个核心子图，对它进行遍历</p>\n<p>=======</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>659ab8ab41e0f048755673e552dec5884206a142<br>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好</p>\n<h2 id=\"pre要求\"><a href=\"#pre要求\" class=\"headerlink\" title=\"pre要求\"></a>pre要求</h2><p>全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。</p>\n<p>要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。</p>\n<p>ppt的讲诉，不能太长，要突出重点，</p>\n<p>讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。</p>\n<h2 id=\"论文选题\"><a href=\"#论文选题\" class=\"headerlink\" title=\"论文选题\"></a>论文选题</h2><p>相比研究之前的skyline，我更希望看点对我有用的东西，</p>\n<p>所以我准备选取数据库方向的文章。</p>\n<p>SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020</p>\n<p>离谱，wps新版的划词翻译的地方还不好找，<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg\"></p>\n<p>如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。</p>\n<p>短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法<br>复杂OLAP查询的快速n元连接查询处理方法</p>\n<h1 id=\"lt-lt-lt-lt-lt-lt-lt-HEAD\"><a href=\"#lt-lt-lt-lt-lt-lt-lt-HEAD\" class=\"headerlink\" title=\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><h5 id=\"超键-super-key-在关系中能唯一标识元组的属性集称为关系模式的超键\"><a href=\"#超键-super-key-在关系中能唯一标识元组的属性集称为关系模式的超键\" class=\"headerlink\" title=\"超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键\"></a>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键</h5><h5 id=\"候选键-candidate-key-不含有多余属性的超键称为候选键\"><a href=\"#候选键-candidate-key-不含有多余属性的超键称为候选键\" class=\"headerlink\" title=\"候选键(candidate key):不含有多余属性的超键称为候选键\"></a>候选键(candidate key):不含有多余属性的超键称为候选键</h5><h5 id=\"主键-primary-key-用户选作元组标识的一个候选键程序主键\"><a href=\"#主键-primary-key-用户选作元组标识的一个候选键程序主键\" class=\"headerlink\" title=\"主键(primary key):用户选作元组标识的一个候选键程序主键\"></a>主键(primary key):用户选作元组标识的一个候选键程序主键</h5><p><strong>外键 (FK)</strong> 是用于建立和加强两个表数据之间的链接的<strong>一列</strong>或<strong>多列</strong></p>\n<p>通过将保存表中主键值的一列或多列添加到另一个表中，可创建两个表之间的链接。这个列就成为第二个表的外键。</p>\n<p><strong>一张表外键的值一般来说是另一张表主键的值。因此，外键的存在使得表与表之间可以联系起来</strong></p>\n<p>FOREIGN KEY 约束防止这种情况的发生。如果主键表中数据的更改使之与外键表中数据的链接失效，则这种更改是不能实现的，从而确保了引用完整性。如果试图删除主键表中的行或更改主键值，而该主键值与另一个表的 FOREIGN KEY 约束值相关，则该操作不可实现。若要成功更改或删除FOREIGN KEY 约束的行，可以先在外键表中删除外键数据或更改外键数据，然后将外键链接到不同的主键数据上去。</p>\n<p><strong>OLAP</strong>联机分析处理是一种软件技术，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。</p>\n<p>随着市场竞争的日趋激烈，企业更加强调决策的及时性和准确性，这使得以<strong>支持决策管理分析</strong>为主要目的的应用迅速崛起，这类应用被称为<strong>联机分析处理</strong>，它所存储的数据被称为信息数据。</p>\n<p>数据仓库：数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），<strong>支持复杂的分析操作，侧重决策支持，并且提供直观易懂</strong>的查询结果。</p>\n<p>基本每家电商公司都会经历，从只需要业务数据库到要数据仓库的阶段。</p>\n<ul>\n<li>电商早期启动非常容易，入行门槛低。找个外包团队，做了一个可以下单的网页前端 + 几台服务器 + 一个MySQL，就能开门迎客了。这好比手工作坊时期。</li>\n<li>第二阶段，流量来了，客户和订单都多起来了，普通查询已经有压力了，这个时候就需要升级架构变成<strong>多台服务器</strong>和多个业务数据库（<strong>量大+分库分表</strong>），这个阶段的业务数字和指标还可以勉强从业务数据库里查询。初步进入工业化。</li>\n<li>第三个阶段，一般需要 3-5 年左右的时间，随着业务指数级的增长，数据量的会陡增，公司角色也开始多了起来，开始有了 CEO、CMO、CIO，大家需要面临的问题越来越复杂，越来越深入。高管们关心的问题，从最初非常粗放的：“昨天的收入是多少”、“上个月的 PV、UV 是多少”，逐渐演化到<strong>非常精细化</strong>和<strong>具体的用户的集群分析</strong>，特定用户在某种使用场景中，例如“20~30岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系”。</li>\n</ul>\n<p>这类非常具体，且能够对公司决策起到关键性作用的问题，基本很难从业务数据库从调取出来。原因在于：</p>\n<ol>\n<li>业务数据库中的数据结构是<strong>为了完成交易而设计</strong>的，不是为了而查询和分析的便利设计的。</li>\n<li>业务数据库大多是<strong>读写优化的</strong>，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。</li>\n</ol>\n<p>而怎么解决这个问题，此时我们就需要建立一个数据仓库了，公司也算开始进入信息化阶段了。数据仓库的作用在于：</p>\n<ol>\n<li>数据结构为了分析和查询的便利；</li>\n<li>只读优化的数据库，即<strong>不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。</strong></li>\n</ol>\n<p>数据库 比较流行的有：MySQL, Oracle, SqlServer等</p>\n<p>数据仓库 比较流行的有：AWS Redshift, Greenplum, Hive等</p>\n<p><strong>本OLAP查询</strong>，基于成本模型 生成包含 <strong>n 元连接运算符</strong>的 查询计划。</p>\n<p><strong>+：a+b所以‘+’就是二元运算符。<br>++：a++所以++就是一元运算符。</strong></p>\n<p>n元就是n个元素，n个表做连接运算</p>\n<h3 id=\"本文结论：SPRINTER-的性能优于最先进的-OLAP-系统。\"><a href=\"#本文结论：SPRINTER-的性能优于最先进的-OLAP-系统。\" class=\"headerlink\" title=\"本文结论：SPRINTER 的性能优于最先进的 OLAP 系统。\"></a>本文结论：SPRINTER 的性能优于最先进的 OLAP 系统。</h3><p>keywords: n元连接运算符，查询规划，查询优化，FK-FK连接，复杂OLAP查询处理，协同处理</p>\n<p>现有系统利用了各种技术，例如中间结果的流水线</p>\n<p>OLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学</p>\n<p>In particular, the number of queries which</p>\n<p>contain join operations between a pair of foreign (or non\u0002</p>\n<p>unique) keys rather than a conventional pair of primary and</p>\n<p>foreign keys increases in the applications. </p>\n<p>!尤其是，查询的数量<strong>包括了外键之间的连接操作</strong>，而不是增加在应用程序的<strong>传统主键和外键</strong></p>\n<p>本文将这种连接操作表示为FK-FK连接，一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。</p>\n<p><strong>流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。</strong></p>\n<p>!它可能对PK-FK连接的查询有效，但对于<strong>事实表中包含FK-FK连接的复杂查询</strong>可能无效</p>\n<p><strong>内连接</strong>实际上就是利用 <strong>where 子句</strong>对两张(多表)表形成的笛卡尔积进行筛选,<strong>我们前面学习的查询都是内连接,也是在开发过程中用的最多的连接查询。</strong></p>\n<p><strong>外连接，如果是全外连接，左*右含有的行</strong> </p>\n<p>数据库视图：</p>\n<p>视图是一种<strong>虚拟</strong>的表（逻辑表），具有和<strong>物理表</strong>相同的功能。<br>可以对视图进行<strong>增，改，查</strong>，操作，<br>试图通常是有<strong>一个表或者多个表的行或列的子集</strong>。<br>对视图的修改<strong>不影响</strong>基本表。<br>它使得我们获取数据<strong>更容易</strong>，相比多表查询</p>\n<p>视图是一个虚拟表，<strong>其查询的数据来自于视图定义时的 as select xx 查询语句</strong>。视图的列来自于一个表或多个表，所以视图不可以和表名重名。<br>数据多用作查询，一般不会通过视图去修改数据。</p>\n<p><strong>!因为存在以下两个问题：</strong>许多key比较 以及大量的内存使用量。</p>\n<p>首先，探测关系中每个元组的连接键值需要与哈希表中的<strong>所有重复键值相匹配</strong>。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。</p>\n<p>n元连接操作和二元连接操作相比，可以减少中间结果数量，大多数情况下更有效，</p>\n<p><strong>多路连接处理</strong>(归并？）已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 ，<strong>因为在内存内的处理环境中，哈希连接通常优于归并排序连接</strong>，并且不同于OLAY图形模式查询，OLAY查询是ad-hoc(点对点)和acyclic(无环)；</p>\n<p>!我们提出了一种方法，可以生成n元连接的查询，而不是传统的二元操作，</p>\n<p>生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，相比较二元 搜索空间变得更大，</p>\n<p>我们<strong>提出了所使用的成本模型</strong>和一种<strong>查询优化方法 t</strong>允许查询规划方法</p>\n<p>!实际应用环境很少 出现简单的二元连接,而<strong>更多的是复杂的多元连接</strong>(multi-mays join)</p>\n<p>n 元连接可以以多种方式分解成 n−1 个二 元连接，每二元连接又可以采用多种算法,因此存在大量执行计划。</p>\n<p>!算法代价以 I/O 为主,<strong>CPU 因等待 I/O 而空闲</strong>,因此,优化连接 <strong>性能最有效的方法是减少 I/O 操作</strong></p>\n<p><strong>等值连接</strong>与<strong>自然连接</strong>是应用最广泛的连接操作,自然连接与等值连接无本质区别,可以通过修改属性名把 等值连接操作转化为自然连接操作,所以研究自然连接具有普遍意义.本节以自然连接(ڇ(为例,设 R 和 S 是两个 数据集,attr(⋅)表示数据集的属性集</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtaut6tcsnj31160nuadm.jpg\"></p>\n<h3 id=\"与等值连接的区别\"><a href=\"#与等值连接的区别\" class=\"headerlink\" title=\"与等值连接的区别\"></a>与等值连接的区别</h3><p>\\1. 等值连接中不要求属性值完全相同，而自然连接要求两个关系中进行比较的必须是相同的属性组（属性名可以不同），即要求必须有相同的值域。</p>\n<p>\\2. 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接（如图所示）</p>\n<p>!由于连接运算结果是确定的,因此无论采用何种顺序执行多元连接,<strong>结果集大小是一致的</strong>.因此,我们需找 到这些执行计划中 <strong>I/O 代价最小的作为最优执行计划.</strong></p>\n<p>较直接的算法为逐一计算每个执行计划的 I/O 代价,搜索 I/O 代价最小的执行计划</p>\n<p>首先,对于任意一个执行计划,需要逐一计算 SiڇSj 的结果集大小Φij 和 6 种算法的 I/O代价,选取 I/O 代价最小的算法作为 SiڇSj 的执行算法.那么对于一个 n 元连接的执行计划选择,至少要计算<img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtauvy654lj308002cdfq.jpg\"></p>\n<p>次连接代价。并在这么多代价里面搜索最小代价。</p>\n<p>只有在与传统的二进制左深连接树相比<strong>有益时</strong>才生成n-ary连接树</p>\n<p>保证 多作业的并行性同时会降低每个作业的并行性,多作业并行并没有带来额外的性能提升</p>\n<p>若 I/O 密集型和 CPU 密集型作业并行执行,则有助于提高资源利用率,提高性能</p>\n<p>若多个 I/O 密集型作业并行执行,每个作业需要 的资源不能互补,而且会争抢 I/O 资源</p>\n<p>FK总是和PK相连接<br>当两个表中间有了PK-FK连接，那么这两个表就有了关系</p>\n<p>单向连接啥基于最坏情况最优连接算法， the worst\u0002 case optimal join algorithm，</p>\n<p>we have demonstrated that SPRINTER significantly outperforms the state-of-the-art OLAP query processing systems in terms of both processing speed and data size that can be <strong>processed without our of memory</strong>.</p>\n<p>我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以在内存不溢出的情况下处理</p>\n<p>本文贡献如下：</p>\n<ul>\n<li>我们提出了一种查询方法，可以生成复杂的OLAY查询的n元连接树包含FK-FK</li>\n<li>我们提出了成本模型和查询优化n路连接树的方法</li>\n<li>n元n路处理方法：基于最坏情况最优连接算法</li>\n<li>我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。</li>\n<li>在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。</li>\n</ul>\n<h3 id=\"2-2-sprinter-中使用最坏情况下最优连接算法\"><a href=\"#2-2-sprinter-中使用最坏情况下最优连接算法\" class=\"headerlink\" title=\"2.2 sprinter 中使用最坏情况下最优连接算法\"></a>2.2 sprinter 中使用最坏情况下最优连接算法</h3><p>当n-ary连接操作符的输入大小非常大时，使用<strong>GPU进行排序</strong>可以进一步提高查询性能。因此，SPRINTER使用不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。</p>\n<p>!<strong>表1中基于比较的算法</strong>意味着，它们需要在排序的key值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n。它们不需要这样的比较来进行排序（例如，radix排序。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.logN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。</p>\n<p><strong>在那个case，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。</strong></p>\n<p>we assume that <em>X</em> is too large to fit in GPU memory, and so, we need to split it into six subar\u0002 rays {<em>X</em>1, · · · ,<em>X</em>6}. </p>\n<p>虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。</p>\n<p>异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本。 y尽可能通过重叠<strong>三种低级GPU操作</strong>，<strong>H2D拷贝</strong>、<strong>radix排序</strong>和<strong>D2H拷贝</strong>。</p>\n<p>两两合并成一个新的这下一个x2   <strong>在x1排序的时候对x2进行排序</strong></p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E8%B0%A2%E5%B8%8C%E7%A7%91%E8%80%81%E5%B8%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%89%8D%E6%B2%BF%E8%AF%BE%E7%9A%84%E8%AE%BA%E6%96%87pre.assets/image-20210805223429708.png\" alt=\"image-20210805223429708\"></p>\n<h4 id=\"最坏情况最优连接算法\"><a href=\"#最坏情况最优连接算法\" class=\"headerlink\" title=\"最坏情况最优连接算法\"></a>最坏情况最优连接算法</h4><p>通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询），一些算法[1,31,44]<strong>需要对输入关系和存储进行预处理，预处理作为数据结构的结果，如B+-tree，</strong></p>\n<p>![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)</p>\n<p>当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二分查找，因此，单个搜索的成本是O(logN),如果一个查询有L个连接变量，<strong>则可能的全局变量顺序的数量为L！，排列组合</strong>。 虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于<strong>每个变量顺序的搜索成本不同</strong>IO成本，可能远非最优。因此，<strong>TJ估计每个可能顺序的连接处理成本</strong>（这就是TJ），并选择最好的顺序。</p>\n<h3 id=\"3-一个激励例子\"><a href=\"#3-一个激励例子\" class=\"headerlink\" title=\"3 一个激励例子\"></a>3 一个激励例子</h3><p>在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS(?)基准数据库[30]上的一个查询，<strong>广泛用于t 测试OLAP系统[18]的查询性能</strong>。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点<strong>关注连接</strong>操作。图3显示了的连接图 该查询包含蓝色矩形的<strong>三个事实表{SS、SR、CS}</strong> （事实表，记录具体事件，如用户交易流水表）和绿色矩形的<strong>三维表{D、I、C}<strong>。（每个维度可能包含多个属性 比如时间维度看有插入时间 更新时间）为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有</strong>2个FK-FK连接</strong>操作，<strong>绿线有5个PK-FK连接</strong>操作。 外键连接越少越好？</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg\"></p>\n<p>图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。 </p>\n<p>系统-x是一个功能齐全的最先进的商业化的<strong>内存数据库系统</strong>,支持<strong>索引驱动</strong>的查询执行和查询优化技术，如bloom过滤器和自适应连接。</p>\n<p>在图4(a)中，它为查询计划生成一个<strong>左深连接树</strong>相当于从左到右顺序结合，并以操作员一次<strong>操作的方式</strong>执行该计划。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p><strong>C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。</strong>【？】</p>\n<p>2.23B就是22.3亿</p>\n<p>图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数</p>\n<p>因为连接操作是FK-FK连接，并且在哈希表中有许多<strong>重复的键值</strong>，所以num 在<strong>探测连接</strong>过程中，哈希表中的key值被访问，我们称之为<strong>探测成本</strong>，这是探测成本，特别是160.9B倍。</p>\n<p>OmniSci[33]是一个开源的<strong>协同处理数据库系统</strong>，其中协同处理意味着<strong>同时</strong>利用<strong>cpu</strong>和<strong>gpu</strong>进行查询处理。</p>\n<p>如图b,它生成了一个左深连接的查询计划和a一样。</p>\n<p>但是是以<strong>非阻塞</strong>和<strong>流水线的方式</strong>执行计划，它<strong>不会生成和存储</strong>要连接的<strong>中间结果</strong>。</p>\n<p>详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。</p>\n<p>图b中SS和SR的第一个连接 ，<strong>对SS的每一个元祖依次探测SR的29M元祖，即暴力遍历</strong>、，哪个探测成本变成了4.1亿美元。</p>\n<p>然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B.</p>\n<p>我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.</p>\n<p>SPRINTER是系统原型，即我们提出的一种集成了跨所有相关层和模块无缝集成到OmniSci中的方法。</p>\n<p>我们选择OmniSci作为SPRINTER的基础系统，因为它是最先进的开源现代数据库系统</p>\n<p>虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。</p>\n<p>如图c，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。</p>\n<p>它分别执行三个连接子树，</p>\n<ul>\n<li>S1={SS、C1、D， I}</li>\n<li>S2={SR、C2}</li>\n<li>S3={CS、C3}</li>\n</ul>\n<p>像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。</p>\n<p>当我们计算时 S1、S2、S3的探针总成本仅为758M</p>\n<p>此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.</p>\n<p>总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。</p>\n<p>图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。</p>\n<p>性能结果表明，OmniSci通过流水线方式消除了单个大块的连接，</p>\n<p>SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 通过将单个大的连接树分割成多个较小的连接子树，并对连接子树的结果执行n个连接。</p>\n<h3 id=\"4-n个连接树的查询规划方法\"><a href=\"#4-n个连接树的查询规划方法\" class=\"headerlink\" title=\"4 n个连接树的查询规划方法\"></a>4 n个连接树的查询规划方法</h3><p>我们首先将在第4.1节中介绍用于生成包含<strong>单个n-ary连接操作符</strong>的查询计划的查询规划方法。然后，我们将该方法<strong>推广</strong>到更复杂的查询中，这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。</p>\n<p>我们考虑一个来自给定查询Q的连接图</p>\n<p>查询Q的连接图G=(V、E、f(v∈V)、g(e∈E)、h(e∈E))是一个无向多重图。</p>\n<p>顶点v∈V表示Q中连接的关系，</p>\n<p>边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。</p>\n<p>有三个标记功能f(v)、g(e)和h(e)。</p>\n<p>函数f(v)返回 关系v的类型，即事实或维数，</p>\n<p>函数g(e）连接操作的类型，即PK-FK或FK-FK，</p>\n<p>以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).</p>\n<p>在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图<strong>表示为核心子图</strong></p>\n<p>连接图G的核心子图，即核心=(Vc，Ec)⊆G，<strong>s.t.是subject to 的缩写，表示约束条件。在。。。的情况下</strong>。</p>\n<p>其中任何两个顶点X和Y在X∈Vc和Y∈Vc的情况下，通过as连接 <em>E**X</em>,<em>Y</em> ⊆ <em>E<strong>c</strong>E**c</em> s.t. <em>g</em>(<em>e</em> ∈ <em>E**X</em>,<em>Y</em> )</p>\n<p>= FK-FK, <em>f</em> (<em>X</em>) = <em>f act</em> and <em>f</em> (<em>Y</em>) = <em>f act</em>.</p>\n<p>在图3中，一个子图{SS，SR，CS}是一个核心子图，因为<strong>所有的顶点都是事实表</strong>，</p>\n<p>事实数据表是包含描述业务内特定事件的数据。是发生在现实世界中的操作型事件所产生的可度量数据，<strong>通常包含大量的行。</strong>日常查询请求的主要目标就是基于事实表展开计算和聚合操作。<br>从最低粒度级别来看，事实表行对应一个度量事件，也可以说，一个度量事件必然对应一个最低粒度的事实行为。</p>\n<p>我们认为的一行数据是什么样的，粒度。</p>\n<p>事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与维度表中对应项的相关索引字段除外的任何数据。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>​                                            图5：激励性查询的分解。</p>\n<p>如果一个连接图G只有<strong>一个</strong>核心子图<strong>核心</strong>，那么我们可以将G分解为核心子图核心和一组彼此在<strong>边不相交的非核心子图</strong>。</p>\n<p>我们就可以使用r 将上述两种分解方法分别表示为D1={core、G1、G2、G3}和D2={core、G1}。</p>\n<p>算法1提供了仅包含单个核心子图的查询的基本查询规划方法。</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>这种方法背后的直觉是使一个<strong>核心子图</strong>成为一个<strong>查询计划</strong>和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。</p>\n<h4 id=\"4-3-搜索空间\"><a href=\"#4-3-搜索空间\" class=\"headerlink\" title=\"4.3 搜索空间\"></a>4.3 搜索空间</h4><p>分解的数量取决于选择哪个核心子图作为根节点，我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图。</p>\n<p>计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtc3zlb5u1j30uo074dfy.jpg\"></p>\n<p>如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划</p>\n<p>对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)<strong>非核心子图</strong> hs</p>\n<p>对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的</p>\n<p>=======<br>这种方法背后的直觉是使一个<strong>核心子图</strong>成为一个<strong>查询计划</strong>和mak<strong>的root</strong>根节点 用非核心子图表示查询计划中的根节点的子节点。用非核心子图表示查询计划中的根节点的<strong>子节点。</strong></p>\n<p>**从每个分解Di中生成一个查询计划Pi 3-9)**从每个分解Di中生成一个查询计划Pi 3-9)从每个分解Di中生成一个查询计划Pi 3-9)</p>\n<p>当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。</p>\n<p>！！我们只考虑为一个<strong>非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间</strong>。前面有证明，至于为什么 需要搞一搞</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p>图b为左深二元连接树</p>\n<p>将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。</p>\n<p>背后的直觉是 通过在查询计划的最后一步<strong>处理事实表上的FK-FK连接</strong>，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<p><strong>代码5-7对于每一个分解方法Di计算代价，第九行做排序</strong></p>\n<p>第11行选择最好的方案，</p>\n<p>背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg\"></p>\n<p>图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。</p>\n<p>图6中的每个二进制连接运算符都对应于一条绿色的边</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg\"></p>\n<p>相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>For example, <em>C</em> appears three times in Figure 6(a) since it is shared among three subgraphs {<em>G</em>1,<em>G</em>2,<em>G</em>3}三种颜色 in Figure 5.</p>\n<p>When comparing two query plans in Figure 6, we can say the plan <em>P</em>1 就是D1 usually has a lower cost than the plan <em>P</em>2 since <em>P</em>1 scans a dimension table <em>C</em> two more times, whereas <em>P</em>2 scans two fact tables <em>SR</em> and <em>CS</em> one more time.</p>\n<h4 id=\"4-2-针对激励性查询的查询计划\"><a href=\"#4-2-针对激励性查询的查询计划\" class=\"headerlink\" title=\"4.2 针对激励性查询的查询计划\"></a>4.2 针对激励性查询的查询计划</h4><p>我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。这种查询的一种朴素的查询规划方法是将连接图中的特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。</p>\n<p>一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。</p>\n<p><strong>我们只需要进行修改算法1中的第6行。</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg\"></p>\n<p>Ndcmp 是以ci为子图核心时，分解数，Ncore个核心子图，</p>\n<p>如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。</p>\n<p>对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，Nsubg(Dj)非核心子图，</p>\n<p>in Figure 6,</p>\n<p>*Nsubg(<em>D</em>1) = 3, and *Nsubg(<em>D</em>2) = 1.</p>\n<p><strong>对于每个子图Gk，都存在Nrecur(Gk)查询计划。</strong></p>\n<p>因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq.2</p>\n<p><img src=\"C:\\Users\\wzr\\Desktop\\myblog\\source_posts\\谢希科老师数据库前沿课的论文pre\\008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。</p>\n<p>我们不考虑连接子树之间的顺序，因为<strong>总处理时间 连接子树是相同的</strong>，不管顺序如何。</p>\n<h2 id=\"5-n-ARY-JOIN处理方法\"><a href=\"#5-n-ARY-JOIN处理方法\" class=\"headerlink\" title=\"5 n-ARY JOIN处理方法\"></a>5 n-ARY JOIN处理方法</h2><p>在本节中，我们将介绍SPRINTER的n连接处理方法。</p>\n<p>我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法</p>\n<p>请执行以下六个步骤。</p>\n<ul>\n<li>步骤1：逐个评估{S1、·、·、Sn}。Si为连接子树</li>\n<li>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</li>\n<li>步骤3：估计连接变量的每个全局顺序的成本。 </li>\n<li>步骤4：选择最佳的全局变量顺序。</li>\n<li>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</li>\n<li>第6步：在n个已排序的关系上合并连接。</li>\n</ul>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！</p>\n<p>在原则上。我们假设n个连接运算符的子级从左到右计算。</p>\n<p>对于朴素方法，无论处理子节点的顺序如何，处理n-ary连接运算符的时间都变得相同</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<p>图7(a)显示了一个用于评估三个连接子树的示例时间线.</p>\n<p>我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。</p>\n<p>图7(a)显示了一个用于评估三个连接子的示例时间线</p>\n<p>我们将将Si计算为Teval(Si)的<strong>经过时间</strong>，以及<strong>对其结果进行排序</strong>的经过时间表示为Tsort(Si)。</p>\n<p>我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)&lt;Teval(Sj)(i&lt;j)。经过时间按ij递增</p>\n<p><strong>步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。</strong></p>\n<p>步骤5根据全局顺序对每个结果进行排序，</p>\n<p>步骤6在时间t2时使用<strong>第2节2.2中所述的TJ(Tributary Join)算法</strong>完成。</p>\n<p>我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)&gt;TSort(Si)或Teval(Si)&lt;Tsort(Si)。</p>\n<p>时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5-自动连接处理方法和优化方法，提供查询性能\"><a href=\"#5-自动连接处理方法和优化方法，提供查询性能\" class=\"headerlink\" title=\"5 自动连接处理方法和优化方法，提供查询性能\"></a>5 自动连接处理方法和优化方法，提供查询性能</h3><p>在本节中，我们将介绍SPRINTER的n连接处理方法。</p>\n<p>我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。</p>\n<ul>\n<li>步骤1：逐个评估{S1、·、·、Sn}。 Si为连接子树</li>\n<li>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</li>\n<li>步骤3：<strong>估计连接变量的每个全局顺序的成本</strong>。 </li>\n<li>步骤4：选择最佳的全局变量顺序。</li>\n<li>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</li>\n<li>第6步：在n个已排序的关系上合并连接。</li>\n</ul>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！</p>\n<p>对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。</p>\n<p>步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。</p>\n<p>朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠</p>\n<p>因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。</li>\n</ul>\n<p> <strong>图7(b)显示了修改后的方法的时间线。</strong></p>\n<p>步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)<strong>。因为先计算 ，就达不到评估和排序的重叠效果</strong></p>\n<p>在步骤3中，它重叠了使用<strong>CPU评估S</strong>i，并使用GPU(i，j)对<strong>Sj</strong>的结果进行排序。</p>\n<p>在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变<strong>（箭头的总长度没有改变）</strong></p>\n<p>我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。</p>\n<p><strong>由于SPRINTER可以同时使用CPU和GPU，</strong>并且同时使用流水线技术，在评估si的时候，排序sj，我们假设s1,s2,s3分别为gpu一次可处理数据大小的1倍，2倍，3倍。</p>\n<p>图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<h3 id=\"确定全局顺序\"><a href=\"#确定全局顺序\" class=\"headerlink\" title=\"确定全局顺序\"></a>确定全局顺序</h3><p>一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。</p>\n<p>本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg\"></p>\n<p>给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备三个变量的组合&lt;w,|Ew|,Cw&gt;</p>\n<p>w是一个连接变量，Ew是w的连接条件数，Cw是w连接的约束的数量，Cw是关系中有w的数量，</p>\n<p>图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg\"></p>\n<p>对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。</p>\n<p>然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。</p>\n<p>则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。</p>\n<p>则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。</p>\n<p>直观地，算法选择<strong>具有更多连接条件</strong>和<strong>可能有更多元组</strong>作为<strong>更高优先级处理的连接变量</strong>，以减少对<strong>排序关系进行二分搜索</strong>的总量。</p>\n<h4 id=\"5-2-排序策略\"><a href=\"#5-2-排序策略\" class=\"headerlink\" title=\"5.2 排序策略\"></a>5.2 排序策略</h4><p>三个因素：<strong>GPU的可用性</strong>，<strong>待排序的数据量的大小</strong>，<strong>数据字段的量</strong>，</p>\n<p>如果GPU不可用，则sprinter使用cpu非比较排序number of sorting columns is only one，</p>\n<p>其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较或基于比较的GPU排序算法，具体取决于<strong>排序列的数量</strong>。</p>\n<p>第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择</p>\n<p>一个排序算法 <strong>GPU排序缺乏良好实现的问题</strong></p>\n<p>GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg\"></p>\n<p>如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。<strong>类似外部排序</strong></p>\n<p>用GPU排序，再用cpu合并比很多情况下都要慢。<strong>因此我们直接用cpu比较排序</strong>。</p>\n<p> If a relation has only a single sorting column,we just use heterogeneous sorting in Section 2.1 since there is a very fast implementation of a non-comparison based algorithm for GPU, and <strong>the cost of merging subarrays is not so large.</strong> </p>\n<h4 id=\"合并加入排序-排序啥？\"><a href=\"#合并加入排序-排序啥？\" class=\"headerlink\" title=\"合并加入排序 排序啥？\"></a>合并加入排序 排序啥？</h4><p>item、cust和ticket表示为i、c和 t</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg\"></p>\n<p>如果4放在最后面，是不是代价就会少很多？</p>\n<h4 id=\"进行查询优化的成本模型\"><a href=\"#进行查询优化的成本模型\" class=\"headerlink\" title=\"进行查询优化的成本模型\"></a>进行查询优化的成本模型</h4><p>我们认为查询计划 P old 由 M-1 个二元连接运算符组成</p>\n<p>使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。</p>\n<p>因此，我们建立了成本模型成本(PNew)和成本(P old)，以确定成本(Pnew)&lt;成本(Pold)。</p>\n<p>我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。</p>\n<p> <strong>Cost model of the base system</strong></p>\n<p>We consider that a query plan <em>P**old</em> consists of <em>M</em> M 1 binary join operators for <em>M</em> relations.</p>\n<p>我们考虑PK-FK连接或FK-FK连接的<strong>每个二进制连接运算符都使用主内存哈希连接算法</strong>进行计算，该算法不仅在OmniSci[33]（GPU）排序中很常见，而且在其他内存查询中也很常见 处理系统</p>\n<p> 我们假设查询处理探测<strong>最左关系的每个元组</strong>，</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg\"></p>\n<p>EQ3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数，EQ4</p>\n<p>探测(F1)探测元组的成本函数 F1 EQ5</p>\n<p>我们可以假设F1的每个元组都与F2的哈希表中的dup2元素进行比较，而不管哈希表的类型如何（例如，开放寻址、单独的链接）。</p>\n<p>谓词：属于函数的一种，但其返回值是真值(true/false/unknown) </p>\n<h4 id=\"SPRINTER的成本模型\"><a href=\"#SPRINTER的成本模型\" class=\"headerlink\" title=\"SPRINTER的成本模型\"></a>SPRINTER的成本模型</h4><p>一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。</p>\n<p>我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。</p>\n<p>Eq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg\"></p>\n<p>如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg\"></p>\n<h3 id=\"7-介绍了实验评价的结果\"><a href=\"#7-介绍了实验评价的结果\" class=\"headerlink\" title=\"7 介绍了实验评价的结果\"></a>7 介绍了实验评价的结果</h3><p><strong>SPRINTER</strong>与<strong>现有的OLAP查询处理系统</strong>所经过的复杂OLAP查询时间i进行比较,in the TPC-DS benchmark</p>\n<p>。详细地，我们通过实证验证了选择第5节中描述的排序算法的策略，</p>\n<p>在第6节中提出的成本模型，以及排序算法的性能。</p>\n<h5 id=\"实验设置\"><a href=\"#实验设置\" class=\"headerlink\" title=\"实验设置\"></a>实验设置</h5><p>查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]</p>\n<p>环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，</p>\n<p>512GB主存和一个11GB的NVIDIAGTX1080TiGPU。 操作系统OS7.5</p>\n<p>系统比较：与sprinter系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg\"></p>\n<p>对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，</p>\n<p>这类似于System-X。但是，它生成了一个二进制（更加平衡的树，区别于作深树）的查询计划，这是与System-x的主要区别之一。</p>\n<p>此外，<strong>Sys tem-Y以流水线的方式处理查询计划</strong>，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。</p>\n<p>using only CPU as SPRINTER(C) and the one of SPRINTER</p>\n<p>using both CPU and GPU as SPRINTER(G). </p>\n<p>我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。</p>\n<p>此外，sprinter(C)和sprinter(G)的大多数查询的性能都优于所有系统，这是由于它们不同的查询计划和不同的连接处理</p>\n<p>对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍</p>\n<p>SPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。</p>\n<p>We note that the current SPRINTER does not use ad\u0002vanced query optimization techniques that System-X and System-Y use, since its base system, OmniSci, does not sup\u0002port them yet. Thus, the performance of SPRINTER can be further <strong>improved by applying the optimization techniques</strong> to OmniSci or SPRINTER.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg\"></p>\n<p>对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理时有更多的故障，通常性能更差。</p>\n<p>这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。</p>\n<p>然而，图11中的TPC-DS查询通常具有较低的fi值（即，接近于0），因此，Sissem-X配备了支持索引驱动的查询执行和查询优化技术 执行OmniSci。 fi是什么</p>\n<p>对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。</p>\n<p>相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表<br>EXPERIMENTAL EVALUATION</p>\n<h3 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h3><h3 id=\"总结全文\"><a href=\"#总结全文\" class=\"headerlink\" title=\"总结全文\"></a>总结全文</h3><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。</p>\n<p>它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的<strong>传统的左深二进制连接树</strong></p>\n<p>该计划可以通过将事实表格上的<strong>FK-FK连接</strong>放入一个n-ary连接操作符中，从而<strong>显著降低探测成本</strong>。</p>\n<p>We also have proposed an effi\u0002cient <em>n</em>-ary join processing method which is based on the TJ algorithm and heuristic algorithm selecting a good global variable order. </p>\n<p>我们提出的sprinter已经可以集成到开源的内存OLAP系统，OmniSci，跨所有相关的层和模块。</p>\n<p>通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。</p>\n<p>算法执行过程：</p>\n<p>算法1，确定了一个核心子图，然后对它的非核心子图一般是维表进行遍历，最后计算事实表的计算，尽量减少中间连接操作形成的结果量</p>\n<p>算法2就是算法1的推广，有多个核心子图，对它进行遍历</p>\n<p>=======</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>659ab8ab41e0f048755673e552dec5884206a142<br>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n"},{"layout":"sprinter：快速","title":"快速n元连接查询处理","date":"2021-07-31T11:50:46.000Z","type":"ustc","thumbnail":"https://picjumbo.com/wp-content/uploads/working-on-a-laptop-from-a-car-2210x1473.jpg","_content":"# SPRINTER：快速 n 元连接查询处理\n\n复杂 OLAP 查询的方法\n\n## 摘要\n\n​\tOLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。\n​\t在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。\n\n## 关键字\n\n​\tn连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理\n\n## **INTRODUCTION**\n\n​\t有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个\n这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。\n\n​\tOLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。\n\n​\t现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以\n\n​\t由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。\n\n​\t在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。\n\n​\t一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型 heuristic式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。\n\n​\t我们的主要贡献总结如下：\n• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。\n• 我们提出了成本模型和查询优化n路连接树的方法。\n• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。\n• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。\n• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。\n\n本文的其余部分组织如下。\n\n在**第2.2节中**，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在**第3节中**，我们将描述本文的一个激励例子。\n\n在**Secti 在4**上，我们提出了n个连接树的查询规划方法。\n\n在**第5节中**，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m\n\n第**6节中的odel**。\n\n**第7节**介绍了实验评价的结果。\n\n最后，我们在**第8节中**讨论相关的工作，\n\n并在**第9节中**总结本文。\n\n## **PRELIMINARIES**\n\n### **Sorting algorithms**\n\n在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。\n\n表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。\n\n**Table 1:**在SPRINTER中使用的并行排序算法和技术。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg)\n\n​\t大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg)\n\n​\t\t图1：异构排序[15]的时间轴。\n\n### 2.2最坏情况下的最优连接算法\n\n​\t在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。\n\n​\t图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。\n\n​\t当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。\n\n![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图2：部落连接[13]的示例。\n\n## **3 动机**\n\n​\t在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图3：激励性查询的连接图。\n\n​\t图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。\n\n​\t图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。\n\n​\tOmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.\n\n​\t短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。\n\n​\t图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。\n\n## 4查询规划方法\n\n​\t在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图4：针对激励性查询的查询计划。\n\n### 4.1单个n个连接运算符的查询\n\n​\t对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。\n\n定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).\n\n​\t在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。\n\n​\t定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。\n\n​\t在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，g(e1)= FKKFKandg(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。\n\n​\t在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。\n\n​\t如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图5：激励性查询的分解。\n\n<<<<<<< HEAD\n​\t算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的 heuristic式方法。 heuristic式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n=======\n​\t算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，**然后选择其中成本最低的最佳计划P∗（第11行）**。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg)\n\n​\t图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg)\n\n图6：针对激励性查询的查询计划。\n\n### 4.2多个n个连接运算符的查询\n\n​\t在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg)\n\n### 4.3搜索空间\n\n​\t我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg)\n\n<<<<<<< HEAD\n​\t如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)非核心子图。例如，在图6中，Nsubg(D1)=3和Nsubg(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.\n=======\nNdcmp 是以ci为子图核心时，分解数，Ncore个核心子图，\n\n如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n​\t在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。\n\n## 5n-ARY JOIN处理方法\n\n​\t在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：估计连接变量的每个全局顺序的成本。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n  对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)<Teval(Sj)(i<j)。步骤2-4在图7(a)中的时间t1时完成，**它确定了连接列之间的一定全局应用TJ算法的顺序。**步骤5 根据全局顺序对每个结果进行排序，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)>TSort(Si)或Teval(Si)<Tsort(Si)。\n\n​\t在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n​\t\t\t\t\t图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。\n\n​\t时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n\n​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)>Tsort(Si)，还是Teval，都没有改变 (Si)<Tsort(Si)。\n\n​\t我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。\n\n \t即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)>Tsort(Si)还是Teval(Si)<TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n\n### 5.1全球订单的确定\n\n​\t一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e heuristic式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种 heuristic式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg)\n\n​\t算法3展示了我们的 heuristic式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图8：TPC-DSQ17的核心子图。\n\n### 5.2排序策略\n\n​\t在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图9：排序算法的选择策略。\n\n​\t如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。\n\n​\t但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。\n\n​\t由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。\n\n### 5.3合并加入排序关系\n\n​\t对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。\n\n​\t人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg)\n\n​\t\t\t\t\t\t\t\t\t图10：图8中的核心子图的合并连接示例。\n\n\n\n​\t\t\t\t\t\t\t\t\t\t表2：符号汇总表。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg)\n\n## 6个关于查询优化的成本模型\n\n​\t使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)<成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。\n\n### 6.1基础系统的成本模型\n\n​\t我们认为查询计划 Pold 由 M- 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).\n\n​\t![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg)\n\n​\t在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j>i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.\n\n### 6.2SPRINTER的成本模型\n\n​\t一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。\n\n​\t因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg)\n\n​\tEq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg)\n\n​\t如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg)\n\n Eq. 9,术语(1+loд（![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg))表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.\n\n## 7 实验评价\n\n​\t在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。\n\n### 7.1 实验设置\n\n​\t查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。\n\n​\t为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。\n\n​\t环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。\n\n系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。\n\n表3：**系统比较汇总**。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg)\n\n​\t对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。\n\n​\t我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用\n用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统\n利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。\n\n### 7.2 性能比较\n\n​\t图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。\n\n​\t与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。\n\nSPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg)\n\n​\t\t\t\t\t\t图11：使用TPC-DS基准查询(SF=100)的性能比较。\n\n​\t对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。\n\n​\tOmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。\n\n​\t相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。\n\n### 7.3 SPRINTER特征\n\n​\t成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t图12：成本模型的验证。\n\n​\t图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。\n\n​\t全局变量阶 heuristic式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了 heuristic式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的 heuristic式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的 heuristic式算法很简单，但很有效。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg)\n\n​\t\t\t\t\t\t\t图13：不同全局变量顺序的结果。\n\n​\t\t\t\t\t\t\t图14：性能分解的结果。\n\n​\t性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。\n\n​\t在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。\n\n​\t排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg)\n\n图15：排序策略的验证。\n\n## 8 相关工作\n\n​\t多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。\n\n​\t[2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。\n\n​\tWCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。\n\n​\tDunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。\n\n​\t对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。\n\n​\tOLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。\n\n## 9 结论\n\n​\t本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和 heuristic式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。\n\n\n\n## **ACKNOWLEDGMENTS**\n\n​\t这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。\n","source":"_posts/元连接查询处理.md","raw":"---\nlayout: sprinter：快速\ntitle: 快速n元连接查询处理\ndate: 2021-07-31 19:50:46\ntype: \"ustc\"\ncategories:\n    - ustc\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/working-on-a-laptop-from-a-car-2210x1473.jpg\n---\n# SPRINTER：快速 n 元连接查询处理\n\n复杂 OLAP 查询的方法\n\n## 摘要\n\n​\tOLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。\n​\t在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。\n\n## 关键字\n\n​\tn连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理\n\n## **INTRODUCTION**\n\n​\t有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个\n这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。\n\n​\tOLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。\n\n​\t现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以\n\n​\t由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。\n\n​\t在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。\n\n​\t一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型 heuristic式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。\n\n​\t我们的主要贡献总结如下：\n• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。\n• 我们提出了成本模型和查询优化n路连接树的方法。\n• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。\n• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。\n• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。\n\n本文的其余部分组织如下。\n\n在**第2.2节中**，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在**第3节中**，我们将描述本文的一个激励例子。\n\n在**Secti 在4**上，我们提出了n个连接树的查询规划方法。\n\n在**第5节中**，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m\n\n第**6节中的odel**。\n\n**第7节**介绍了实验评价的结果。\n\n最后，我们在**第8节中**讨论相关的工作，\n\n并在**第9节中**总结本文。\n\n## **PRELIMINARIES**\n\n### **Sorting algorithms**\n\n在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。\n\n表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。\n\n**Table 1:**在SPRINTER中使用的并行排序算法和技术。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg)\n\n​\t大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg)\n\n​\t\t图1：异构排序[15]的时间轴。\n\n### 2.2最坏情况下的最优连接算法\n\n​\t在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。\n\n​\t图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。\n\n​\t当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。\n\n![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图2：部落连接[13]的示例。\n\n## **3 动机**\n\n​\t在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图3：激励性查询的连接图。\n\n​\t图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。\n\n​\t图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。\n\n​\tOmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.\n\n​\t短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。\n\n​\t图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。\n\n## 4查询规划方法\n\n​\t在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图4：针对激励性查询的查询计划。\n\n### 4.1单个n个连接运算符的查询\n\n​\t对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。\n\n定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).\n\n​\t在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。\n\n​\t定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。\n\n​\t在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，g(e1)= FKKFKandg(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。\n\n​\t在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。\n\n​\t如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图5：激励性查询的分解。\n\n<<<<<<< HEAD\n​\t算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的 heuristic式方法。 heuristic式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n=======\n​\t算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，**然后选择其中成本最低的最佳计划P∗（第11行）**。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg)\n\n​\t图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg)\n\n图6：针对激励性查询的查询计划。\n\n### 4.2多个n个连接运算符的查询\n\n​\t在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg)\n\n### 4.3搜索空间\n\n​\t我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg)\n\n<<<<<<< HEAD\n​\t如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)非核心子图。例如，在图6中，Nsubg(D1)=3和Nsubg(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.\n=======\nNdcmp 是以ci为子图核心时，分解数，Ncore个核心子图，\n\n如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.\n>>>>>>> c050ef667e21f7ae5e2e8f8620a157be214c5b23\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n​\t在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。\n\n## 5n-ARY JOIN处理方法\n\n​\t在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：估计连接变量的每个全局顺序的成本。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n  对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)<Teval(Sj)(i<j)。步骤2-4在图7(a)中的时间t1时完成，**它确定了连接列之间的一定全局应用TJ算法的顺序。**步骤5 根据全局顺序对每个结果进行排序，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)>TSort(Si)或Teval(Si)<Tsort(Si)。\n\n​\t在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n​\t\t\t\t\t图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。\n\n​\t时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n\n​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)>Tsort(Si)，还是Teval，都没有改变 (Si)<Tsort(Si)。\n\n​\t我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。\n\n \t即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)>Tsort(Si)还是Teval(Si)<TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n\n### 5.1全球订单的确定\n\n​\t一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e heuristic式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种 heuristic式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg)\n\n​\t算法3展示了我们的 heuristic式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图8：TPC-DSQ17的核心子图。\n\n### 5.2排序策略\n\n​\t在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图9：排序算法的选择策略。\n\n​\t如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。\n\n​\t但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。\n\n​\t由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。\n\n### 5.3合并加入排序关系\n\n​\t对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。\n\n​\t人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg)\n\n​\t\t\t\t\t\t\t\t\t图10：图8中的核心子图的合并连接示例。\n\n\n\n​\t\t\t\t\t\t\t\t\t\t表2：符号汇总表。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg)\n\n## 6个关于查询优化的成本模型\n\n​\t使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)<成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。\n\n### 6.1基础系统的成本模型\n\n​\t我们认为查询计划 Pold 由 M- 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).\n\n​\t![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg)\n\n​\t在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j>i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.\n\n### 6.2SPRINTER的成本模型\n\n​\t一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。\n\n​\t因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg)\n\n​\tEq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg)\n\n​\t如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg)\n\n Eq. 9,术语(1+loд（![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg))表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.\n\n## 7 实验评价\n\n​\t在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。\n\n### 7.1 实验设置\n\n​\t查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。\n\n​\t为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。\n\n​\t环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。\n\n系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。\n\n表3：**系统比较汇总**。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg)\n\n​\t对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。\n\n​\t我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用\n用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统\n利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。\n\n### 7.2 性能比较\n\n​\t图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。\n\n​\t与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。\n\nSPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg)\n\n​\t\t\t\t\t\t图11：使用TPC-DS基准查询(SF=100)的性能比较。\n\n​\t对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。\n\n​\tOmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。\n\n​\t相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。\n\n### 7.3 SPRINTER特征\n\n​\t成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t图12：成本模型的验证。\n\n​\t图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。\n\n​\t全局变量阶 heuristic式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了 heuristic式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的 heuristic式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的 heuristic式算法很简单，但很有效。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg)\n\n​\t\t\t\t\t\t\t图13：不同全局变量顺序的结果。\n\n​\t\t\t\t\t\t\t图14：性能分解的结果。\n\n​\t性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。\n\n​\t在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。\n\n​\t排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg)\n\n图15：排序策略的验证。\n\n## 8 相关工作\n\n​\t多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。\n\n​\t[2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。\n\n​\tWCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。\n\n​\tDunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。\n\n​\t对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。\n\n​\tOLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。\n\n## 9 结论\n\n​\t本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和 heuristic式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。\n\n\n\n## **ACKNOWLEDGMENTS**\n\n​\t这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。\n","slug":"元连接查询处理","published":1,"updated":"2021-08-18T01:02:59.370Z","comments":1,"photos":[],"link":"","_id":"cksiamo9d001qc376hycu6d9y","content":"<h1 id=\"SPRINTER：快速-n-元连接查询处理\"><a href=\"#SPRINTER：快速-n-元连接查询处理\" class=\"headerlink\" title=\"SPRINTER：快速 n 元连接查询处理\"></a>SPRINTER：快速 n 元连接查询处理</h1><p>复杂 OLAP 查询的方法</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>​    OLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。<br>​    在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。</p>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><p>​    n连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理</p>\n<h2 id=\"INTRODUCTION\"><a href=\"#INTRODUCTION\" class=\"headerlink\" title=\"INTRODUCTION\"></a><strong>INTRODUCTION</strong></h2><p>​    有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个<br>这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。</p>\n<p>​    OLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。</p>\n<p>​    现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以</p>\n<p>​    由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。</p>\n<p>​    在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。</p>\n<p>​    一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型 heuristic式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。</p>\n<p>​    我们的主要贡献总结如下：<br>• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。<br>• 我们提出了成本模型和查询优化n路连接树的方法。<br>• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。<br>• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。<br>• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。</p>\n<p>本文的其余部分组织如下。</p>\n<p>在<strong>第2.2节中</strong>，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在<strong>第3节中</strong>，我们将描述本文的一个激励例子。</p>\n<p>在<strong>Secti 在4</strong>上，我们提出了n个连接树的查询规划方法。</p>\n<p>在<strong>第5节中</strong>，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m</p>\n<p>第<strong>6节中的odel</strong>。</p>\n<p><strong>第7节</strong>介绍了实验评价的结果。</p>\n<p>最后，我们在<strong>第8节中</strong>讨论相关的工作，</p>\n<p>并在<strong>第9节中</strong>总结本文。</p>\n<h2 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a><strong>PRELIMINARIES</strong></h2><h3 id=\"Sorting-algorithms\"><a href=\"#Sorting-algorithms\" class=\"headerlink\" title=\"Sorting algorithms\"></a><strong>Sorting algorithms</strong></h3><p>在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。</p>\n<p>表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。</p>\n<p>**Table 1:**在SPRINTER中使用的并行排序算法和技术。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg\"></p>\n<p>​    大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg\"></p>\n<p>​        图1：异构排序[15]的时间轴。</p>\n<h3 id=\"2-2最坏情况下的最优连接算法\"><a href=\"#2-2最坏情况下的最优连接算法\" class=\"headerlink\" title=\"2.2最坏情况下的最优连接算法\"></a>2.2最坏情况下的最优连接算法</h3><p>​    在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。</p>\n<p>​    图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。</p>\n<p>​    当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。</p>\n<p>![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)</p>\n<p>​                                                图2：部落连接[13]的示例。</p>\n<h2 id=\"3-动机\"><a href=\"#3-动机\" class=\"headerlink\" title=\"3 动机\"></a><strong>3 动机</strong></h2><p>​    在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg\"></p>\n<p>​                                            图3：激励性查询的连接图。</p>\n<p>​    图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。</p>\n<p>​    图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。</p>\n<p>​    OmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.</p>\n<p>​    短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。</p>\n<p>​    图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。</p>\n<h2 id=\"4查询规划方法\"><a href=\"#4查询规划方法\" class=\"headerlink\" title=\"4查询规划方法\"></a>4查询规划方法</h2><p>​    在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p>​                                                图4：针对激励性查询的查询计划。</p>\n<h3 id=\"4-1单个n个连接运算符的查询\"><a href=\"#4-1单个n个连接运算符的查询\" class=\"headerlink\" title=\"4.1单个n个连接运算符的查询\"></a>4.1单个n个连接运算符的查询</h3><p>​    对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。</p>\n<p>定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).</p>\n<p>​    在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。</p>\n<p>​    定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。</p>\n<p>​    在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，g(e1)= FKKFKandg(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。</p>\n<p>​    在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。</p>\n<p>​    如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>​                                            图5：激励性查询的分解。</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>​    算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的 heuristic式方法。 heuristic式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。<br>=======<br>​    算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，<strong>然后选择其中成本最低的最佳计划P∗（第11行）</strong>。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg\"></p>\n<p>​    图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg\"></p>\n<p>图6：针对激励性查询的查询计划。</p>\n<h3 id=\"4-2多个n个连接运算符的查询\"><a href=\"#4-2多个n个连接运算符的查询\" class=\"headerlink\" title=\"4.2多个n个连接运算符的查询\"></a>4.2多个n个连接运算符的查询</h3><p>​    在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg\"></p>\n<h3 id=\"4-3搜索空间\"><a href=\"#4-3搜索空间\" class=\"headerlink\" title=\"4.3搜索空间\"></a>4.3搜索空间</h3><p>​    我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg\"></p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>​    如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)非核心子图。例如，在图6中，Nsubg(D1)=3和Nsubg(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.<br>=======<br>Ndcmp 是以ci为子图核心时，分解数，Ncore个核心子图，</p>\n<p>如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>​    在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。</p>\n<h2 id=\"5n-ARY-JOIN处理方法\"><a href=\"#5n-ARY-JOIN处理方法\" class=\"headerlink\" title=\"5n-ARY JOIN处理方法\"></a>5n-ARY JOIN处理方法</h2><p>​    在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。</p>\n<ul>\n<li><p>步骤1：逐个评估{S1、·、·、Sn}。</p>\n</li>\n<li><p>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</p>\n</li>\n<li><p>步骤3：估计连接变量的每个全局顺序的成本。 </p>\n</li>\n<li><p>步骤4：选择最佳的全局变量顺序。</p>\n</li>\n<li><p>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</p>\n</li>\n<li><p>第6步：在n个已排序的关系上合并连接。</p>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)&lt;Teval(Sj)(i&lt;j)。步骤2-4在图7(a)中的时间t1时完成，**它确定了连接列之间的一定全局应用TJ算法的顺序。**步骤5 根据全局顺序对每个结果进行排序，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)&gt;TSort(Si)或Teval(Si)&lt;Tsort(Si)。</p>\n</li>\n</ul>\n<p>​    在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<p>​                    图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。</p>\n<p>​    时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。</li>\n</ul>\n<p>​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)&gt;Tsort(Si)，还是Teval，都没有改变 (Si)&lt;Tsort(Si)。</p>\n<p>​    我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。</p>\n<pre><code> 即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)&gt;Tsort(Si)还是Teval(Si)&lt;TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n</code></pre>\n<h3 id=\"5-1全球订单的确定\"><a href=\"#5-1全球订单的确定\" class=\"headerlink\" title=\"5.1全球订单的确定\"></a>5.1全球订单的确定</h3><p>​    一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e heuristic式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种 heuristic式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg\"></p>\n<p>​    算法3展示了我们的 heuristic式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg\"></p>\n<p>​                                            图8：TPC-DSQ17的核心子图。</p>\n<h3 id=\"5-2排序策略\"><a href=\"#5-2排序策略\" class=\"headerlink\" title=\"5.2排序策略\"></a>5.2排序策略</h3><p>​    在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg\"></p>\n<p>​                                                图9：排序算法的选择策略。</p>\n<p>​    如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。</p>\n<p>​    但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。</p>\n<p>​    由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。</p>\n<h3 id=\"5-3合并加入排序关系\"><a href=\"#5-3合并加入排序关系\" class=\"headerlink\" title=\"5.3合并加入排序关系\"></a>5.3合并加入排序关系</h3><p>​    对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。</p>\n<p>​    人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg\"></p>\n<p>​                                    图10：图8中的核心子图的合并连接示例。</p>\n<p>​                                        表2：符号汇总表。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg\"></p>\n<h2 id=\"6个关于查询优化的成本模型\"><a href=\"#6个关于查询优化的成本模型\" class=\"headerlink\" title=\"6个关于查询优化的成本模型\"></a>6个关于查询优化的成本模型</h2><p>​    使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)&lt;成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。</p>\n<h3 id=\"6-1基础系统的成本模型\"><a href=\"#6-1基础系统的成本模型\" class=\"headerlink\" title=\"6.1基础系统的成本模型\"></a>6.1基础系统的成本模型</h3><p>​    我们认为查询计划 Pold 由 M- 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).</p>\n<p>​    <img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg\"></p>\n<p>​    在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j&gt;i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.</p>\n<h3 id=\"6-2SPRINTER的成本模型\"><a href=\"#6-2SPRINTER的成本模型\" class=\"headerlink\" title=\"6.2SPRINTER的成本模型\"></a>6.2SPRINTER的成本模型</h3><p>​    一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。</p>\n<p>​    因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg\"></p>\n<p>​    Eq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg\"></p>\n<p>​    如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg\"></p>\n<p> Eq. 9,术语(1+loд（<img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg\">)表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.</p>\n<h2 id=\"7-实验评价\"><a href=\"#7-实验评价\" class=\"headerlink\" title=\"7 实验评价\"></a>7 实验评价</h2><p>​    在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。</p>\n<h3 id=\"7-1-实验设置\"><a href=\"#7-1-实验设置\" class=\"headerlink\" title=\"7.1 实验设置\"></a>7.1 实验设置</h3><p>​    查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。</p>\n<p>​    为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。</p>\n<p>​    环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。</p>\n<p>系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。</p>\n<p>表3：<strong>系统比较汇总</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg\"></p>\n<p>​    对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。</p>\n<p>​    我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用<br>用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统<br>利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。</p>\n<h3 id=\"7-2-性能比较\"><a href=\"#7-2-性能比较\" class=\"headerlink\" title=\"7.2 性能比较\"></a>7.2 性能比较</h3><p>​    图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。</p>\n<p>​    与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。</p>\n<p>SPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg\"></p>\n<p>​                        图11：使用TPC-DS基准查询(SF=100)的性能比较。</p>\n<p>​    对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。</p>\n<p>​    OmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。</p>\n<p>​    相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。</p>\n<h3 id=\"7-3-SPRINTER特征\"><a href=\"#7-3-SPRINTER特征\" class=\"headerlink\" title=\"7.3 SPRINTER特征\"></a>7.3 SPRINTER特征</h3><p>​    成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg\"></p>\n<p>​                                                    图12：成本模型的验证。</p>\n<p>​    图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。</p>\n<p>​    全局变量阶 heuristic式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了 heuristic式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的 heuristic式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的 heuristic式算法很简单，但很有效。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg\"></p>\n<p>​                            图13：不同全局变量顺序的结果。</p>\n<p>​                            图14：性能分解的结果。</p>\n<p>​    性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。</p>\n<p>​    在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。</p>\n<p>​    排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg\"></p>\n<p>图15：排序策略的验证。</p>\n<h2 id=\"8-相关工作\"><a href=\"#8-相关工作\" class=\"headerlink\" title=\"8 相关工作\"></a>8 相关工作</h2><p>​    多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。</p>\n<p>​    [2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。</p>\n<p>​    WCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。</p>\n<p>​    DunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。</p>\n<p>​    对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。</p>\n<p>​    OLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。</p>\n<h2 id=\"9-结论\"><a href=\"#9-结论\" class=\"headerlink\" title=\"9 结论\"></a>9 结论</h2><p>​    本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和 heuristic式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。</p>\n<h2 id=\"ACKNOWLEDGMENTS\"><a href=\"#ACKNOWLEDGMENTS\" class=\"headerlink\" title=\"ACKNOWLEDGMENTS\"></a><strong>ACKNOWLEDGMENTS</strong></h2><p>​    这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SPRINTER：快速-n-元连接查询处理\"><a href=\"#SPRINTER：快速-n-元连接查询处理\" class=\"headerlink\" title=\"SPRINTER：快速 n 元连接查询处理\"></a>SPRINTER：快速 n 元连接查询处理</h1><p>复杂 OLAP 查询的方法</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>​    OLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。<br>​    在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。</p>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><p>​    n连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理</p>\n<h2 id=\"INTRODUCTION\"><a href=\"#INTRODUCTION\" class=\"headerlink\" title=\"INTRODUCTION\"></a><strong>INTRODUCTION</strong></h2><p>​    有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个<br>这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。</p>\n<p>​    OLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。</p>\n<p>​    现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以</p>\n<p>​    由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。</p>\n<p>​    在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。</p>\n<p>​    一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型 heuristic式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。</p>\n<p>​    我们的主要贡献总结如下：<br>• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。<br>• 我们提出了成本模型和查询优化n路连接树的方法。<br>• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。<br>• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。<br>• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。</p>\n<p>本文的其余部分组织如下。</p>\n<p>在<strong>第2.2节中</strong>，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在<strong>第3节中</strong>，我们将描述本文的一个激励例子。</p>\n<p>在<strong>Secti 在4</strong>上，我们提出了n个连接树的查询规划方法。</p>\n<p>在<strong>第5节中</strong>，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m</p>\n<p>第<strong>6节中的odel</strong>。</p>\n<p><strong>第7节</strong>介绍了实验评价的结果。</p>\n<p>最后，我们在<strong>第8节中</strong>讨论相关的工作，</p>\n<p>并在<strong>第9节中</strong>总结本文。</p>\n<h2 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a><strong>PRELIMINARIES</strong></h2><h3 id=\"Sorting-algorithms\"><a href=\"#Sorting-algorithms\" class=\"headerlink\" title=\"Sorting algorithms\"></a><strong>Sorting algorithms</strong></h3><p>在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。</p>\n<p>表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。</p>\n<p>**Table 1:**在SPRINTER中使用的并行排序算法和技术。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg\"></p>\n<p>​    大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg\"></p>\n<p>​        图1：异构排序[15]的时间轴。</p>\n<h3 id=\"2-2最坏情况下的最优连接算法\"><a href=\"#2-2最坏情况下的最优连接算法\" class=\"headerlink\" title=\"2.2最坏情况下的最优连接算法\"></a>2.2最坏情况下的最优连接算法</h3><p>​    在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。</p>\n<p>​    图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。</p>\n<p>​    当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。</p>\n<p>![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)</p>\n<p>​                                                图2：部落连接[13]的示例。</p>\n<h2 id=\"3-动机\"><a href=\"#3-动机\" class=\"headerlink\" title=\"3 动机\"></a><strong>3 动机</strong></h2><p>​    在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg\"></p>\n<p>​                                            图3：激励性查询的连接图。</p>\n<p>​    图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。</p>\n<p>​    图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。</p>\n<p>​    OmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.</p>\n<p>​    短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。</p>\n<p>​    图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。</p>\n<h2 id=\"4查询规划方法\"><a href=\"#4查询规划方法\" class=\"headerlink\" title=\"4查询规划方法\"></a>4查询规划方法</h2><p>​    在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p>​                                                图4：针对激励性查询的查询计划。</p>\n<h3 id=\"4-1单个n个连接运算符的查询\"><a href=\"#4-1单个n个连接运算符的查询\" class=\"headerlink\" title=\"4.1单个n个连接运算符的查询\"></a>4.1单个n个连接运算符的查询</h3><p>​    对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。</p>\n<p>定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).</p>\n<p>​    在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。</p>\n<p>​    定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。</p>\n<p>​    在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，g(e1)= FKKFKandg(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。</p>\n<p>​    在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。</p>\n<p>​    如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>​                                            图5：激励性查询的分解。</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>​    算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的 heuristic式方法。 heuristic式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。<br>=======<br>​    算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，<strong>然后选择其中成本最低的最佳计划P∗（第11行）</strong>。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg\"></p>\n<p>​    图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg\"></p>\n<p>图6：针对激励性查询的查询计划。</p>\n<h3 id=\"4-2多个n个连接运算符的查询\"><a href=\"#4-2多个n个连接运算符的查询\" class=\"headerlink\" title=\"4.2多个n个连接运算符的查询\"></a>4.2多个n个连接运算符的查询</h3><p>​    在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg\"></p>\n<h3 id=\"4-3搜索空间\"><a href=\"#4-3搜索空间\" class=\"headerlink\" title=\"4.3搜索空间\"></a>4.3搜索空间</h3><p>​    我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg\"></p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>​    如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubg(Dj)非核心子图。例如，在图6中，Nsubg(D1)=3和Nsubg(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.<br>=======<br>Ndcmp 是以ci为子图核心时，分解数，Ncore个核心子图，</p>\n<p>如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>c050ef667e21f7ae5e2e8f8620a157be214c5b23</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>​    在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。</p>\n<h2 id=\"5n-ARY-JOIN处理方法\"><a href=\"#5n-ARY-JOIN处理方法\" class=\"headerlink\" title=\"5n-ARY JOIN处理方法\"></a>5n-ARY JOIN处理方法</h2><p>​    在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。</p>\n<ul>\n<li><p>步骤1：逐个评估{S1、·、·、Sn}。</p>\n</li>\n<li><p>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</p>\n</li>\n<li><p>步骤3：估计连接变量的每个全局顺序的成本。 </p>\n</li>\n<li><p>步骤4：选择最佳的全局变量顺序。</p>\n</li>\n<li><p>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</p>\n</li>\n<li><p>第6步：在n个已排序的关系上合并连接。</p>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在朴素方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)&lt;Teval(Sj)(i&lt;j)。步骤2-4在图7(a)中的时间t1时完成，**它确定了连接列之间的一定全局应用TJ算法的顺序。**步骤5 根据全局顺序对每个结果进行排序，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)&gt;TSort(Si)或Teval(Si)&lt;Tsort(Si)。</p>\n</li>\n</ul>\n<p>​    在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<p>​                    图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。</p>\n<p>​    时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由of请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。</li>\n</ul>\n<p>​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)&gt;Tsort(Si)，还是Teval，都没有改变 (Si)&lt;Tsort(Si)。</p>\n<p>​    我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。</p>\n<pre><code> 即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)&gt;Tsort(Si)还是Teval(Si)&lt;TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n</code></pre>\n<h3 id=\"5-1全球订单的确定\"><a href=\"#5-1全球订单的确定\" class=\"headerlink\" title=\"5.1全球订单的确定\"></a>5.1全球订单的确定</h3><p>​    一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e heuristic式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种 heuristic式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg\"></p>\n<p>​    算法3展示了我们的 heuristic式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtc61m91taj30dn06r74k.jpg\"></p>\n<p>​                                            图8：TPC-DSQ17的核心子图。</p>\n<h3 id=\"5-2排序策略\"><a href=\"#5-2排序策略\" class=\"headerlink\" title=\"5.2排序策略\"></a>5.2排序策略</h3><p>​    在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg\"></p>\n<p>​                                                图9：排序算法的选择策略。</p>\n<p>​    如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。</p>\n<p>​    但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。</p>\n<p>​    由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。</p>\n<h3 id=\"5-3合并加入排序关系\"><a href=\"#5-3合并加入排序关系\" class=\"headerlink\" title=\"5.3合并加入排序关系\"></a>5.3合并加入排序关系</h3><p>​    对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。</p>\n<p>​    人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg\"></p>\n<p>​                                    图10：图8中的核心子图的合并连接示例。</p>\n<p>​                                        表2：符号汇总表。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg\"></p>\n<h2 id=\"6个关于查询优化的成本模型\"><a href=\"#6个关于查询优化的成本模型\" class=\"headerlink\" title=\"6个关于查询优化的成本模型\"></a>6个关于查询优化的成本模型</h2><p>​    使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)&lt;成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。</p>\n<h3 id=\"6-1基础系统的成本模型\"><a href=\"#6-1基础系统的成本模型\" class=\"headerlink\" title=\"6.1基础系统的成本模型\"></a>6.1基础系统的成本模型</h3><p>​    我们认为查询计划 Pold 由 M- 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).</p>\n<p>​    <img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg\"></p>\n<p>​    在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j&gt;i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.</p>\n<h3 id=\"6-2SPRINTER的成本模型\"><a href=\"#6-2SPRINTER的成本模型\" class=\"headerlink\" title=\"6.2SPRINTER的成本模型\"></a>6.2SPRINTER的成本模型</h3><p>​    一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。</p>\n<p>​    因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg\"></p>\n<p>​    Eq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg\"></p>\n<p>​    如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg\"></p>\n<p> Eq. 9,术语(1+loд（<img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg\">)表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.</p>\n<h2 id=\"7-实验评价\"><a href=\"#7-实验评价\" class=\"headerlink\" title=\"7 实验评价\"></a>7 实验评价</h2><p>​    在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。</p>\n<h3 id=\"7-1-实验设置\"><a href=\"#7-1-实验设置\" class=\"headerlink\" title=\"7.1 实验设置\"></a>7.1 实验设置</h3><p>​    查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。</p>\n<p>​    为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。</p>\n<p>​    环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。</p>\n<p>系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。</p>\n<p>表3：<strong>系统比较汇总</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg\"></p>\n<p>​    对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。</p>\n<p>​    我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用<br>用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统<br>利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。</p>\n<h3 id=\"7-2-性能比较\"><a href=\"#7-2-性能比较\" class=\"headerlink\" title=\"7.2 性能比较\"></a>7.2 性能比较</h3><p>​    图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。</p>\n<p>​    与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。</p>\n<p>SPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg\"></p>\n<p>​                        图11：使用TPC-DS基准查询(SF=100)的性能比较。</p>\n<p>​    对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。</p>\n<p>​    OmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。</p>\n<p>​    相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。</p>\n<h3 id=\"7-3-SPRINTER特征\"><a href=\"#7-3-SPRINTER特征\" class=\"headerlink\" title=\"7.3 SPRINTER特征\"></a>7.3 SPRINTER特征</h3><p>​    成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg\"></p>\n<p>​                                                    图12：成本模型的验证。</p>\n<p>​    图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。</p>\n<p>​    全局变量阶 heuristic式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了 heuristic式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的 heuristic式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的 heuristic式算法很简单，但很有效。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg\"></p>\n<p>​                            图13：不同全局变量顺序的结果。</p>\n<p>​                            图14：性能分解的结果。</p>\n<p>​    性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。</p>\n<p>​    在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。</p>\n<p>​    排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg\"></p>\n<p>图15：排序策略的验证。</p>\n<h2 id=\"8-相关工作\"><a href=\"#8-相关工作\" class=\"headerlink\" title=\"8 相关工作\"></a>8 相关工作</h2><p>​    多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。</p>\n<p>​    [2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。</p>\n<p>​    WCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。</p>\n<p>​    DunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。</p>\n<p>​    对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。</p>\n<p>​    OLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。</p>\n<h2 id=\"9-结论\"><a href=\"#9-结论\" class=\"headerlink\" title=\"9 结论\"></a>9 结论</h2><p>​    本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和 heuristic式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。</p>\n<h2 id=\"ACKNOWLEDGMENTS\"><a href=\"#ACKNOWLEDGMENTS\" class=\"headerlink\" title=\"ACKNOWLEDGMENTS\"></a><strong>ACKNOWLEDGMENTS</strong></h2><p>​    这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。</p>\n"},{"title":"8月20日","date":"2021-08-20T02:21:46.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtn1kggckuj60u0190jxy02.jpg","_content":"\nJava AtomicBoolean get()用法及代码示例\n\njava.util.concurrent.atomic.AtomicBoolean.get()是java中的内置方法，\n该方法返回布尔值类型的当前值。\n\n```java\n// Java Program to demonstrates \n// the get() function \n  \nimport java.util.concurrent.atomic.AtomicBoolean; \n  \npublic class GFG { \n    public static void main(String args[]) \n    { \n  \n        // Initially value as false \n        AtomicBoolean val \n            = new AtomicBoolean(false); \n  \n        // Gets the current value \n        boolean res = val.get(); \n  \n        System.out.println(\"current value: \"\n                           + res); \n    } \n}\n```\n\n\n\n### @NoArgsConstructor\n\n注解在类上，为类提供一个无参的构造方法。\n\n```java\n@NoArgsConstructor\n@AllArgsConstructor\n```\n\n\n\nDispatcherServlet截获请求后，就通过控制器上@RequestMapping提供的映射信息请求所对应的处理方法\n\nRequestMapping用来处理请求地址映射的注解，可用于类或方法上\n\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径\n\n使用RequestMapping修饰类\n\n@RequestMapping除了可以使用请求URL映射请求外，还可以使用请求方法请求参数及请求头映射请求\n\n@RequestMapping的value、method、params、heads分别表示请求URL、请求方法、请求参数及请求头的映射条件，它们之间是与的关系、联合使用多个条件可以让请求映射更加精准化\n\nvalue：指定请求的实际地址，指定的地址可以是URI Template 模式\n\nmethod： 指定请求的method类型， GET、POST、PUT、DELETE等\n\nparams： 指定request中必须包含某些参数值时，才让该方法处理\n\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\n\n\n\n\nfindBy指定数目的记录怎么写？\n\nselect * from tableName limit i,n *# tableName：表名* *# i：为查询结果的索引值(默认从0开始)，当i=0时可省略i* *# n：为查询结果返回的数量* *# i与n之间使用英文逗号\",\"隔开*\n\n\n\nExecuting an update/delete query; nested exception is javax.persistence.\n\n没加事务注解\n\n为什么实现类不能引用自己的接口\n\n为什么Authorization的token有时候不能用，redis原理，怎么配置的日志\n\n\n\n```\n//手工添加的热搜配置，在热搜统计数据足够时，rank不允许更改，否则数据量不足，手工热搜之间不允许有间隙，需要进行重排序。\n//根据level进行排序，手工的热搜配置的level设置为xx，添加之前需要判断原来的level是否存在，前端显示灰色？\n//综合频道只显示综合的热搜配置，独立频道\n//不同的频道去各自的类型的热搜统计中抽取level值高的，如果对应类型的热搜不足6个，\n//则判断手工热搜是否有间隔，若有间隔还需针对手工热搜进行排序，\n```\n\n","source":"_posts/8月20日.md","raw":"---\ntitle: 8月20日\ndate: 2021-08-20 10:21:46\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtn1kggckuj60u0190jxy02.jpg\n---\n\nJava AtomicBoolean get()用法及代码示例\n\njava.util.concurrent.atomic.AtomicBoolean.get()是java中的内置方法，\n该方法返回布尔值类型的当前值。\n\n```java\n// Java Program to demonstrates \n// the get() function \n  \nimport java.util.concurrent.atomic.AtomicBoolean; \n  \npublic class GFG { \n    public static void main(String args[]) \n    { \n  \n        // Initially value as false \n        AtomicBoolean val \n            = new AtomicBoolean(false); \n  \n        // Gets the current value \n        boolean res = val.get(); \n  \n        System.out.println(\"current value: \"\n                           + res); \n    } \n}\n```\n\n\n\n### @NoArgsConstructor\n\n注解在类上，为类提供一个无参的构造方法。\n\n```java\n@NoArgsConstructor\n@AllArgsConstructor\n```\n\n\n\nDispatcherServlet截获请求后，就通过控制器上@RequestMapping提供的映射信息请求所对应的处理方法\n\nRequestMapping用来处理请求地址映射的注解，可用于类或方法上\n\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径\n\n使用RequestMapping修饰类\n\n@RequestMapping除了可以使用请求URL映射请求外，还可以使用请求方法请求参数及请求头映射请求\n\n@RequestMapping的value、method、params、heads分别表示请求URL、请求方法、请求参数及请求头的映射条件，它们之间是与的关系、联合使用多个条件可以让请求映射更加精准化\n\nvalue：指定请求的实际地址，指定的地址可以是URI Template 模式\n\nmethod： 指定请求的method类型， GET、POST、PUT、DELETE等\n\nparams： 指定request中必须包含某些参数值时，才让该方法处理\n\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求\n\n\n\n\nfindBy指定数目的记录怎么写？\n\nselect * from tableName limit i,n *# tableName：表名* *# i：为查询结果的索引值(默认从0开始)，当i=0时可省略i* *# n：为查询结果返回的数量* *# i与n之间使用英文逗号\",\"隔开*\n\n\n\nExecuting an update/delete query; nested exception is javax.persistence.\n\n没加事务注解\n\n为什么实现类不能引用自己的接口\n\n为什么Authorization的token有时候不能用，redis原理，怎么配置的日志\n\n\n\n```\n//手工添加的热搜配置，在热搜统计数据足够时，rank不允许更改，否则数据量不足，手工热搜之间不允许有间隙，需要进行重排序。\n//根据level进行排序，手工的热搜配置的level设置为xx，添加之前需要判断原来的level是否存在，前端显示灰色？\n//综合频道只显示综合的热搜配置，独立频道\n//不同的频道去各自的类型的热搜统计中抽取level值高的，如果对应类型的热搜不足6个，\n//则判断手工热搜是否有间隔，若有间隔还需针对手工热搜进行排序，\n```\n\n","slug":"8月20日","published":1,"updated":"2021-08-23T12:45:27.372Z","_id":"cksjq92yr00004f76e4rvfgrn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Java AtomicBoolean get()用法及代码示例</p>\n<p>java.util.concurrent.atomic.AtomicBoolean.get()是java中的内置方法，<br>该方法返回布尔值类型的当前值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java Program to demonstrates </span></span><br><span class=\"line\"><span class=\"comment\">// the get() function </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicBoolean; </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GFG</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// Initially value as false </span></span><br><span class=\"line\">        AtomicBoolean val </span><br><span class=\"line\">            = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>); </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// Gets the current value </span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> res = val.get(); </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;current value: &quot;</span></span><br><span class=\"line\">                           + res); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"NoArgsConstructor\"><a href=\"#NoArgsConstructor\" class=\"headerlink\" title=\"@NoArgsConstructor\"></a>@NoArgsConstructor</h3><p>注解在类上，为类提供一个无参的构造方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>DispatcherServlet截获请求后，就通过控制器上@RequestMapping提供的映射信息请求所对应的处理方法</p>\n<p>RequestMapping用来处理请求地址映射的注解，可用于类或方法上</p>\n<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径</p>\n<p>使用RequestMapping修饰类</p>\n<p>@RequestMapping除了可以使用请求URL映射请求外，还可以使用请求方法请求参数及请求头映射请求</p>\n<p>@RequestMapping的value、method、params、heads分别表示请求URL、请求方法、请求参数及请求头的映射条件，它们之间是与的关系、联合使用多个条件可以让请求映射更加精准化</p>\n<p>value：指定请求的实际地址，指定的地址可以是URI Template 模式</p>\n<p>method： 指定请求的method类型， GET、POST、PUT、DELETE等</p>\n<p>params： 指定request中必须包含某些参数值时，才让该方法处理</p>\n<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>\n<p>findBy指定数目的记录怎么写？</p>\n<p>select * from tableName limit i,n <em># tableName：表名</em> <em># i：为查询结果的索引值(默认从0开始)，当i=0时可省略i</em> <em># n：为查询结果返回的数量</em> <em># i与n之间使用英文逗号”,”隔开</em></p>\n<p>Executing an update/delete query; nested exception is javax.persistence.</p>\n<p>没加事务注解</p>\n<p>为什么实现类不能引用自己的接口</p>\n<p>为什么Authorization的token有时候不能用，redis原理，怎么配置的日志</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//手工添加的热搜配置，在热搜统计数据足够时，rank不允许更改，否则数据量不足，手工热搜之间不允许有间隙，需要进行重排序。</span><br><span class=\"line\">//根据level进行排序，手工的热搜配置的level设置为xx，添加之前需要判断原来的level是否存在，前端显示灰色？</span><br><span class=\"line\">//综合频道只显示综合的热搜配置，独立频道</span><br><span class=\"line\">//不同的频道去各自的类型的热搜统计中抽取level值高的，如果对应类型的热搜不足6个，</span><br><span class=\"line\">//则判断手工热搜是否有间隔，若有间隔还需针对手工热搜进行排序，</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>Java AtomicBoolean get()用法及代码示例</p>\n<p>java.util.concurrent.atomic.AtomicBoolean.get()是java中的内置方法，<br>该方法返回布尔值类型的当前值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java Program to demonstrates </span></span><br><span class=\"line\"><span class=\"comment\">// the get() function </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicBoolean; </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GFG</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// Initially value as false </span></span><br><span class=\"line\">        AtomicBoolean val </span><br><span class=\"line\">            = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>); </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// Gets the current value </span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> res = val.get(); </span><br><span class=\"line\">  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;current value: &quot;</span></span><br><span class=\"line\">                           + res); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"NoArgsConstructor\"><a href=\"#NoArgsConstructor\" class=\"headerlink\" title=\"@NoArgsConstructor\"></a>@NoArgsConstructor</h3><p>注解在类上，为类提供一个无参的构造方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>DispatcherServlet截获请求后，就通过控制器上@RequestMapping提供的映射信息请求所对应的处理方法</p>\n<p>RequestMapping用来处理请求地址映射的注解，可用于类或方法上</p>\n<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径</p>\n<p>使用RequestMapping修饰类</p>\n<p>@RequestMapping除了可以使用请求URL映射请求外，还可以使用请求方法请求参数及请求头映射请求</p>\n<p>@RequestMapping的value、method、params、heads分别表示请求URL、请求方法、请求参数及请求头的映射条件，它们之间是与的关系、联合使用多个条件可以让请求映射更加精准化</p>\n<p>value：指定请求的实际地址，指定的地址可以是URI Template 模式</p>\n<p>method： 指定请求的method类型， GET、POST、PUT、DELETE等</p>\n<p>params： 指定request中必须包含某些参数值时，才让该方法处理</p>\n<p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p>\n<p>findBy指定数目的记录怎么写？</p>\n<p>select * from tableName limit i,n <em># tableName：表名</em> <em># i：为查询结果的索引值(默认从0开始)，当i=0时可省略i</em> <em># n：为查询结果返回的数量</em> <em># i与n之间使用英文逗号”,”隔开</em></p>\n<p>Executing an update/delete query; nested exception is javax.persistence.</p>\n<p>没加事务注解</p>\n<p>为什么实现类不能引用自己的接口</p>\n<p>为什么Authorization的token有时候不能用，redis原理，怎么配置的日志</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//手工添加的热搜配置，在热搜统计数据足够时，rank不允许更改，否则数据量不足，手工热搜之间不允许有间隙，需要进行重排序。</span><br><span class=\"line\">//根据level进行排序，手工的热搜配置的level设置为xx，添加之前需要判断原来的level是否存在，前端显示灰色？</span><br><span class=\"line\">//综合频道只显示综合的热搜配置，独立频道</span><br><span class=\"line\">//不同的频道去各自的类型的热搜统计中抽取level值高的，如果对应类型的热搜不足6个，</span><br><span class=\"line\">//则判断手工热搜是否有间隔，若有间隔还需针对手工热搜进行排序，</span><br></pre></td></tr></table></figure>\n\n"},{"title":"8月21日","date":"2021-08-21T06:07:05.000Z","thumbnail":null,"_content":"\n@RequestMapping\n作用:设置请求映射，把请求和控制层中的方法设置映射关系，\n\n当请求路径和@RequestMapping的value属性一致时，即注解所标注的方法即为处理请求的方法\n\n\n","source":"_posts/8月21日.md","raw":"---\ntitle: 8月21日\ndate: 2021-08-21 14:07:05\ncategories:\ntags:\nthumbnail:\n---\n\n@RequestMapping\n作用:设置请求映射，把请求和控制层中的方法设置映射关系，\n\n当请求路径和@RequestMapping的value属性一致时，即注解所标注的方法即为处理请求的方法\n\n\n","slug":"8月21日","published":1,"updated":"2021-08-21T06:08:28.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksphebct00009d764egf71lm","content":"<p>@RequestMapping<br>作用:设置请求映射，把请求和控制层中的方法设置映射关系，</p>\n<p>当请求路径和@RequestMapping的value属性一致时，即注解所标注的方法即为处理请求的方法</p>\n","site":{"data":{}},"excerpt":"","more":"<p>@RequestMapping<br>作用:设置请求映射，把请求和控制层中的方法设置映射关系，</p>\n<p>当请求路径和@RequestMapping的value属性一致时，即注解所标注的方法即为处理请求的方法</p>\n"},{"title":"8月24日","date":"2021-08-24T01:23:18.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtrmb59gkcj60u0190q8p02.jpg","_content":"\n前几天太忙了，鸽了几天\n\n\n\n@PostConstruct基本：\n@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。\n\nJava中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。\n\n通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：\n\nConstructor(构造方法) -> @Autowired(依赖注入) -> @PostConstruct(注释的方法)\n\n应用：在静态方法中调用依赖注入的Bean中的方法。\n\n\n\n看端口\n\n```\nserver.port:\n```\n\n# countDownLatch\n\n- countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。\n- 存在于java.util.cucurrent包下。\n\n概念\n\n\n\n- countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。\n- 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。\n\n\n\n\n\n\n\n## 一、ExecutorService介绍\n\n**ExecutorService**是Java中对线程池定义的一个接口，它`java.util.concurrent`包中，在这个接口中定义了和后台任务执行相关的方法：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gts6lncwarj60ch07vwf102.jpg)\n\n\n\nJava API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类（详细了解这两个实现类，[点击这里](http://blog.csdn.net/suifeng3051/article/details/49444177)）：\n\n1. ThreadPoolExecutor \n\n2. ScheduledThreadPoolExecutor\n\n除此之外，ExecutorService还继承了`Executor`接口（注意区分Executor接口和Executors工厂类），这个接口只有一个`execute()`方法，最后我们看一下整个继承树：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gts6mtkci5j60b009lglq02.jpg)\n\n\n\n## 二、ExecutorService的创建\n\n创建一个什么样的ExecutorService的实例（即线程池）需要g根据具体应用场景而定，不过Java给我们提供了一个`Executors工厂类`，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：\n\n1. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\n**注意：线程池只是为了控制应用中处理某项业务中防止高并发问题带来的线程不安全的发生的概率。在我目前的测试用，还没有发现线程可以重用这个概念，因为线程开启后，用完就关闭了，不可以再次开启的，查看源码发现会每次新创建一个线程用来处理业务。我们可以通过线程池指定处理这项业务最大的同步线程数，**\n\n**比如：Executors.newFixedThreadPool(3);在线程池中保持三个线程可以同时执行，但是注意，并不是说线程池中永远都是这三个线程，只是说可以同时存在的线程数，当某个线程执行结束后，会有新的线程进来。newFixedThreadPool.execute(new ThreadForpools());这句话的含义并不是添加新的线程，而是添加新的处理业务请求进来。至少我当前是这么理解的，没有发现线程可以重复使用。**\n\n\n\nrunWorker（）通过循环来取任务 通过getTask()方法。这里也就是说worker的run（）方法执行了多个任务，从而实现重复使用。多个任务本来是多个线程run（）方法执行，这里实现了一个run（）执行多个任务。\n\ngetTask()方法里用了一个死循环获取任务，如果没有任务时，并且没有受到超时和shutdown命令时，线程将会一直被阻塞在这个方法里。从而实现了线程没有被销毁的目的。\n\n\n\n## 三、ExecutorService的使用\n\n```java\nExecutorService executorService = Executors.newFixedThreadPool(10);\n\nexecutorService.execute(new Runnable() {\npublic void run() {\n    System.out.println(\"Asynchronous task\");\n}\n});\n```\n\n## 四、ExecutorService的执行\n\nExecutorService有如下几个执行方法：\n\n- execute(Runnable)\n- submit(Runnable)\n- submit(Callable)\n- invokeAny(...)\n- invokeAll(...)\n\n### 4.1 execute(Runnable)\n\n这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：\n\n```java\nExecutorService executorService = Executors.newSingleThreadExecutor();\n\nexecutorService.execute(new Runnable() {\npublic void run() {\n    System.out.println(\"Asynchronous task\");\n}\n});\n\nexecutorService.shutdown();\n\n```\n\n\n\nExecutors.newSingleThreadExecutor()这种的实现方式，看名字我们就应该知道是使用单线程重来支持的。\n\njdk的注释说明有介绍 ，它和其他的实现 newFixedThreadPool(1)代码的区别在于，它不支持设置corePoolSize。保证不可使用额外的线程。\n\nFinalizableDelegatedExecutorService重写了finalize方法，并且在该方法中调用了super.shutdown()。它实现了在GC的时候会关闭线程。\n\n\n主线程就是执行main函数的线程，A线程创建B，那么B就是A的子线程","source":"_posts/8月24日.md","raw":"---\ntitle: 8月24日\ndate: 2021-08-24 09:23:18\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtrmb59gkcj60u0190q8p02.jpg\n---\n\n前几天太忙了，鸽了几天\n\n\n\n@PostConstruct基本：\n@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。\n\nJava中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。\n\n通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：\n\nConstructor(构造方法) -> @Autowired(依赖注入) -> @PostConstruct(注释的方法)\n\n应用：在静态方法中调用依赖注入的Bean中的方法。\n\n\n\n看端口\n\n```\nserver.port:\n```\n\n# countDownLatch\n\n- countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。\n- 存在于java.util.cucurrent包下。\n\n概念\n\n\n\n- countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。\n- 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。\n\n\n\n\n\n\n\n## 一、ExecutorService介绍\n\n**ExecutorService**是Java中对线程池定义的一个接口，它`java.util.concurrent`包中，在这个接口中定义了和后台任务执行相关的方法：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gts6lncwarj60ch07vwf102.jpg)\n\n\n\nJava API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类（详细了解这两个实现类，[点击这里](http://blog.csdn.net/suifeng3051/article/details/49444177)）：\n\n1. ThreadPoolExecutor \n\n2. ScheduledThreadPoolExecutor\n\n除此之外，ExecutorService还继承了`Executor`接口（注意区分Executor接口和Executors工厂类），这个接口只有一个`execute()`方法，最后我们看一下整个继承树：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gts6mtkci5j60b009lglq02.jpg)\n\n\n\n## 二、ExecutorService的创建\n\n创建一个什么样的ExecutorService的实例（即线程池）需要g根据具体应用场景而定，不过Java给我们提供了一个`Executors工厂类`，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：\n\n1. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\n4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n\n**注意：线程池只是为了控制应用中处理某项业务中防止高并发问题带来的线程不安全的发生的概率。在我目前的测试用，还没有发现线程可以重用这个概念，因为线程开启后，用完就关闭了，不可以再次开启的，查看源码发现会每次新创建一个线程用来处理业务。我们可以通过线程池指定处理这项业务最大的同步线程数，**\n\n**比如：Executors.newFixedThreadPool(3);在线程池中保持三个线程可以同时执行，但是注意，并不是说线程池中永远都是这三个线程，只是说可以同时存在的线程数，当某个线程执行结束后，会有新的线程进来。newFixedThreadPool.execute(new ThreadForpools());这句话的含义并不是添加新的线程，而是添加新的处理业务请求进来。至少我当前是这么理解的，没有发现线程可以重复使用。**\n\n\n\nrunWorker（）通过循环来取任务 通过getTask()方法。这里也就是说worker的run（）方法执行了多个任务，从而实现重复使用。多个任务本来是多个线程run（）方法执行，这里实现了一个run（）执行多个任务。\n\ngetTask()方法里用了一个死循环获取任务，如果没有任务时，并且没有受到超时和shutdown命令时，线程将会一直被阻塞在这个方法里。从而实现了线程没有被销毁的目的。\n\n\n\n## 三、ExecutorService的使用\n\n```java\nExecutorService executorService = Executors.newFixedThreadPool(10);\n\nexecutorService.execute(new Runnable() {\npublic void run() {\n    System.out.println(\"Asynchronous task\");\n}\n});\n```\n\n## 四、ExecutorService的执行\n\nExecutorService有如下几个执行方法：\n\n- execute(Runnable)\n- submit(Runnable)\n- submit(Callable)\n- invokeAny(...)\n- invokeAll(...)\n\n### 4.1 execute(Runnable)\n\n这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：\n\n```java\nExecutorService executorService = Executors.newSingleThreadExecutor();\n\nexecutorService.execute(new Runnable() {\npublic void run() {\n    System.out.println(\"Asynchronous task\");\n}\n});\n\nexecutorService.shutdown();\n\n```\n\n\n\nExecutors.newSingleThreadExecutor()这种的实现方式，看名字我们就应该知道是使用单线程重来支持的。\n\njdk的注释说明有介绍 ，它和其他的实现 newFixedThreadPool(1)代码的区别在于，它不支持设置corePoolSize。保证不可使用额外的线程。\n\nFinalizableDelegatedExecutorService重写了finalize方法，并且在该方法中调用了super.shutdown()。它实现了在GC的时候会关闭线程。\n\n\n主线程就是执行main函数的线程，A线程创建B，那么B就是A的子线程","slug":"8月24日","published":1,"updated":"2021-08-24T15:32:58.344Z","_id":"cksphebcv00019d76dkdxbww1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前几天太忙了，鸽了几天</p>\n<p>@PostConstruct基本：<br>@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。</p>\n<p>Java中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。</p>\n<p>通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：</p>\n<p>Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)</p>\n<p>应用：在静态方法中调用依赖注入的Bean中的方法。</p>\n<p>看端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port:</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"countDownLatch\"><a href=\"#countDownLatch\" class=\"headerlink\" title=\"countDownLatch\"></a>countDownLatch</h1><ul>\n<li>countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。</li>\n<li>存在于java.util.cucurrent包下。</li>\n</ul>\n<p>概念</p>\n<ul>\n<li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li>\n<li>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li>\n</ul>\n<h2 id=\"一、ExecutorService介绍\"><a href=\"#一、ExecutorService介绍\" class=\"headerlink\" title=\"一、ExecutorService介绍\"></a>一、ExecutorService介绍</h2><p><strong>ExecutorService</strong>是Java中对线程池定义的一个接口，它<code>java.util.concurrent</code>包中，在这个接口中定义了和后台任务执行相关的方法：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gts6lncwarj60ch07vwf102.jpg\"></p>\n<p>Java API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类（详细了解这两个实现类，<a href=\"http://blog.csdn.net/suifeng3051/article/details/49444177\">点击这里</a>）：</p>\n<ol>\n<li><p>ThreadPoolExecutor </p>\n</li>\n<li><p>ScheduledThreadPoolExecutor</p>\n</li>\n</ol>\n<p>除此之外，ExecutorService还继承了<code>Executor</code>接口（注意区分Executor接口和Executors工厂类），这个接口只有一个<code>execute()</code>方法，最后我们看一下整个继承树：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gts6mtkci5j60b009lglq02.jpg\"></p>\n<h2 id=\"二、ExecutorService的创建\"><a href=\"#二、ExecutorService的创建\" class=\"headerlink\" title=\"二、ExecutorService的创建\"></a>二、ExecutorService的创建</h2><p>创建一个什么样的ExecutorService的实例（即线程池）需要g根据具体应用场景而定，不过Java给我们提供了一个<code>Executors工厂类</code>，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：</p>\n<ol>\n<li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>\n<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>\n<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li>\n<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>\n</ol>\n<p><strong>注意：线程池只是为了控制应用中处理某项业务中防止高并发问题带来的线程不安全的发生的概率。在我目前的测试用，还没有发现线程可以重用这个概念，因为线程开启后，用完就关闭了，不可以再次开启的，查看源码发现会每次新创建一个线程用来处理业务。我们可以通过线程池指定处理这项业务最大的同步线程数，</strong></p>\n<p><strong>比如：Executors.newFixedThreadPool(3);在线程池中保持三个线程可以同时执行，但是注意，并不是说线程池中永远都是这三个线程，只是说可以同时存在的线程数，当某个线程执行结束后，会有新的线程进来。newFixedThreadPool.execute(new ThreadForpools());这句话的含义并不是添加新的线程，而是添加新的处理业务请求进来。至少我当前是这么理解的，没有发现线程可以重复使用。</strong></p>\n<p>runWorker（）通过循环来取任务 通过getTask()方法。这里也就是说worker的run（）方法执行了多个任务，从而实现重复使用。多个任务本来是多个线程run（）方法执行，这里实现了一个run（）执行多个任务。</p>\n<p>getTask()方法里用了一个死循环获取任务，如果没有任务时，并且没有受到超时和shutdown命令时，线程将会一直被阻塞在这个方法里。从而实现了线程没有被销毁的目的。</p>\n<h2 id=\"三、ExecutorService的使用\"><a href=\"#三、ExecutorService的使用\" class=\"headerlink\" title=\"三、ExecutorService的使用\"></a>三、ExecutorService的使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">executorService.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Asynchronous task&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、ExecutorService的执行\"><a href=\"#四、ExecutorService的执行\" class=\"headerlink\" title=\"四、ExecutorService的执行\"></a>四、ExecutorService的执行</h2><p>ExecutorService有如下几个执行方法：</p>\n<ul>\n<li>execute(Runnable)</li>\n<li>submit(Runnable)</li>\n<li>submit(Callable)</li>\n<li>invokeAny(…)</li>\n<li>invokeAll(…)</li>\n</ul>\n<h3 id=\"4-1-execute-Runnable\"><a href=\"#4-1-execute-Runnable\" class=\"headerlink\" title=\"4.1 execute(Runnable)\"></a>4.1 execute(Runnable)</h3><p>这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">executorService.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Asynchronous task&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">executorService.shutdown();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Executors.newSingleThreadExecutor()这种的实现方式，看名字我们就应该知道是使用单线程重来支持的。</p>\n<p>jdk的注释说明有介绍 ，它和其他的实现 newFixedThreadPool(1)代码的区别在于，它不支持设置corePoolSize。保证不可使用额外的线程。</p>\n<p>FinalizableDelegatedExecutorService重写了finalize方法，并且在该方法中调用了super.shutdown()。它实现了在GC的时候会关闭线程。</p>\n<p>主线程就是执行main函数的线程，A线程创建B，那么B就是A的子线程</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前几天太忙了，鸽了几天</p>\n<p>@PostConstruct基本：<br>@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。</p>\n<p>Java中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。</p>\n<p>通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：</p>\n<p>Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)</p>\n<p>应用：在静态方法中调用依赖注入的Bean中的方法。</p>\n<p>看端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port:</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"countDownLatch\"><a href=\"#countDownLatch\" class=\"headerlink\" title=\"countDownLatch\"></a>countDownLatch</h1><ul>\n<li>countDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、concurrentHashMap和BlockingQueue。</li>\n<li>存在于java.util.cucurrent包下。</li>\n</ul>\n<p>概念</p>\n<ul>\n<li>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li>\n<li>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li>\n</ul>\n<h2 id=\"一、ExecutorService介绍\"><a href=\"#一、ExecutorService介绍\" class=\"headerlink\" title=\"一、ExecutorService介绍\"></a>一、ExecutorService介绍</h2><p><strong>ExecutorService</strong>是Java中对线程池定义的一个接口，它<code>java.util.concurrent</code>包中，在这个接口中定义了和后台任务执行相关的方法：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gts6lncwarj60ch07vwf102.jpg\"></p>\n<p>Java API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类（详细了解这两个实现类，<a href=\"http://blog.csdn.net/suifeng3051/article/details/49444177\">点击这里</a>）：</p>\n<ol>\n<li><p>ThreadPoolExecutor </p>\n</li>\n<li><p>ScheduledThreadPoolExecutor</p>\n</li>\n</ol>\n<p>除此之外，ExecutorService还继承了<code>Executor</code>接口（注意区分Executor接口和Executors工厂类），这个接口只有一个<code>execute()</code>方法，最后我们看一下整个继承树：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gts6mtkci5j60b009lglq02.jpg\"></p>\n<h2 id=\"二、ExecutorService的创建\"><a href=\"#二、ExecutorService的创建\" class=\"headerlink\" title=\"二、ExecutorService的创建\"></a>二、ExecutorService的创建</h2><p>创建一个什么样的ExecutorService的实例（即线程池）需要g根据具体应用场景而定，不过Java给我们提供了一个<code>Executors工厂类</code>，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：</p>\n<ol>\n<li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>\n<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>\n<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li>\n<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>\n</ol>\n<p><strong>注意：线程池只是为了控制应用中处理某项业务中防止高并发问题带来的线程不安全的发生的概率。在我目前的测试用，还没有发现线程可以重用这个概念，因为线程开启后，用完就关闭了，不可以再次开启的，查看源码发现会每次新创建一个线程用来处理业务。我们可以通过线程池指定处理这项业务最大的同步线程数，</strong></p>\n<p><strong>比如：Executors.newFixedThreadPool(3);在线程池中保持三个线程可以同时执行，但是注意，并不是说线程池中永远都是这三个线程，只是说可以同时存在的线程数，当某个线程执行结束后，会有新的线程进来。newFixedThreadPool.execute(new ThreadForpools());这句话的含义并不是添加新的线程，而是添加新的处理业务请求进来。至少我当前是这么理解的，没有发现线程可以重复使用。</strong></p>\n<p>runWorker（）通过循环来取任务 通过getTask()方法。这里也就是说worker的run（）方法执行了多个任务，从而实现重复使用。多个任务本来是多个线程run（）方法执行，这里实现了一个run（）执行多个任务。</p>\n<p>getTask()方法里用了一个死循环获取任务，如果没有任务时，并且没有受到超时和shutdown命令时，线程将会一直被阻塞在这个方法里。从而实现了线程没有被销毁的目的。</p>\n<h2 id=\"三、ExecutorService的使用\"><a href=\"#三、ExecutorService的使用\" class=\"headerlink\" title=\"三、ExecutorService的使用\"></a>三、ExecutorService的使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">executorService.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Asynchronous task&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、ExecutorService的执行\"><a href=\"#四、ExecutorService的执行\" class=\"headerlink\" title=\"四、ExecutorService的执行\"></a>四、ExecutorService的执行</h2><p>ExecutorService有如下几个执行方法：</p>\n<ul>\n<li>execute(Runnable)</li>\n<li>submit(Runnable)</li>\n<li>submit(Callable)</li>\n<li>invokeAny(…)</li>\n<li>invokeAll(…)</li>\n</ul>\n<h3 id=\"4-1-execute-Runnable\"><a href=\"#4-1-execute-Runnable\" class=\"headerlink\" title=\"4.1 execute(Runnable)\"></a>4.1 execute(Runnable)</h3><p>这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">executorService.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Asynchronous task&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">executorService.shutdown();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Executors.newSingleThreadExecutor()这种的实现方式，看名字我们就应该知道是使用单线程重来支持的。</p>\n<p>jdk的注释说明有介绍 ，它和其他的实现 newFixedThreadPool(1)代码的区别在于，它不支持设置corePoolSize。保证不可使用额外的线程。</p>\n<p>FinalizableDelegatedExecutorService重写了finalize方法，并且在该方法中调用了super.shutdown()。它实现了在GC的时候会关闭线程。</p>\n<p>主线程就是执行main函数的线程，A线程创建B，那么B就是A的子线程</p>\n"},{"title":"8月25日","date":"2021-08-25T10:26:46.000Z","thumbnail":null,"_content":"被sql安排的明明白白的一天\n\njpa实体类和数据库字段的命名规则，数据库中一定要用下划线，\n\n\n\ngroup_by的意思是根据by对数据**按照哪个字段进行分组**，或者**哪几个字段进行分组**\n\nselect   字段    from   表名   where    条件     group   by       字段\n\n或者\n\nselect   字段    from   表名   group  by    字段    having    过滤条件\n\n注意：对于过滤条件，可以先用where，再用group  by或者是先用group  by，再用having\n\n两者选其一\n\n**常用的聚合函数：count() , sum() , avg() , max() , min()**\n\nselect  name , count(*)  from  student  group  by  name      查看表中相同人名的个数\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtt8keppqmj604p02e3ye02.jpg)\n\nselect  name , sum(salary)  from  student  group  by  name    查看表中人员的工资和（同姓的工资相加）\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtt8kw95rbj605702fa9z02.jpg)\n\nselect  name , avg(salary)  from  student  group  by  name  , grade    查看表中人员的工资平均数（同姓工资平均数）\n\n得出的如下结果\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtt8l97ofbj605902c3yf02.jpg)\n\nselect  grade , max(salary)  from  student  group  by  grade      查看按等级划分人员工资最大值\n\n得出的如下结果\n\n![img](https://img-blog.csdn.net/20180914003230722)\n\nselect  grade , min(salary)  from  student  group  by  grade     查看按等级划分人员工资最小值\n\n得出的如下结果\n\n![img](https://img-blog.csdn.net/20180914003320251)\n\n# 将 list 转换为 分页Page\n\npublic static <T> Page<T> listConvertToPage(List<T> list, long total, Pageable pageable)\n\n","source":"_posts/8月25日.md","raw":"---\ntitle: 8月25日\ndate: 2021-08-25 18:26:46\ncategories:\ntags:\nthumbnail:\n---\n被sql安排的明明白白的一天\n\njpa实体类和数据库字段的命名规则，数据库中一定要用下划线，\n\n\n\ngroup_by的意思是根据by对数据**按照哪个字段进行分组**，或者**哪几个字段进行分组**\n\nselect   字段    from   表名   where    条件     group   by       字段\n\n或者\n\nselect   字段    from   表名   group  by    字段    having    过滤条件\n\n注意：对于过滤条件，可以先用where，再用group  by或者是先用group  by，再用having\n\n两者选其一\n\n**常用的聚合函数：count() , sum() , avg() , max() , min()**\n\nselect  name , count(*)  from  student  group  by  name      查看表中相同人名的个数\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtt8keppqmj604p02e3ye02.jpg)\n\nselect  name , sum(salary)  from  student  group  by  name    查看表中人员的工资和（同姓的工资相加）\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtt8kw95rbj605702fa9z02.jpg)\n\nselect  name , avg(salary)  from  student  group  by  name  , grade    查看表中人员的工资平均数（同姓工资平均数）\n\n得出的如下结果\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtt8l97ofbj605902c3yf02.jpg)\n\nselect  grade , max(salary)  from  student  group  by  grade      查看按等级划分人员工资最大值\n\n得出的如下结果\n\n![img](https://img-blog.csdn.net/20180914003230722)\n\nselect  grade , min(salary)  from  student  group  by  grade     查看按等级划分人员工资最小值\n\n得出的如下结果\n\n![img](https://img-blog.csdn.net/20180914003320251)\n\n# 将 list 转换为 分页Page\n\npublic static <T> Page<T> listConvertToPage(List<T> list, long total, Pageable pageable)\n\n","slug":"8月25日","published":1,"updated":"2021-08-25T13:45:23.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckssrccnr00006y767pz2ar8p","content":"<p>被sql安排的明明白白的一天</p>\n<p>jpa实体类和数据库字段的命名规则，数据库中一定要用下划线，</p>\n<p>group_by的意思是根据by对数据<strong>按照哪个字段进行分组</strong>，或者<strong>哪几个字段进行分组</strong></p>\n<p>select   字段    from   表名   where    条件     group   by       字段</p>\n<p>或者</p>\n<p>select   字段    from   表名   group  by    字段    having    过滤条件</p>\n<p>注意：对于过滤条件，可以先用where，再用group  by或者是先用group  by，再用having</p>\n<p>两者选其一</p>\n<p><strong>常用的聚合函数：count() , sum() , avg() , max() , min()</strong></p>\n<p>select  name , count(*)  from  student  group  by  name      查看表中相同人名的个数</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt8keppqmj604p02e3ye02.jpg\"></p>\n<p>select  name , sum(salary)  from  student  group  by  name    查看表中人员的工资和（同姓的工资相加）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt8kw95rbj605702fa9z02.jpg\"></p>\n<p>select  name , avg(salary)  from  student  group  by  name  , grade    查看表中人员的工资平均数（同姓工资平均数）</p>\n<p>得出的如下结果</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt8l97ofbj605902c3yf02.jpg\"></p>\n<p>select  grade , max(salary)  from  student  group  by  grade      查看按等级划分人员工资最大值</p>\n<p>得出的如下结果</p>\n<p><img src=\"https://img-blog.csdn.net/20180914003230722\" alt=\"img\"></p>\n<p>select  grade , min(salary)  from  student  group  by  grade     查看按等级划分人员工资最小值</p>\n<p>得出的如下结果</p>\n<p><img src=\"https://img-blog.csdn.net/20180914003320251\" alt=\"img\"></p>\n<h1 id=\"将-list-转换为-分页Page\"><a href=\"#将-list-转换为-分页Page\" class=\"headerlink\" title=\"将 list 转换为 分页Page\"></a>将 list 转换为 分页Page</h1><p>public static <T> Page<T> listConvertToPage(List<T> list, long total, Pageable pageable)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>被sql安排的明明白白的一天</p>\n<p>jpa实体类和数据库字段的命名规则，数据库中一定要用下划线，</p>\n<p>group_by的意思是根据by对数据<strong>按照哪个字段进行分组</strong>，或者<strong>哪几个字段进行分组</strong></p>\n<p>select   字段    from   表名   where    条件     group   by       字段</p>\n<p>或者</p>\n<p>select   字段    from   表名   group  by    字段    having    过滤条件</p>\n<p>注意：对于过滤条件，可以先用where，再用group  by或者是先用group  by，再用having</p>\n<p>两者选其一</p>\n<p><strong>常用的聚合函数：count() , sum() , avg() , max() , min()</strong></p>\n<p>select  name , count(*)  from  student  group  by  name      查看表中相同人名的个数</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt8keppqmj604p02e3ye02.jpg\"></p>\n<p>select  name , sum(salary)  from  student  group  by  name    查看表中人员的工资和（同姓的工资相加）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt8kw95rbj605702fa9z02.jpg\"></p>\n<p>select  name , avg(salary)  from  student  group  by  name  , grade    查看表中人员的工资平均数（同姓工资平均数）</p>\n<p>得出的如下结果</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt8l97ofbj605902c3yf02.jpg\"></p>\n<p>select  grade , max(salary)  from  student  group  by  grade      查看按等级划分人员工资最大值</p>\n<p>得出的如下结果</p>\n<p><img src=\"https://img-blog.csdn.net/20180914003230722\" alt=\"img\"></p>\n<p>select  grade , min(salary)  from  student  group  by  grade     查看按等级划分人员工资最小值</p>\n<p>得出的如下结果</p>\n<p><img src=\"https://img-blog.csdn.net/20180914003320251\" alt=\"img\"></p>\n<h1 id=\"将-list-转换为-分页Page\"><a href=\"#将-list-转换为-分页Page\" class=\"headerlink\" title=\"将 list 转换为 分页Page\"></a>将 list 转换为 分页Page</h1><p>public static <T> Page<T> listConvertToPage(List<T> list, long total, Pageable pageable)</p>\n"},{"title":"8月26日","date":"2021-08-26T09:17:59.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gtubmrfh0sj618z0u0afq02.jpg","_content":"\n\n完了，论文要ddl了，忙着公司的事情，根本没时间弄啊，\n\n能一边上班回家还没稳定学习输出的人是真的顶，\n\n还想着平时没事刷刷leetcode和面经呢\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n国内大部分大企业都是mybatis，小公司一般用jpa，国外则jpa用的多。\n\n\n\n```java\n@Transient \nprivate int age;\n```\n\n\n\n此数据不会持久化到数据库中，   \n\n没有主键一定是新增，有主键修改\n\n","source":"_posts/8月26日.md","raw":"---\ntitle: 8月26日\ndate: 2021-08-26 17:17:59\ncategories:\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gtubmrfh0sj618z0u0afq02.jpg\n---\n\n\n完了，论文要ddl了，忙着公司的事情，根本没时间弄啊，\n\n能一边上班回家还没稳定学习输出的人是真的顶，\n\n还想着平时没事刷刷leetcode和面经呢\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n国内大部分大企业都是mybatis，小公司一般用jpa，国外则jpa用的多。\n\n\n\n```java\n@Transient \nprivate int age;\n```\n\n\n\n此数据不会持久化到数据库中，   \n\n没有主键一定是新增，有主键修改\n\n","slug":"8月26日","published":1,"updated":"2021-08-26T12:07:37.563Z","_id":"ckssrccnv00016y762o36ghrb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>完了，论文要ddl了，忙着公司的事情，根本没时间弄啊，</p>\n<p>能一边上班回家还没稳定学习输出的人是真的顶，</p>\n<p>还想着平时没事刷刷leetcode和面经呢</p>\n<p>国内大部分大企业都是mybatis，小公司一般用jpa，国外则jpa用的多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transient</span> </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>此数据不会持久化到数据库中，   </p>\n<p>没有主键一定是新增，有主键修改</p>\n","site":{"data":{}},"excerpt":"","more":"<p>完了，论文要ddl了，忙着公司的事情，根本没时间弄啊，</p>\n<p>能一边上班回家还没稳定学习输出的人是真的顶，</p>\n<p>还想着平时没事刷刷leetcode和面经呢</p>\n<p>国内大部分大企业都是mybatis，小公司一般用jpa，国外则jpa用的多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transient</span> </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>此数据不会持久化到数据库中，   </p>\n<p>没有主键一定是新增，有主键修改</p>\n"},{"title":"8月27","date":"2021-08-27T03:49:09.000Z","thumbnail":null,"_content":"\n\n\n\\#{}和${}\n\n\\#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 \n\n\\#{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。\n\n${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value\n\n\n\ncount(1)会统计包括null值的所有符合条件的字段的条数。\n\ncount(0)将返回表格中所有存在的行的总数包括值为null的行，\n\n然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）\n\ndistinct 列名，得到的结果将是除去值为null和重复数据后的结果 。\n\nCount(列名) 一列中包含值的个数，不包含空值，而count(*)中包含空值\n\n对比下两个执行计划我们可以发现是完全一样的，这也就**说明count(*)和count(1)的执行效率是完全一样**的，**根本不存在所谓的单列扫描和多列扫描的问题。**\n\nCOUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：\n\nCount(0)\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtvfow7ms8j61ag0r80u602.jpg)\n\ncount(1)\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtvfp82yksj61980pojsi02.jpg)\n\n\n\nCount(*)\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtvfq3564ej612u0smgn102.jpg)\n\n\n\n**结论：Count(0)最快，count(1)最慢**\n\n\n\nresultType：直接表示返回类型，包括基础数据类型和复杂数据类型。\n\nresultMap 则是对外部 resultMap 定义的引用，对应外部 resultMap 的 id，表示返回结果映射到哪一个 resultMap 上。它的应用场景一般是：数据库字段信息与对象属性不一致或者需要做复杂的联合查询以便自由控制映射结果。\n\n```java\n@ApiOperation(\"返回底纹\")\n    @RequestMapping(value = \"/inputBox\", method = RequestMethod.GET)\n    public Response queryInputBox(Integer type){\n        return new Response().buildSuccess(channelService.findAllInputBox(type));\n    }\n\n@Override\n    public List<String> findAllInputBox(Integer type) {\n        List<String> list=new ArrayList<>();\n        int cnt=channelMapper.countByTypeAndStatus(type,true);\n        if(cnt!=0){\n            //若无，则为默认底纹 channelName是不会变的，name会变。\n            list.add(channelMapper.findDefaultBox(type));\n        }else{\n            list=channelMapper.findListByType(type,cnt);\n        }\n        return list;\n    }\n\nInteger countByTypeAndStatus(Integer Type, Boolean status);\n\n    List<String> findListByType(Integer type, Integer cnt);\n\n\n    String findDefaultBox(Integer type);\n\n\n    <select id=\"countByTypeAndStatus\" resultType=\"Integer\" >\n        select count(0) from search_inputbox_config where type=#{type} and status=true\n    </select>\n\n    <select id=\"findListByType\" resultMap=\"string\">\n        select name from search_inputbox_config where type=#{type} and status=true order by level ASC limit #{cnt}\n    </select>\n\n\n    <select id=\"findDefaultBox\" resultType=\"string\">\n        select name from search_inputbox_default where type=#{type}\n    </select>\n```\n\n","source":"_posts/8月27.md","raw":"---\ntitle: 8月27\ndate: 2021-08-27 11:49:09\ncategories:\ntags:\nthumbnail:\n---\n\n\n\n\\#{}和${}\n\n\\#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 \n\n\\#{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。\n\n${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value\n\n\n\ncount(1)会统计包括null值的所有符合条件的字段的条数。\n\ncount(0)将返回表格中所有存在的行的总数包括值为null的行，\n\n然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）\n\ndistinct 列名，得到的结果将是除去值为null和重复数据后的结果 。\n\nCount(列名) 一列中包含值的个数，不包含空值，而count(*)中包含空值\n\n对比下两个执行计划我们可以发现是完全一样的，这也就**说明count(*)和count(1)的执行效率是完全一样**的，**根本不存在所谓的单列扫描和多列扫描的问题。**\n\nCOUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：\n\nCount(0)\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtvfow7ms8j61ag0r80u602.jpg)\n\ncount(1)\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtvfp82yksj61980pojsi02.jpg)\n\n\n\nCount(*)\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gtvfq3564ej612u0smgn102.jpg)\n\n\n\n**结论：Count(0)最快，count(1)最慢**\n\n\n\nresultType：直接表示返回类型，包括基础数据类型和复杂数据类型。\n\nresultMap 则是对外部 resultMap 定义的引用，对应外部 resultMap 的 id，表示返回结果映射到哪一个 resultMap 上。它的应用场景一般是：数据库字段信息与对象属性不一致或者需要做复杂的联合查询以便自由控制映射结果。\n\n```java\n@ApiOperation(\"返回底纹\")\n    @RequestMapping(value = \"/inputBox\", method = RequestMethod.GET)\n    public Response queryInputBox(Integer type){\n        return new Response().buildSuccess(channelService.findAllInputBox(type));\n    }\n\n@Override\n    public List<String> findAllInputBox(Integer type) {\n        List<String> list=new ArrayList<>();\n        int cnt=channelMapper.countByTypeAndStatus(type,true);\n        if(cnt!=0){\n            //若无，则为默认底纹 channelName是不会变的，name会变。\n            list.add(channelMapper.findDefaultBox(type));\n        }else{\n            list=channelMapper.findListByType(type,cnt);\n        }\n        return list;\n    }\n\nInteger countByTypeAndStatus(Integer Type, Boolean status);\n\n    List<String> findListByType(Integer type, Integer cnt);\n\n\n    String findDefaultBox(Integer type);\n\n\n    <select id=\"countByTypeAndStatus\" resultType=\"Integer\" >\n        select count(0) from search_inputbox_config where type=#{type} and status=true\n    </select>\n\n    <select id=\"findListByType\" resultMap=\"string\">\n        select name from search_inputbox_config where type=#{type} and status=true order by level ASC limit #{cnt}\n    </select>\n\n\n    <select id=\"findDefaultBox\" resultType=\"string\">\n        select name from search_inputbox_default where type=#{type}\n    </select>\n```\n\n","slug":"8月27","published":1,"updated":"2021-08-27T11:46:59.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksvzdgd1000054f12s491g9s","content":"<p>#{}和${}</p>\n<p>#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 </p>\n<p>#{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p>\n<p>${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value</p>\n<p>count(1)会统计包括null值的所有符合条件的字段的条数。</p>\n<p>count(0)将返回表格中所有存在的行的总数包括值为null的行，</p>\n<p>然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）</p>\n<p>distinct 列名，得到的结果将是除去值为null和重复数据后的结果 。</p>\n<p>Count(列名) 一列中包含值的个数，不包含空值，而count(*)中包含空值</p>\n<p>对比下两个执行计划我们可以发现是完全一样的，这也就<strong>说明count(*)和count(1)的执行效率是完全一样</strong>的，<strong>根本不存在所谓的单列扫描和多列扫描的问题。</strong></p>\n<p>COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：</p>\n<p>Count(0)</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtvfow7ms8j61ag0r80u602.jpg\"></p>\n<p>count(1)</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtvfp82yksj61980pojsi02.jpg\"></p>\n<p>Count(*)</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtvfq3564ej612u0smgn102.jpg\"></p>\n<p><strong>结论：Count(0)最快，count(1)最慢</strong></p>\n<p>resultType：直接表示返回类型，包括基础数据类型和复杂数据类型。</p>\n<p>resultMap 则是对外部 resultMap 定义的引用，对应外部 resultMap 的 id，表示返回结果映射到哪一个 resultMap 上。它的应用场景一般是：数据库字段信息与对象属性不一致或者需要做复杂的联合查询以便自由控制映射结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ApiOperation(&quot;返回底纹&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/inputBox&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">queryInputBox</span><span class=\"params\">(Integer type)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response().buildSuccess(channelService.findAllInputBox(type));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findAllInputBox</span><span class=\"params\">(Integer type)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=channelMapper.countByTypeAndStatus(type,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//若无，则为默认底纹 channelName是不会变的，name会变。</span></span><br><span class=\"line\">            list.add(channelMapper.findDefaultBox(type));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            list=channelMapper.findListByType(type,cnt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">countByTypeAndStatus</span><span class=\"params\">(Integer Type, Boolean status)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;String&gt; <span class=\"title\">findListByType</span><span class=\"params\">(Integer type, Integer cnt)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">findDefaultBox</span><span class=\"params\">(Integer type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">&quot;countByTypeAndStatus&quot;</span> resultType=<span class=\"string\">&quot;Integer&quot;</span> &gt;</span><br><span class=\"line\">        <span class=\"function\">select <span class=\"title\">count</span><span class=\"params\">(<span class=\"number\">0</span>)</span> from search_inputbox_config where type</span>=#&#123;type&#125; and status=<span class=\"keyword\">true</span></span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">&quot;findListByType&quot;</span> resultMap=<span class=\"string\">&quot;string&quot;</span>&gt;</span><br><span class=\"line\">        select name from search_inputbox_config where type=#&#123;type&#125; and status=<span class=\"keyword\">true</span> order by level ASC limit #&#123;cnt&#125;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">&quot;findDefaultBox&quot;</span> resultType=<span class=\"string\">&quot;string&quot;</span>&gt;</span><br><span class=\"line\">        select name from search_inputbox_default where type=#&#123;type&#125;</span><br><span class=\"line\">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>#{}和${}</p>\n<p>#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 </p>\n<p>#{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p>\n<p>${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value</p>\n<p>count(1)会统计包括null值的所有符合条件的字段的条数。</p>\n<p>count(0)将返回表格中所有存在的行的总数包括值为null的行，</p>\n<p>然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）</p>\n<p>distinct 列名，得到的结果将是除去值为null和重复数据后的结果 。</p>\n<p>Count(列名) 一列中包含值的个数，不包含空值，而count(*)中包含空值</p>\n<p>对比下两个执行计划我们可以发现是完全一样的，这也就<strong>说明count(*)和count(1)的执行效率是完全一样</strong>的，<strong>根本不存在所谓的单列扫描和多列扫描的问题。</strong></p>\n<p>COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：</p>\n<p>Count(0)</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtvfow7ms8j61ag0r80u602.jpg\"></p>\n<p>count(1)</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtvfp82yksj61980pojsi02.jpg\"></p>\n<p>Count(*)</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtvfq3564ej612u0smgn102.jpg\"></p>\n<p><strong>结论：Count(0)最快，count(1)最慢</strong></p>\n<p>resultType：直接表示返回类型，包括基础数据类型和复杂数据类型。</p>\n<p>resultMap 则是对外部 resultMap 定义的引用，对应外部 resultMap 的 id，表示返回结果映射到哪一个 resultMap 上。它的应用场景一般是：数据库字段信息与对象属性不一致或者需要做复杂的联合查询以便自由控制映射结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ApiOperation(&quot;返回底纹&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/inputBox&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">queryInputBox</span><span class=\"params\">(Integer type)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response().buildSuccess(channelService.findAllInputBox(type));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findAllInputBox</span><span class=\"params\">(Integer type)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list=<span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt=channelMapper.countByTypeAndStatus(type,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//若无，则为默认底纹 channelName是不会变的，name会变。</span></span><br><span class=\"line\">            list.add(channelMapper.findDefaultBox(type));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            list=channelMapper.findListByType(type,cnt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Integer <span class=\"title\">countByTypeAndStatus</span><span class=\"params\">(Integer Type, Boolean status)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;String&gt; <span class=\"title\">findListByType</span><span class=\"params\">(Integer type, Integer cnt)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">findDefaultBox</span><span class=\"params\">(Integer type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">&quot;countByTypeAndStatus&quot;</span> resultType=<span class=\"string\">&quot;Integer&quot;</span> &gt;</span><br><span class=\"line\">        <span class=\"function\">select <span class=\"title\">count</span><span class=\"params\">(<span class=\"number\">0</span>)</span> from search_inputbox_config where type</span>=#&#123;type&#125; and status=<span class=\"keyword\">true</span></span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">&quot;findListByType&quot;</span> resultMap=<span class=\"string\">&quot;string&quot;</span>&gt;</span><br><span class=\"line\">        select name from search_inputbox_config where type=#&#123;type&#125; and status=<span class=\"keyword\">true</span> order by level ASC limit #&#123;cnt&#125;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;select id=<span class=\"string\">&quot;findDefaultBox&quot;</span> resultType=<span class=\"string\">&quot;string&quot;</span>&gt;</span><br><span class=\"line\">        select name from search_inputbox_default where type=#&#123;type&#125;</span><br><span class=\"line\">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim\n\n","source":"_posts/数据库调查报告.md","raw":"SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim\n\n","slug":"数据库调查报告","published":1,"date":"2021-08-28T11:02:52.191Z","updated":"2021-08-28T15:31:37.277Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cksvzdgda000154f1cn7fcyj7","content":"<p>SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim</p>\n","site":{"data":{}},"excerpt":"","more":"<p>SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cksiamo8d0009c3765cfl1b01","category_id":"cksiamo8m000lc376cbknfz6a","_id":"cksiamo8r000vc376e1fvaoz3"},{"post_id":"cksiamo8p000rc3762d7qdm2f","category_id":"cksiamo8m000lc376cbknfz6a","_id":"cksiamo8t000zc3764ya5h97s"},{"post_id":"cksiamo7l0001c376aarfec7b","category_id":"cksiamo7v0004c376eucweamp","_id":"cksiamo8u0012c3765c2ug0jh"},{"post_id":"cksiamo7l0001c376aarfec7b","category_id":"cksiamo8o000qc3766vfx401m","_id":"cksiamo8v0014c376f9knb9kc"},{"post_id":"cksiamo8q000tc376ftsgffw0","category_id":"cksiamo8m000lc376cbknfz6a","_id":"cksiamo8w0017c376cdrt7kri"},{"post_id":"cksiamo8r000xc37660bn7w9h","category_id":"cksiamo8m000lc376cbknfz6a","_id":"cksiamo8x0019c3767opc9yfn"},{"post_id":"cksiamo7q0003c376bam8bwcb","category_id":"cksiamo7v0004c376eucweamp","_id":"cksiamo8y001bc376bgrf3i49"},{"post_id":"cksiamo7q0003c376bam8bwcb","category_id":"cksiamo8o000qc3766vfx401m","_id":"cksiamo8z001cc3763y80e2ey"},{"post_id":"cksiamo840007c3769ucjfej4","category_id":"cksiamo7v0004c376eucweamp","_id":"cksiamo8z001ec3762ydl2i45"},{"post_id":"cksiamo840007c3769ucjfej4","category_id":"cksiamo8o000qc3766vfx401m","_id":"cksiamo8z001fc376as8o2018"},{"post_id":"cksiamo8l000kc3769v262xmd","category_id":"cksiamo8m000lc376cbknfz6a","_id":"cksiamo90001gc376d199bl00"},{"post_id":"cksiamo8x0018c376haj31x4q","category_id":"cksiamo7v0004c376eucweamp","_id":"cksiamo90001hc3764teudcr0"},{"post_id":"cksiamo8o000pc37621j8hrre","category_id":"cksiamo7v0004c376eucweamp","_id":"cksiamo90001ic376dsrp6gkc"},{"post_id":"cksiamo8o000pc37621j8hrre","category_id":"cksiamo8o000qc3766vfx401m","_id":"cksiamo90001jc3767nvigp72"},{"post_id":"cksiamo8v0016c3767s3se0hu","category_id":"cksiamo8z001dc3764uo1ae18","_id":"cksiamo90001kc3762i3gh8ja"},{"post_id":"cksiamo9b001lc37612yj4hbz","category_id":"cksiamo9c001mc376d9sc535y","_id":"cksiamo9c001oc37663n52q0v"},{"post_id":"cksiamo9b001lc37612yj4hbz","category_id":"cksiamo9c001nc3765lbvetkk","_id":"cksiamo9c001pc3769nzx2m1y"},{"post_id":"cksiamo9d001qc376hycu6d9y","category_id":"cksiamo9c001mc376d9sc535y","_id":"cksiamo9e001rc376e5og2hnk"}],"PostTag":[{"post_id":"cksiamo7l0001c376aarfec7b","tag_id":"cksiamo7x0005c376djj2bszm","_id":"cksiamo8l000jc3763rs50mxf"},{"post_id":"cksiamo7l0001c376aarfec7b","tag_id":"cksiamo8f000dc3763ftp2gxv","_id":"cksiamo8m000mc37649aub5or"},{"post_id":"cksiamo840007c3769ucjfej4","tag_id":"cksiamo7x0005c376djj2bszm","_id":"cksiamo8p000sc3766ppt9xq5"},{"post_id":"cksiamo840007c3769ucjfej4","tag_id":"cksiamo8f000dc3763ftp2gxv","_id":"cksiamo8q000uc376gyyra5xo"}],"Tag":[{"name":"java","_id":"cksiamo7x0005c376djj2bszm"},{"name":"框架","_id":"cksiamo8f000dc3763ftp2gxv"}]}}