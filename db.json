{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/miccall/source/css/backcss.css","path":"css/backcss.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/demo.css","path":"css/demo.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/dropdownMenu.css","path":"css/dropdownMenu.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/gallery.css","path":"css/gallery.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/item.css","path":"css/item.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/mic_gallery.css","path":"css/mic_gallery.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/mic_main.css","path":"css/mic_main.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/my_link.css","path":"css/my_link.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/normalize.css","path":"css/normalize.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/noscript.css","path":"css/noscript.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/ok_prism.css","path":"css/ok_prism.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism.css","path":"css/prism.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_coy.css","path":"css/prism_coy.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_dark.css","path":"css/prism_dark.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_default.css","path":"css/prism_default.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_funky.css","path":"css/prism_funky.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_okaidia.css","path":"css/prism_okaidia.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_solarized.css","path":"css/prism_solarized.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/prism_twilight.css","path":"css/prism_twilight.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/typo.css","path":"css/typo.css","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/FZLT.ttf","path":"fonts/FZLT.ttf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/logo_miccall.png","path":"img/logo_miccall.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/12.jpg","path":"images/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/21.jpg","path":"images/21.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/3123.jpg","path":"images/3123.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/WechatIMG501.jpeg","path":"images/WechatIMG501.jpeg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/me.jpg","path":"images/me.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/overlay.png","path":"images/overlay.png","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","path":"images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic01.jpg","path":"images/pic01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic02.jpg","path":"images/pic02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic03.jpg","path":"images/pic03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic04.jpg","path":"images/pic04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic05.jpg","path":"images/pic05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic06.jpg","path":"images/pic06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic07.jpg","path":"images/pic07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic08.jpg","path":"images/pic08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic09.jpg","path":"images/pic09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic10.jpg","path":"images/pic10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic11.jpg","path":"images/pic11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/pic12.jpg","path":"images/pic12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/picx03.jpg","path":"images/picx03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery_skel.min.js","path":"js/gallery_skel.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrollex.min.js","path":"js/jquery.scrollex.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/jquery.scrolly.min.js","path":"js/jquery.scrolly.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/mic_gallery.js","path":"js/mic_gallery.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/prism.js","path":"js/prism.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/skel.min.js","path":"js/skel.min.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/arrow-small.svg","path":"css/images/arrow-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/arrow.svg","path":"css/images/arrow.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close-small-alt.svg","path":"css/images/close-small-alt.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close-small.svg","path":"css/images/close-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/close.svg","path":"css/images/close.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/open-small.svg","path":"css/images/open-small.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/open.svg","path":"css/images/open.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/css/images/spinner.svg","path":"css/images/spinner.svg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/01.jpg","path":"images/fulls/01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/02.jpg","path":"images/fulls/02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/03.jpg","path":"images/fulls/03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/04.jpg","path":"images/fulls/04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/05.jpg","path":"images/fulls/05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/06.jpg","path":"images/fulls/06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/07.jpg","path":"images/fulls/07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/08.jpg","path":"images/fulls/08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/09.jpg","path":"images/fulls/09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/10.jpg","path":"images/fulls/10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/11.jpg","path":"images/fulls/11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/fulls/12.jpg","path":"images/fulls/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/01.jpg","path":"images/thumbs/01.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/02.jpg","path":"images/thumbs/02.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/03.jpg","path":"images/thumbs/03.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/04.jpg","path":"images/thumbs/04.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/05.jpg","path":"images/thumbs/05.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/06.jpg","path":"images/thumbs/06.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/07.jpg","path":"images/thumbs/07.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/08.jpg","path":"images/thumbs/08.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/09.jpg","path":"images/thumbs/09.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/10.jpg","path":"images/thumbs/10.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/11.jpg","path":"images/thumbs/11.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/images/thumbs/12.jpg","path":"images/thumbs/12.jpg","modified":0,"renderable":1},{"_id":"themes/miccall/source/js/gallery/gallery.js","path":"js/gallery/gallery.js","modified":0,"renderable":1},{"_id":"themes/miccall/source/img/sunset.jpg","path":"img/sunset.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/.DS_Store","hash":"d12d5b032be3a2db7df4eda434e983852cb22c98","modified":1627713022032},{"_id":"source/_posts/7月31号.md","hash":"6af743062c8309d6e62ee2321b5e2d0f57e63ee7","modified":1627724896686},{"_id":"source/_posts/7月29日.md","hash":"28d723ec10610b12a2176ac2a085c1ac26183a54","modified":1627709648783},{"_id":"source/_posts/盘点我从无到有搭建一个Springboot遇到的坑.md","hash":"352dcb32f3bb2b61e249afb347566dc716af0aa2","modified":1627725437094},{"_id":"source/.DS_Store","hash":"d7145f87b1a715414bdd78372376c8ede565b814","modified":1627723743473},{"_id":"source/Java/index.md","hash":"14e376b465c1c78ea1ea7084ba350b79252b6fc8","modified":1627711294152},{"_id":"source/_posts/7月30日.assets/image-20210730124507149.png","hash":"60113adc5033a58898ac0dbd09b5fea94300a05c","modified":1627620307150},{"_id":"source/about/index.md","hash":"9a8cf8854a38e7858cb871b7e369972a8ca97183","modified":1627791750140},{"_id":"source/group/index.md","hash":"9c1f9b0d6c173d9e152dfc42fddda9fec5d11e89","modified":1627709182916},{"_id":"source/_posts/7月30日.md","hash":"3783bd554830bebaa9e61fda329cb39d72f0cc91","modified":1627713081700},{"_id":"themes/miccall/LICENSE","hash":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1540215856000},{"_id":"themes/miccall/_config.yml","hash":"706f3efbe289ef5994883ba5e38a32d7b68f2b7c","modified":1627791784592},{"_id":"themes/miccall/readme.md","hash":"ee36b0cb76c688ed9fa8990eee5c49d5f2b53525","modified":1540215856000},{"_id":"themes/miccall/layout/index.ejs","hash":"f5e1bd35ce8e172ec0b5479066eec55a2ccc6c2f","modified":1540215856000},{"_id":"themes/miccall/layout/post.ejs","hash":"d3c06743dfd9c137b8953e927d80d0099f169034","modified":1540215856000},{"_id":"themes/miccall/.DS_Store","hash":"5b1f36d9077eacd91efac40b500ea41ad56483d3","modified":1627712989325},{"_id":"themes/miccall/layout/layout.ejs","hash":"41bd4dce5bebc122b09908c8336f404dca9db9ab","modified":1540215856000},{"_id":"themes/miccall/source/.DS_Store","hash":"d41550088a3524607dec4b4cb67815d86dea551a","modified":1627712980562},{"_id":"themes/miccall/layout/_partial/copyright.ejs","hash":"03f20eb5997f7132c232393b203fbca6eaec5205","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/footer.ejs","hash":"003361014b1467ce8062557c6c5952abaa9f00aa","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/head.ejs","hash":"de0a31f65a5efe69ffb04511c18b23c0c94f653a","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/gallery_head.ejs","hash":"4bd6fb2bdf51a21b7c5b4e95b0575f7e6ac3dcd1","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/comment.ejs","hash":"c9fb1f98a18ca484cb52d60e2ad2bad25b56dfb2","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/gallery_js.ejs","hash":"2d4bf4e503f72f50e61fba396386dc7d57d3165f","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/mainfirst.ejs","hash":"ea4fc5b7083f655aaf850e24bad811f5f98f6506","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/mathjax.ejs","hash":"f98a7f202cc7645e42991c5ca75a791890160986","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/importJS.ejs","hash":"31d45544f38d8016351f95f9ab5a2486c17a3acc","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/nav.ejs","hash":"05a44ee21f99b2ae8b99d924db6f1a2aa3e1e393","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/intro.ejs","hash":"f1e136f0e6ede50d5ce5a3abbc14db63a92c04d3","modified":1540215856000},{"_id":"themes/miccall/layout/_partial/headerlogo.ejs","hash":"e9ba05cce80d7f93ba11a9ef5c8a12e958f996f2","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/page-tagcloud.ejs","hash":"bdd2cca14c209462c2b894de2563be5a2c6c5599","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/page-links.ejs","hash":"bfe157e5e9f534cc40475b0470888d251fcc6f44","modified":1540215856000},{"_id":"themes/miccall/source/css/dropdownMenu.css","hash":"3e44ce25f19c28dcf2c12db1938ccce7a081c10f","modified":1540215856000},{"_id":"themes/miccall/source/css/font-awesome.min.css","hash":"03eb0a6b53db2655f3ded9bb1a4e4af07cc1efa6","modified":1540215856000},{"_id":"themes/miccall/source/css/gallery.css","hash":"4c0178ea898cdc5e010346b56d1c9845fe8da53e","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/page-gallery.ejs","hash":"7d89025675f7f59395a888577e248f394f72c03c","modified":1540215856000},{"_id":"themes/miccall/source/css/backcss.css","hash":"65db154a14ccb0e773a14e1d1262553e6f30aec5","modified":1540215856000},{"_id":"themes/miccall/source/css/demo.css","hash":"99b020fe28a276c2b128a5048ab1325fc3303b96","modified":1540215856000},{"_id":"themes/miccall/source/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1540215856000},{"_id":"themes/miccall/source/css/item.css","hash":"da1277164b611ccba56beda47960f9075c61dbab","modified":1540215856000},{"_id":"themes/miccall/source/css/mic_gallery.css","hash":"5c75b8ab2670599538a1250957cf7c44d0e4cbec","modified":1540215856000},{"_id":"themes/miccall/source/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1540215856000},{"_id":"themes/miccall/source/css/my_link.css","hash":"c9535592792f2271df88c39e4baf8c849e23db17","modified":1540215856000},{"_id":"themes/miccall/source/css/ok_prism.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1540215856000},{"_id":"themes/miccall/source/css/prism.css","hash":"b39768264f9923a770bcc3f289be0a2bd8e64268","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_coy.css","hash":"24ebf5f3e5f68341522204dcaaf33f429d3c3718","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_dark.css","hash":"8085542cdb4583ffb78b2edd146ebe9511bf668c","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_funky.css","hash":"aa0e3a37fb8ccce44457d7805a13d7c6094d1f5e","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_default.css","hash":"3600bee175b309662e306b50e494ac73495619c2","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_okaidia.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_solarized.css","hash":"73759f72dc43870aaf76dca7ef4e61a142b6b4f0","modified":1540215856000},{"_id":"themes/miccall/source/css/prism_twilight.css","hash":"17498435f6d964243c1a50deb563e6003aebe0e6","modified":1540215856000},{"_id":"themes/miccall/source/css/typo.css","hash":"768004dae4204dfbda865d412229feaa618ec3b7","modified":1540215856000},{"_id":"themes/miccall/source/images/.DS_Store","hash":"bce4e5657e010117c3c7275e2db67286824b196b","modified":1627712975559},{"_id":"themes/miccall/source/images/12.jpg","hash":"88d68b169744a76ca7b21a258fc0812bc03ee701","modified":1540215856000},{"_id":"themes/miccall/source/images/3123.jpg","hash":"fc005184ff616231647c5dc85c63167040d810ba","modified":1540215856000},{"_id":"themes/miccall/source/images/overlay.png","hash":"e978d81201508e6fcbe0fe95485dae1a4b983a8d","modified":1540215856000},{"_id":"themes/miccall/source/images/me.jpg","hash":"b520aa4d797fc0794d93104f260d18a523b67522","modified":1540215856000},{"_id":"themes/miccall/source/images/pic01.jpg","hash":"774db644cdac607e0d9d72ca65a4961f9a250c11","modified":1540215856000},{"_id":"themes/miccall/source/images/pic02.jpg","hash":"ab77495fef5102f94e36b71d4308cd682dd4b1a8","modified":1540215856000},{"_id":"themes/miccall/source/images/pic03.jpg","hash":"ec46b8b1490a794ea5d4c61058959b9a52ac262f","modified":1540215856000},{"_id":"themes/miccall/source/images/pic04.jpg","hash":"ee299cd40108e50d7151333de525049f8ec4f150","modified":1540215856000},{"_id":"themes/miccall/source/images/pic05.jpg","hash":"b74d638c0aa9e90f94b056db4c0a886e382973f1","modified":1540215856000},{"_id":"themes/miccall/source/images/pic06.jpg","hash":"3d8572663edf8a77b99bdfd93491d4f6a7298aaf","modified":1540215856000},{"_id":"themes/miccall/source/images/pic07.jpg","hash":"de06b4eee3d0e42ddcac415adc8c83466f430253","modified":1540215856000},{"_id":"themes/miccall/source/images/pic08.jpg","hash":"993e8ff91c20b6d28b6302d3a18367547610c58a","modified":1540215856000},{"_id":"themes/miccall/source/images/pic10.jpg","hash":"814a661f2966a3c8fe2c89034f62e828f291d770","modified":1540215856000},{"_id":"themes/miccall/source/images/pic09.jpg","hash":"6aae76e8215e3a6e785ce2a65484e4df03ed5fe9","modified":1540215856000},{"_id":"themes/miccall/source/images/pic11.jpg","hash":"a034beb80041d238f36685706a019a269f159ac1","modified":1540215856000},{"_id":"themes/miccall/source/images/pic12.jpg","hash":"ae93f2674a3b1f1dcbfe9692f2e172e106c02d96","modified":1540215856000},{"_id":"themes/miccall/source/images/picx03.jpg","hash":"cffaa38c9489f131f6f37763b37b937811b316df","modified":1540215856000},{"_id":"themes/miccall/source/js/gallery_skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1540215856000},{"_id":"themes/miccall/source/js/jquery.scrollex.min.js","hash":"57fa1d1de2eca4fabbe75d6d160edc45cc398075","modified":1540215856000},{"_id":"themes/miccall/source/js/jquery.scrolly.min.js","hash":"6807fda8e44d95117e7007563a4db951818df82b","modified":1540215856000},{"_id":"themes/miccall/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1540215856000},{"_id":"themes/miccall/source/js/main.js","hash":"509935fbbf5896ee1e8f2047e961dd58894ae74d","modified":1540215856000},{"_id":"themes/miccall/source/js/mic_gallery.js","hash":"9f5d540f90fcef501df7a9f8272203d1604cd507","modified":1540215856000},{"_id":"themes/miccall/source/js/skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1540215856000},{"_id":"themes/miccall/source/css/images/arrow-small.svg","hash":"f00360be7c8c06c0ab9d008b3485429cd07b8621","modified":1540215856000},{"_id":"themes/miccall/source/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1540215856000},{"_id":"themes/miccall/source/css/images/arrow.svg","hash":"84ad7a183fce70ac31766748919292d9db68c3c8","modified":1540215856000},{"_id":"themes/miccall/source/css/images/close-small-alt.svg","hash":"6b0204bb16fc15963977c3921d631209afff8180","modified":1540215856000},{"_id":"themes/miccall/source/css/images/close-small.svg","hash":"23e81571a4e597278e80a593c9e82a0f03d9d167","modified":1540215856000},{"_id":"themes/miccall/source/css/images/spinner.svg","hash":"7ef1bb9afa8be7be3509ba644c990b23f5876863","modified":1540215856000},{"_id":"themes/miccall/source/css/images/open-small.svg","hash":"7ee24df085722b308c03d3b827fd0769a63e49f2","modified":1540215856000},{"_id":"themes/miccall/source/css/images/open.svg","hash":"f376adaf38d3fc3a2a0209e560a7d181105c75a6","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/01.jpg","hash":"cfc928948301b97ab2873e837284cd83cc3c6cff","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/02.jpg","hash":"1a729f597316a7483ebcf39b5984ced1612a0410","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/03.jpg","hash":"0f8c8109f8b605aa46ef571df1d16e8bdd43d090","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/04.jpg","hash":"806679d4c4398335413b6b53941709a4aef7c3cd","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/05.jpg","hash":"232b0b9e3b6e751ebb2e6c4284651639526200e3","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/06.jpg","hash":"e97b29127a50c69cf445d0591cd94daab0f50e33","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/07.jpg","hash":"eb41675450650b613195806b154c6badbb7eca4d","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/08.jpg","hash":"d31c389218f04bc7ec510ac236fbe343048e3cfc","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/09.jpg","hash":"61fab3aa8ceee938efb4965042ce2b5f51d3a584","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/10.jpg","hash":"9a284568752a54ab9e8e9cd19c41750e05975d2a","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/11.jpg","hash":"cff6219163e3154c1263ee1d7f924c0ae3ccc9e7","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/01.jpg","hash":"4f5a2b9fdf44146d60f8dd3a32c81a8419b9148f","modified":1540215856000},{"_id":"themes/miccall/source/css/images/close.svg","hash":"7e524252c4610461102bf6da4b41eaa60845b642","modified":1540215856000},{"_id":"themes/miccall/source/images/fulls/12.jpg","hash":"a631491537584e2e23926d9d6f50ce60bb884b18","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/02.jpg","hash":"396a422cbc1b94b6c9b00f6a34c02b05913230ba","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/03.jpg","hash":"e3915b1cc3283b5ec33f49e2591ebf2e6be2362e","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/05.jpg","hash":"3e28c2253db93ba42d16ba9a1f451dbc452fd947","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/04.jpg","hash":"3c60445217b1b52b1fd6cae4578356c564d7624d","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/06.jpg","hash":"ffc80bb5fe28626d9462e06d9f01d2a5f99b0ae9","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/07.jpg","hash":"45194a98089345e4f135c0f0bfffeee7ccdd9c99","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/08.jpg","hash":"e0384120f6acfa64ad0b5bd0d7e114e9f239294e","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/09.jpg","hash":"bc8a02decf65e44657f02dcc11c7395bfa41ffdb","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/10.jpg","hash":"ccfee49fbca187bad971336cb8fda7dec05ab01e","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/11.jpg","hash":"66a7fb237824b1b2fd550a068bb6a32f5031ab8f","modified":1540215856000},{"_id":"themes/miccall/source/images/thumbs/12.jpg","hash":"17ab685447ed06b6c12e4d42f38111c684221bc7","modified":1540215856000},{"_id":"themes/miccall/source/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/changyan/enter.ejs","hash":"e3cfb4f37ea35457f112f3e822e130c930086497","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/changyan/main.ejs","hash":"77539ff32cc9d1204b848e01b5277fff5cbd61e0","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus/enter.ejs","hash":"ecde1e8e072cd6ec5b69287186c3551d246feb78","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/changyan/common.ejs","hash":"40e1fc76d6b7f64e226693fb2fe1a6bb17bae245","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus/common.ejs","hash":"c11cfceb0906a96399dede5da01ff7fe4787f8a5","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus/main.ejs","hash":"e545ec7bab21e2d345e058ed438e2031e3e1f353","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/common.ejs","hash":"d243f576b366a62191066459efcc6fd0ab79d00a","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/enter.ejs","hash":"d82f0296f8bae25223ec44e6e05b817d3a234884","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/valine/enter.ejs","hash":"0f1c274517b7d9008adbafdf456bbd24a615ffd3","modified":1540215856000},{"_id":"source/_posts/盘点我从无到有搭建一个Springboot遇到的坑.assets/image-20210731171750135.png","hash":"e0eecf680401990f641454bbc2afa4893b7b3552","modified":1627723070136},{"_id":"themes/miccall/layout/_widget/comment/disqus_click/main.ejs","hash":"afc734b693b98128f0c45e70b4ecb5702b482829","modified":1540215856000},{"_id":"themes/miccall/layout/_widget/comment/valine/main.ejs","hash":"5f026c923ed86a46fd87086deff2ee2a9d13a8f5","modified":1540215856000},{"_id":"themes/miccall/source/css/mic_main.css","hash":"152cca3d857f0184a99d1e8ac54dcb1d19945b3e","modified":1540215856000},{"_id":"themes/miccall/source/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1540215856000},{"_id":"themes/miccall/source/img/logo_miccall.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1540215856000},{"_id":"themes/miccall/source/images/WechatIMG501.jpeg","hash":"14a43a6c89875e65e2ee2bf3fb2a2bbdb2bb1b3e","modified":1627708307457},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1540215856000},{"_id":"themes/miccall/source/images/logo.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1540215856000},{"_id":"themes/miccall/source/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1540215856000},{"_id":"themes/miccall/source/img/avatar.png","hash":"41e4190dab86b5ccdf79880b87536a301938d5a0","modified":1627455295608},{"_id":"themes/miccall/source/css/noscript.css","hash":"5579ccdecc63139609db824704331d8d4af61538","modified":1540215856000},{"_id":"themes/miccall/source/images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","hash":"06177cb664fe001b2a23e8c90a8b0c183e49ad03","modified":1627710679412},{"_id":"themes/miccall/source/js/prism.js","hash":"0868d642f4661649a37dfb45b93fa30b4d92d4e4","modified":1540215856000},{"_id":"themes/miccall/source/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1540215856000},{"_id":"themes/miccall/source/images/sunset.jpg","hash":"6269f3b31fa709eec3430686e72ecde461e231ca","modified":1627710472313},{"_id":"themes/miccall/source/images/21.jpg","hash":"0b2570df0e6d9b79a0c50d0b4ce8799bd40ea421","modified":1540215856000},{"_id":"source/_posts/img.png","hash":"d80c5d3efa16b8c0e3e4c69bdcc24030f6782310","modified":1627709792150},{"_id":"themes/miccall/source/fonts/FZLT.ttf","hash":"24dfab81236612d596c97eb38b3adf5de99f669c","modified":1540215856000},{"_id":"themes/miccall/source/img/bg.jpg","hash":"af7fe6067d0c21f558502613eed86d8246000bba","modified":1540215856000},{"_id":"source/_posts/7月31号.assets/snowy-mountain-peak-with-sunrise-glow-picjumbo-com.jpg","hash":"020f363c059684c91687b8b6aeb71827e036d9ce","modified":1627696941680},{"_id":"public/Java/index.html","hash":"f8404abb96b80405abd40c8aab6881c7430fe502","modified":1627792282101},{"_id":"public/about/index.html","hash":"1399fa7e2cfed9402ce2db7d2959cc6dc2fd6f39","modified":1627792282101},{"_id":"public/group/index.html","hash":"c9032405f05fac4a7ec954255af62d320757915a","modified":1627792282101},{"_id":"public/2021/07/30/7月30日/index.html","hash":"439361eccd0c1af88cba7f1a930dbea4d82bdc3d","modified":1627792282101},{"_id":"public/index.html","hash":"661adc435c6bb48c0ad9b60f0b80caed5dead738","modified":1627792282101},{"_id":"public/archives/index.html","hash":"8ecff5ab4a4a192a60a98cce10638e1fc7626058","modified":1627792282101},{"_id":"public/archives/2021/index.html","hash":"8ecff5ab4a4a192a60a98cce10638e1fc7626058","modified":1627792282101},{"_id":"public/archives/2021/07/index.html","hash":"dcb3c59bd3591dae7697ca4ab1261e1138cbd94e","modified":1627792282101},{"_id":"public/2021/07/31/盘点我从无到有搭建一个Springboot遇到的坑/index.html","hash":"22f28599da9ac9a2bf42d657fb5bcad84e2eb680","modified":1627792282101},{"_id":"public/2021/07/31/7月31号/index.html","hash":"2a0b56024c8e71edb41fbb1c0564edd03ca0f2db","modified":1627792282101},{"_id":"public/2021/07/29/7月29日/index.html","hash":"cc8674c94656bd85af7398f99ecdc9e2ba5c2b15","modified":1627792282101},{"_id":"public/images/12.jpg","hash":"88d68b169744a76ca7b21a258fc0812bc03ee701","modified":1627724508447},{"_id":"public/images/3123.jpg","hash":"fc005184ff616231647c5dc85c63167040d810ba","modified":1627724508447},{"_id":"public/images/me.jpg","hash":"b520aa4d797fc0794d93104f260d18a523b67522","modified":1627724508447},{"_id":"public/images/overlay.png","hash":"e978d81201508e6fcbe0fe95485dae1a4b983a8d","modified":1627724508447},{"_id":"public/images/pic01.jpg","hash":"774db644cdac607e0d9d72ca65a4961f9a250c11","modified":1627724508447},{"_id":"public/images/pic02.jpg","hash":"ab77495fef5102f94e36b71d4308cd682dd4b1a8","modified":1627724508447},{"_id":"public/images/pic03.jpg","hash":"ec46b8b1490a794ea5d4c61058959b9a52ac262f","modified":1627724508447},{"_id":"public/images/pic04.jpg","hash":"ee299cd40108e50d7151333de525049f8ec4f150","modified":1627724508447},{"_id":"public/images/pic05.jpg","hash":"b74d638c0aa9e90f94b056db4c0a886e382973f1","modified":1627724508447},{"_id":"public/images/pic06.jpg","hash":"3d8572663edf8a77b99bdfd93491d4f6a7298aaf","modified":1627724508447},{"_id":"public/images/pic07.jpg","hash":"de06b4eee3d0e42ddcac415adc8c83466f430253","modified":1627724508447},{"_id":"public/images/pic08.jpg","hash":"993e8ff91c20b6d28b6302d3a18367547610c58a","modified":1627724508447},{"_id":"public/images/pic09.jpg","hash":"6aae76e8215e3a6e785ce2a65484e4df03ed5fe9","modified":1627724508447},{"_id":"public/images/pic10.jpg","hash":"814a661f2966a3c8fe2c89034f62e828f291d770","modified":1627724508447},{"_id":"public/images/pic11.jpg","hash":"a034beb80041d238f36685706a019a269f159ac1","modified":1627724508447},{"_id":"public/images/pic12.jpg","hash":"ae93f2674a3b1f1dcbfe9692f2e172e106c02d96","modified":1627724508447},{"_id":"public/images/picx03.jpg","hash":"cffaa38c9489f131f6f37763b37b937811b316df","modified":1627724508447},{"_id":"public/css/images/arrow-small.svg","hash":"f00360be7c8c06c0ab9d008b3485429cd07b8621","modified":1627724508447},{"_id":"public/css/images/arrow.svg","hash":"84ad7a183fce70ac31766748919292d9db68c3c8","modified":1627724508447},{"_id":"public/css/images/close-small-alt.svg","hash":"6b0204bb16fc15963977c3921d631209afff8180","modified":1627724508447},{"_id":"public/css/images/close-small.svg","hash":"23e81571a4e597278e80a593c9e82a0f03d9d167","modified":1627724508447},{"_id":"public/css/images/close.svg","hash":"7e524252c4610461102bf6da4b41eaa60845b642","modified":1627724508447},{"_id":"public/css/images/open-small.svg","hash":"7ee24df085722b308c03d3b827fd0769a63e49f2","modified":1627724508447},{"_id":"public/css/images/open.svg","hash":"f376adaf38d3fc3a2a0209e560a7d181105c75a6","modified":1627724508447},{"_id":"public/css/images/spinner.svg","hash":"7ef1bb9afa8be7be3509ba644c990b23f5876863","modified":1627724508447},{"_id":"public/images/fulls/01.jpg","hash":"cfc928948301b97ab2873e837284cd83cc3c6cff","modified":1627724508447},{"_id":"public/images/fulls/03.jpg","hash":"0f8c8109f8b605aa46ef571df1d16e8bdd43d090","modified":1627724508447},{"_id":"public/images/fulls/02.jpg","hash":"1a729f597316a7483ebcf39b5984ced1612a0410","modified":1627724508447},{"_id":"public/images/fulls/04.jpg","hash":"806679d4c4398335413b6b53941709a4aef7c3cd","modified":1627724508447},{"_id":"public/images/fulls/05.jpg","hash":"232b0b9e3b6e751ebb2e6c4284651639526200e3","modified":1627724508447},{"_id":"public/images/fulls/06.jpg","hash":"e97b29127a50c69cf445d0591cd94daab0f50e33","modified":1627724508447},{"_id":"public/images/fulls/07.jpg","hash":"eb41675450650b613195806b154c6badbb7eca4d","modified":1627724508447},{"_id":"public/images/fulls/08.jpg","hash":"d31c389218f04bc7ec510ac236fbe343048e3cfc","modified":1627724508447},{"_id":"public/images/fulls/09.jpg","hash":"61fab3aa8ceee938efb4965042ce2b5f51d3a584","modified":1627724508447},{"_id":"public/images/fulls/10.jpg","hash":"9a284568752a54ab9e8e9cd19c41750e05975d2a","modified":1627724508447},{"_id":"public/images/fulls/11.jpg","hash":"cff6219163e3154c1263ee1d7f924c0ae3ccc9e7","modified":1627724508447},{"_id":"public/images/thumbs/01.jpg","hash":"4f5a2b9fdf44146d60f8dd3a32c81a8419b9148f","modified":1627724508447},{"_id":"public/images/fulls/12.jpg","hash":"a631491537584e2e23926d9d6f50ce60bb884b18","modified":1627724508447},{"_id":"public/images/thumbs/02.jpg","hash":"396a422cbc1b94b6c9b00f6a34c02b05913230ba","modified":1627724508447},{"_id":"public/images/thumbs/03.jpg","hash":"e3915b1cc3283b5ec33f49e2591ebf2e6be2362e","modified":1627724508447},{"_id":"public/images/thumbs/04.jpg","hash":"3c60445217b1b52b1fd6cae4578356c564d7624d","modified":1627724508447},{"_id":"public/images/thumbs/05.jpg","hash":"3e28c2253db93ba42d16ba9a1f451dbc452fd947","modified":1627724508447},{"_id":"public/images/thumbs/06.jpg","hash":"ffc80bb5fe28626d9462e06d9f01d2a5f99b0ae9","modified":1627724508447},{"_id":"public/images/thumbs/07.jpg","hash":"45194a98089345e4f135c0f0bfffeee7ccdd9c99","modified":1627724508447},{"_id":"public/images/thumbs/08.jpg","hash":"e0384120f6acfa64ad0b5bd0d7e114e9f239294e","modified":1627724508447},{"_id":"public/images/thumbs/09.jpg","hash":"bc8a02decf65e44657f02dcc11c7395bfa41ffdb","modified":1627724508447},{"_id":"public/images/thumbs/10.jpg","hash":"ccfee49fbca187bad971336cb8fda7dec05ab01e","modified":1627724508447},{"_id":"public/images/thumbs/11.jpg","hash":"66a7fb237824b1b2fd550a068bb6a32f5031ab8f","modified":1627724508447},{"_id":"public/images/thumbs/12.jpg","hash":"17ab685447ed06b6c12e4d42f38111c684221bc7","modified":1627724508447},{"_id":"public/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1627724508447},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1627724508447},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1627724508447},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1627724508447},{"_id":"public/img/logo_miccall.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1627724508447},{"_id":"public/images/WechatIMG501.jpeg","hash":"14a43a6c89875e65e2ee2bf3fb2a2bbdb2bb1b3e","modified":1627724508447},{"_id":"public/images/logo.png","hash":"ee2cf634d838f8acab5b826400edb0b42c8ce52b","modified":1627724508447},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1627724508447},{"_id":"public/img/avatar.png","hash":"41e4190dab86b5ccdf79880b87536a301938d5a0","modified":1627724508447},{"_id":"public/images/people-enjoying-sunset-over-the-ocean-free-photo-2210x1474.jpg","hash":"06177cb664fe001b2a23e8c90a8b0c183e49ad03","modified":1627724508447},{"_id":"public/css/backcss.css","hash":"65db154a14ccb0e773a14e1d1262553e6f30aec5","modified":1627724508447},{"_id":"public/css/demo.css","hash":"99b020fe28a276c2b128a5048ab1325fc3303b96","modified":1627724508447},{"_id":"public/css/dropdownMenu.css","hash":"3e44ce25f19c28dcf2c12db1938ccce7a081c10f","modified":1627724508447},{"_id":"public/css/my_link.css","hash":"c9535592792f2271df88c39e4baf8c849e23db17","modified":1627724508447},{"_id":"public/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1627724508447},{"_id":"public/css/noscript.css","hash":"5579ccdecc63139609db824704331d8d4af61538","modified":1627724508447},{"_id":"public/css/ok_prism.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1627724508447},{"_id":"public/css/prism.css","hash":"b39768264f9923a770bcc3f289be0a2bd8e64268","modified":1627724508447},{"_id":"public/css/prism_coy.css","hash":"24ebf5f3e5f68341522204dcaaf33f429d3c3718","modified":1627724508447},{"_id":"public/css/prism_dark.css","hash":"8085542cdb4583ffb78b2edd146ebe9511bf668c","modified":1627724508447},{"_id":"public/css/prism_default.css","hash":"3600bee175b309662e306b50e494ac73495619c2","modified":1627724508447},{"_id":"public/css/prism_funky.css","hash":"aa0e3a37fb8ccce44457d7805a13d7c6094d1f5e","modified":1627724508447},{"_id":"public/css/prism_okaidia.css","hash":"e20586e80aeef3192c727e20d2efe4bd23846d29","modified":1627724508447},{"_id":"public/css/prism_solarized.css","hash":"73759f72dc43870aaf76dca7ef4e61a142b6b4f0","modified":1627724508447},{"_id":"public/css/prism_twilight.css","hash":"17498435f6d964243c1a50deb563e6003aebe0e6","modified":1627724508447},{"_id":"public/css/typo.css","hash":"768004dae4204dfbda865d412229feaa618ec3b7","modified":1627724508447},{"_id":"public/js/gallery_skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1627724508447},{"_id":"public/js/jquery.scrollex.min.js","hash":"57fa1d1de2eca4fabbe75d6d160edc45cc398075","modified":1627724508447},{"_id":"public/js/jquery.scrolly.min.js","hash":"6807fda8e44d95117e7007563a4db951818df82b","modified":1627724508447},{"_id":"public/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1627724508447},{"_id":"public/js/main.js","hash":"509935fbbf5896ee1e8f2047e961dd58894ae74d","modified":1627724508447},{"_id":"public/js/mic_gallery.js","hash":"9f5d540f90fcef501df7a9f8272203d1604cd507","modified":1627724508447},{"_id":"public/js/skel.min.js","hash":"475a99682e46ad061915a11a9adb3fad82258d3c","modified":1627724508447},{"_id":"public/js/util.js","hash":"3ece9010adc07dd3dc27ced0e22e7ac8bcd16e14","modified":1627724508447},{"_id":"public/css/gallery.css","hash":"4c0178ea898cdc5e010346b56d1c9845fe8da53e","modified":1627724508447},{"_id":"public/css/gallery.min.css","hash":"c5333ca835aae49239d809130a7b281af745729e","modified":1627724508447},{"_id":"public/css/item.css","hash":"da1277164b611ccba56beda47960f9075c61dbab","modified":1627724508447},{"_id":"public/css/mic_gallery.css","hash":"5c75b8ab2670599538a1250957cf7c44d0e4cbec","modified":1627724508447},{"_id":"public/js/gallery/gallery.js","hash":"8ee48312a183b42a9886211a0ec825ea0d041301","modified":1627724508447},{"_id":"public/css/font-awesome.min.css","hash":"03eb0a6b53db2655f3ded9bb1a4e4af07cc1efa6","modified":1627724508447},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1627724508447},{"_id":"public/images/sunset.jpg","hash":"6269f3b31fa709eec3430686e72ecde461e231ca","modified":1627724508447},{"_id":"public/images/21.jpg","hash":"0b2570df0e6d9b79a0c50d0b4ce8799bd40ea421","modified":1627724508447},{"_id":"public/css/mic_main.css","hash":"152cca3d857f0184a99d1e8ac54dcb1d19945b3e","modified":1627724508447},{"_id":"public/js/jquery.min.js","hash":"276c87ff3e1e3155679c318938e74e5c1b76d809","modified":1627724508447},{"_id":"public/img/bg.jpg","hash":"af7fe6067d0c21f558502613eed86d8246000bba","modified":1627724508447},{"_id":"public/js/prism.js","hash":"0868d642f4661649a37dfb45b93fa30b4d92d4e4","modified":1627724508447},{"_id":"public/fonts/FZLT.ttf","hash":"24dfab81236612d596c97eb38b3adf5de99f669c","modified":1627724508447},{"_id":"source/_posts/谢希科老师数据库前沿课的论文pre.md","hash":"4b3ce2d79775b63614f7737ee5344a2a068ab4f2","modified":1627729620798},{"_id":"public/2021/07/31/谢希科老师数据库前沿课的论文pre/index.html","hash":"b232ed9aa5fc11a56269c297ab065d66fac74905","modified":1627792282101},{"_id":"source/_posts/元连接查询处理.md","hash":"73e169abc8db55c58a71cdbf203d19d7044d9b0d","modified":1627792277234},{"_id":"public/2021/07/31/元连接查询处理/index.html","hash":"0b9f0c6d83ba98c7d19b6e644cbe3cd71f1dbf61","modified":1627792282101},{"_id":"source/_posts/元连接查询处理.assets/image-20210731200903651.png","hash":"6eebabdb7c4c116d1d52d6407d24dde3e13acfcb","modified":1627733343654},{"_id":"source/_posts/元连接查询处理.assets/image-20210731201800921.png","hash":"83564168173e2f1b56ab71b31d503151d95f4bad","modified":1627733880923},{"_id":"source/_posts/元连接查询处理.assets/image-20210731203214373.png","hash":"ae9fad83096019520999fd646c7d283e466eceba","modified":1627734734375},{"_id":"source/_posts/元连接查询处理.assets/image-20210731203746568.png","hash":"2b663091d461d5c3294886ce94e422a3ea430999","modified":1627735066569},{"_id":"source/_posts/元连接查询处理.assets/image-20210731203334822.png","hash":"3705afafa4b3638d1a97fe3c9bf229a741203209","modified":1627734814822},{"_id":"source/_posts/元连接查询处理.assets/image-20210731204445823.png","hash":"0e4db3fb536cb771d469f47ae391e0a7b6dfef02","modified":1627735485824},{"_id":"source/_posts/元连接查询处理.assets/image-20210731204449323.png","hash":"0e4db3fb536cb771d469f47ae391e0a7b6dfef02","modified":1627735489323},{"_id":"themes/miccall/source/img/sunset.jpg","hash":"6269f3b31fa709eec3430686e72ecde461e231ca","modified":1627710472313},{"_id":"public/img/sunset.jpg","hash":"6269f3b31fa709eec3430686e72ecde461e231ca","modified":1627737258225},{"_id":"source/_posts/周末的上海-前置摄像头给自己理个发.md","hash":"274a5cb72a2a5854787ed1e724af91d3e9b01f9f","modified":1627792154360},{"_id":"public/2021/08/01/周末的上海-前置摄像头给自己理个发/index.html","hash":"67ac21d85b88332292e66586a8e4cdf4ea9df1c8","modified":1627792282101},{"_id":"public/archives/2021/08/index.html","hash":"c723dfeca76aa23ee94f1a1ff4b17bfe12177008","modified":1627792282101},{"_id":"source/ustc/index.md","hash":"6d860b6bf398e5f7120c1835fbb64325bbcab175","modified":1627789600476},{"_id":"source/个人生活/index.md","hash":"372542fd39d43ce02c2ac6ee917b78d8b769fd37","modified":1627789548366},{"_id":"public/ustc/index.html","hash":"5da6ae6a5563147be35eae605f39f4f8b35d45e7","modified":1627792282101},{"_id":"public/个人生活/index.html","hash":"99d7fc3ad56b436f80d5e14ff8104f56591e77d2","modified":1627792282101},{"_id":"public/categories/个人生活/index.html","hash":"c723dfeca76aa23ee94f1a1ff4b17bfe12177008","modified":1627792282101},{"_id":"public/categories/ustc/index.html","hash":"2ab0dd3f456e1161b3811ab50be3e4c205ea8add","modified":1627792282101}],"Category":[{"name":"个人生活","_id":"ckrspfcpp0000a8f16hk13iai"},{"name":"ustc","_id":"ckrsphvzw0000baf18s0peet6"}],"Data":[],"Page":[{"title":"categories","date":"2021-07-31T06:01:34.000Z","_content":"","source":"Java/index.md","raw":"---\ntitle: categories\ndate: 2021-07-31 14:01:34\n---\n","updated":"2021-07-31T06:01:34.152Z","path":"Java/index.html","comments":1,"layout":"page","_id":"ckrrl59e30000ps76boru5ltj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"8月1号","date":"2021-07-31T01:26:11.000Z","tags":null,"thumbnail":"https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg","_content":"wzr","source":"about/index.md","raw":"---\ntitle: 8月1号\ndate: 2021-07-31 09:26:11\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg\n---\nwzr","updated":"2021-08-01T04:22:30.140Z","path":"about/index.html","_id":"ckrrl59e90002ps76bmn2hn6p","comments":1,"layout":"page","content":"<p>wzr</p>\n","site":{"data":{}},"excerpt":"","more":"<p>wzr</p>\n"},{"title":"7月30日","date":"2021-07-30T01:17:39.000Z","tags":null,"thumbnail":"https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg","_content":"","source":"group/index.md","raw":"---\ntitle: 7月30日\ndate: 2021-07-30 09:17:39\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg # 略缩图\n---\n","updated":"2021-07-31T05:26:22.916Z","path":"group/index.html","comments":1,"layout":"page","_id":"ckrrl59eb0004ps76fbj1btar","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"ustc","date":"2021-08-01T03:46:40.000Z","_content":"","source":"ustc/index.md","raw":"---\ntitle: ustc\ndate: 2021-08-01 11:46:40\n---\n","updated":"2021-08-01T03:46:40.476Z","path":"ustc/index.html","comments":1,"layout":"page","_id":"ckrsnxdxc0000xvf142y8czit","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"个人生活","date":"2021-08-01T03:45:48.000Z","_content":"","source":"个人生活/index.md","raw":"---\ntitle: 个人生活\ndate: 2021-08-01 11:45:48\n---\n","updated":"2021-08-01T03:45:48.366Z","path":"个人生活/index.html","comments":1,"layout":"page","_id":"ckrsnxdxg0001xvf1bbuk5cc6","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"7月29日","date":"2021-07-29T01:46:17.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/mountains-sticking-out-of-inverse-in-a-beautiful-sunrise-light-2210x1243.jpg","_content":"\nhexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同\n\nHero g -d 别忘了\n\n![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe)\n\nAtomicLong是作用是对长整形进行原子操作。\n在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。\n\n首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。\n\nalias 别名\n\ngit绑定仓库的命令\n\n\n\n```shell\ngit init //第一次要先初始化一个git目录\ngit remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）\ngit pull origin master\ngit push -u origin master\n```\n\n\n\nwarning: adding embedded git repository: .deploy_git\n\n当前目录下面有.git文件夹------默认是隐藏的，直接将.git文件夹掉，再重新git add .\n\n\n\n### …or create a new repository on the command line\n\n\n\n```\necho \"# myBlog\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit push -u origin main\n```\n\n### …or push an existing repository from the command line\n\n\n\n```\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit branch -M main\ngit push -u origin main\n```\n\n\n\nFielding将他对互联网软件的架构原则，定名为**REST**，即**Representational State Transfer**的缩写。我对这个词组的翻译是\"表现层状态转化\"。\n\n如果一个架构符合REST原则，就称它为RESTful架构。\n\n**要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。**如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n**三、资源（Resources）**\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。**我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。**\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\n**五、状态转化（State Transfer）**\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：**GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。**\n\n\n\nLog注解\n\n\n\n1. 打开访达,切到应用程序,找到`Pycharm.app`,右键->显示包内容,打开`Contents/MacOS/`\n2. 打开终端,cd 到`Contents/MacOS/`目录,直接将`MacOS`文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.\n3. 执行该文件夹下的`pycharm`文件,即:`./pycharm`,之后可以在终端看到输出的信息, 如果没问题会直接打开 `Pycharm`\n\n解决方法:\n\n1. 在终端cd 到`/Users/{替换成自己的用户名}/Library/Application Support/JetBrains/PyCharm2020.1/`,这个文件夹下有一个`pycharm.vmoptions`的文件,我们需要将这个文件删除.\n2. 终端执行 `rm -f pycharm.vmoptions`\n3. 重新打开即可.\n\n说明：\n `cd 到Application Support时 提示找不到路径的问题`\n 原因：`/Application Support/` 这个地方`Application` 和 `Support` 中间有一个空格，需要转义。\n\n正确的为：\n `cd /Users/{替换成自己的用户名}/Library/Application\\ Support/JetBrains/PyCharm2020.1/`\n\n`/PyCharm2020.1/` 这个路径根据安装版本的不同路径会有所不同。\n\n\n\n安装py3 直接去官网就可以，安装了之后，需要重启pycharm\n\n更新pip3\n\nsudo pip3 install --upgrade pip\n\npylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。\n\n%matplotlib inline。可以注释掉\n\nlambda表达式的语法格式如下：\n\n(parameters) -> expression 或 (parameters) ->{ statements; }\n\n```Java\nhomeApiTotalMapper.toDto(homeApiTotalRepository\n        .findAll((root, criteriaQuery, criteriaBuilder) -> QueryHelp.getPredicate(root, criteria, criteriaBuilder)));\n```\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc)\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc)\n\n\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc)\n\n这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。**而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式**。\n\n但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？\n\n在Java 8里面，**所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。**这是我认为理解Lambda的一个关键所在，简而言之就是，**Lambda表达式本身就是一个接口的实现**。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc)\n\n这种只有**一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。**为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成\"非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc)\n\n这样，我们就得到了一个完整的Lambda表达式声明：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc)\n\n\n\n这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，**我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：**\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc)\n\n","source":"_posts/7月29日.md","raw":"---\ntitle: 7月29日\ndate: 2021-07-29 09:46:17\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/mountains-sticking-out-of-inverse-in-a-beautiful-sunrise-light-2210x1243.jpg\n---\n\nhexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同\n\nHero g -d 别忘了\n\n![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe)\n\nAtomicLong是作用是对长整形进行原子操作。\n在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。\n\n首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。\n\nalias 别名\n\ngit绑定仓库的命令\n\n\n\n```shell\ngit init //第一次要先初始化一个git目录\ngit remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）\ngit pull origin master\ngit push -u origin master\n```\n\n\n\nwarning: adding embedded git repository: .deploy_git\n\n当前目录下面有.git文件夹------默认是隐藏的，直接将.git文件夹掉，再重新git add .\n\n\n\n### …or create a new repository on the command line\n\n\n\n```\necho \"# myBlog\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit push -u origin main\n```\n\n### …or push an existing repository from the command line\n\n\n\n```\ngit remote add origin git@github.com:wzr1005/myBlog.git\ngit branch -M main\ngit push -u origin main\n```\n\n\n\nFielding将他对互联网软件的架构原则，定名为**REST**，即**Representational State Transfer**的缩写。我对这个词组的翻译是\"表现层状态转化\"。\n\n如果一个架构符合REST原则，就称它为RESTful架构。\n\n**要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。**如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。\n\n**三、资源（Resources）**\n\nREST的名称\"表现层状态转化\"中，省略了主语。\"表现层\"其实指的是\"资源\"（Resources）的\"表现层\"。\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。**我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"（Representation）。**\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\n**五、状态转化（State Transfer）**\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：**GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。**\n\n\n\nLog注解\n\n\n\n1. 打开访达,切到应用程序,找到`Pycharm.app`,右键->显示包内容,打开`Contents/MacOS/`\n2. 打开终端,cd 到`Contents/MacOS/`目录,直接将`MacOS`文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.\n3. 执行该文件夹下的`pycharm`文件,即:`./pycharm`,之后可以在终端看到输出的信息, 如果没问题会直接打开 `Pycharm`\n\n解决方法:\n\n1. 在终端cd 到`/Users/{替换成自己的用户名}/Library/Application Support/JetBrains/PyCharm2020.1/`,这个文件夹下有一个`pycharm.vmoptions`的文件,我们需要将这个文件删除.\n2. 终端执行 `rm -f pycharm.vmoptions`\n3. 重新打开即可.\n\n说明：\n `cd 到Application Support时 提示找不到路径的问题`\n 原因：`/Application Support/` 这个地方`Application` 和 `Support` 中间有一个空格，需要转义。\n\n正确的为：\n `cd /Users/{替换成自己的用户名}/Library/Application\\ Support/JetBrains/PyCharm2020.1/`\n\n`/PyCharm2020.1/` 这个路径根据安装版本的不同路径会有所不同。\n\n\n\n安装py3 直接去官网就可以，安装了之后，需要重启pycharm\n\n更新pip3\n\nsudo pip3 install --upgrade pip\n\npylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。\n\n%matplotlib inline。可以注释掉\n\nlambda表达式的语法格式如下：\n\n(parameters) -> expression 或 (parameters) ->{ statements; }\n\n```Java\nhomeApiTotalMapper.toDto(homeApiTotalRepository\n        .findAll((root, criteriaQuery, criteriaBuilder) -> QueryHelp.getPredicate(root, criteria, criteriaBuilder)));\n```\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc)\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc)\n\n\n\n\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc)\n\n这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。**而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式**。\n\n但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？\n\n在Java 8里面，**所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。**这是我认为理解Lambda的一个关键所在，简而言之就是，**Lambda表达式本身就是一个接口的实现**。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc)\n\n这种只有**一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。**为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成\"非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc)\n\n这样，我们就得到了一个完整的Lambda表达式声明：\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc)\n\n\n\n这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，**我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：**\n\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc)\n\n","slug":"7月29日","published":1,"updated":"2021-07-31T05:34:08.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrl59e60001ps763ccaeprt","content":"<p>hexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同</p>\n<p>Hero g -d 别忘了</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe\" alt=\"img\"></p>\n<p>AtomicLong是作用是对长整形进行原子操作。<br>在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。</p>\n<p>首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。</p>\n<p>alias 别名</p>\n<p>git绑定仓库的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init //第一次要先初始化一个git目录</span><br><span class=\"line\">git remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>warning: adding embedded git repository: .deploy_git</p>\n<p>当前目录下面有.git文件夹——默认是隐藏的，直接将.git文件夹掉，再重新git add .</p>\n<h3 id=\"…or-create-a-new-repository-on-the-command-line\"><a href=\"#…or-create-a-new-repository-on-the-command-line\" class=\"headerlink\" title=\"…or create a new repository on the command line\"></a>…or create a new repository on the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;# myBlog&quot; &gt;&gt; README.md</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"…or-push-an-existing-repository-from-the-command-line\"><a href=\"#…or-push-an-existing-repository-from-the-command-line\" class=\"headerlink\" title=\"…or push an existing repository from the command line\"></a>…or push an existing repository from the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Fielding将他对互联网软件的架构原则，定名为<strong>REST</strong>，即<strong>Representational State Transfer</strong>的缩写。我对这个词组的翻译是”表现层状态转化”。</p>\n<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>\n<p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p><strong>三、资源（Resources）</strong></p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p><strong>五、状态转化（State Transfer）</strong></p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>\n<p>Log注解</p>\n<ol>\n<li>打开访达,切到应用程序,找到<code>Pycharm.app</code>,右键-&gt;显示包内容,打开<code>Contents/MacOS/</code></li>\n<li>打开终端,cd 到<code>Contents/MacOS/</code>目录,直接将<code>MacOS</code>文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.</li>\n<li>执行该文件夹下的<code>pycharm</code>文件,即:<code>./pycharm</code>,之后可以在终端看到输出的信息, 如果没问题会直接打开 <code>Pycharm</code></li>\n</ol>\n<p>解决方法:</p>\n<ol>\n<li>在终端cd 到<code>/Users/&#123;替换成自己的用户名&#125;/Library/Application Support/JetBrains/PyCharm2020.1/</code>,这个文件夹下有一个<code>pycharm.vmoptions</code>的文件,我们需要将这个文件删除.</li>\n<li>终端执行 <code>rm -f pycharm.vmoptions</code></li>\n<li>重新打开即可.</li>\n</ol>\n<p>说明：<br> <code>cd 到Application Support时 提示找不到路径的问题</code><br> 原因：<code>/Application Support/</code> 这个地方<code>Application</code> 和 <code>Support</code> 中间有一个空格，需要转义。</p>\n<p>正确的为：<br> <code>cd /Users/&#123;替换成自己的用户名&#125;/Library/Application\\ Support/JetBrains/PyCharm2020.1/</code></p>\n<p><code>/PyCharm2020.1/</code> 这个路径根据安装版本的不同路径会有所不同。</p>\n<p>安装py3 直接去官网就可以，安装了之后，需要重启pycharm</p>\n<p>更新pip3</p>\n<p>sudo pip3 install –upgrade pip</p>\n<p>pylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。</p>\n<p>%matplotlib inline。可以注释掉</p>\n<p>lambda表达式的语法格式如下：</p>\n<p>(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">homeApiTotalMapper.toDto(homeApiTotalRepository</span><br><span class=\"line\">        .findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria, criteriaBuilder)));</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。</p>\n<p>但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？</p>\n<p>在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。</strong>这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc\" alt=\"img\"></p>\n<p>这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。</strong>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就得到了一个完整的Lambda表达式声明：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc\" alt=\"img\"></p>\n<p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>hexo博客的xxxx.github.io的xxxx一定要和GitHub的名称相同</p>\n<p>Hero g -d 别忘了</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20181007%2F18%2F1538909694-MvtUgmBJzc.jpg&refer=http%3A%2F%2Fimage.biaobaiju.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630144395&t=0eaa79ed341dcf9aed41582917edb3fe\" alt=\"img\"></p>\n<p>AtomicLong是作用是对长整形进行原子操作。<br>在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。</p>\n<p>首先你得了解synchronized（同步锁），atomiclong 可以理解是加了synchronized的long。</p>\n<p>alias 别名</p>\n<p>git绑定仓库的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init //第一次要先初始化一个git目录</span><br><span class=\"line\">git remote add origin git@gitee.com:XXX （如果已关联 git remote rm origin 删除）</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n\n\n<p>warning: adding embedded git repository: .deploy_git</p>\n<p>当前目录下面有.git文件夹——默认是隐藏的，直接将.git文件夹掉，再重新git add .</p>\n<h3 id=\"…or-create-a-new-repository-on-the-command-line\"><a href=\"#…or-create-a-new-repository-on-the-command-line\" class=\"headerlink\" title=\"…or create a new repository on the command line\"></a>…or create a new repository on the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;# myBlog&quot; &gt;&gt; README.md</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add README.md</span><br><span class=\"line\">git commit -m &quot;first commit&quot;</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"…or-push-an-existing-repository-from-the-command-line\"><a href=\"#…or-push-an-existing-repository-from-the-command-line\" class=\"headerlink\" title=\"…or push an existing repository from the command line\"></a>…or push an existing repository from the command line</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:wzr1005/myBlog.git</span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Fielding将他对互联网软件的架构原则，定名为<strong>REST</strong>，即<strong>Representational State Transfer</strong>的缩写。我对这个词组的翻译是”表现层状态转化”。</p>\n<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>\n<p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<p><strong>三、资源（Resources）</strong></p>\n<p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>\n<p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p><strong>五、状态转化（State Transfer）</strong></p>\n<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>\n<p>Log注解</p>\n<ol>\n<li>打开访达,切到应用程序,找到<code>Pycharm.app</code>,右键-&gt;显示包内容,打开<code>Contents/MacOS/</code></li>\n<li>打开终端,cd 到<code>Contents/MacOS/</code>目录,直接将<code>MacOS</code>文件夹拖到终端里面,就会显示该文件件的全路径,然后cd进去.</li>\n<li>执行该文件夹下的<code>pycharm</code>文件,即:<code>./pycharm</code>,之后可以在终端看到输出的信息, 如果没问题会直接打开 <code>Pycharm</code></li>\n</ol>\n<p>解决方法:</p>\n<ol>\n<li>在终端cd 到<code>/Users/&#123;替换成自己的用户名&#125;/Library/Application Support/JetBrains/PyCharm2020.1/</code>,这个文件夹下有一个<code>pycharm.vmoptions</code>的文件,我们需要将这个文件删除.</li>\n<li>终端执行 <code>rm -f pycharm.vmoptions</code></li>\n<li>重新打开即可.</li>\n</ol>\n<p>说明：<br> <code>cd 到Application Support时 提示找不到路径的问题</code><br> 原因：<code>/Application Support/</code> 这个地方<code>Application</code> 和 <code>Support</code> 中间有一个空格，需要转义。</p>\n<p>正确的为：<br> <code>cd /Users/&#123;替换成自己的用户名&#125;/Library/Application\\ Support/JetBrains/PyCharm2020.1/</code></p>\n<p><code>/PyCharm2020.1/</code> 这个路径根据安装版本的不同路径会有所不同。</p>\n<p>安装py3 直接去官网就可以，安装了之后，需要重启pycharm</p>\n<p>更新pip3</p>\n<p>sudo pip3 install –upgrade pip</p>\n<p>pylab安装不能像其他scipy等计算包一样直接pip install，它是模块matplotlib下的一个包，需要先安装matplotlib等，再用import导入。</p>\n<p>%matplotlib inline。可以注释掉</p>\n<p>lambda表达式的语法格式如下：</p>\n<p>(parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">homeApiTotalMapper.toDto(homeApiTotalRepository</span><br><span class=\"line\">        .findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria, criteriaBuilder)));</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0xY2M4N2U4MmZiYTA4NzJjMmNhZTNmZWUwOGU4ZmU0MV9oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0xNDVhNTU2ZDg2ODA2YzMxNjMzOTFhMTM0MjhlM2YwM19oZC5qcGc\" alt=\"img\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1hNzEyNzUzYjQyOTcyZTA5NGE1NDhhZTAyZmE4Mjk4N19oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。</p>\n<p>但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？</p>\n<p>在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。</strong>这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi01NWRlNjYwNjBiNGNiNzAxOTNkZGM3ZmVhMjAxYjI1N19oZC5qcGc\" alt=\"img\"></p>\n<p>这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。</strong>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0yYzU3ZTc0MTFkZTIyN2QxZWIwOWMzMjdkMDFmYjc2Nl9oZC5qcGc\" alt=\"img\"></p>\n<p>这样，我们就得到了一个完整的Lambda表达式声明：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wMmVlZGM1MjhmY2VlMTE1ZjVlZDBiN2IwNDU4NDZkN19oZC5qcGc\" alt=\"img\"></p>\n<p>这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0yODYwNmY0MzI4MzA4YmFmN2Y3MGEzNmJkNjg5ZTVlYV9oZC5qcGc\" alt=\"img\"></p>\n"},{"title":"7月30日","date":"2021-07-30T01:17:39.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg","_content":"\n今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。\n\n\n\nJPA写个功能\n\n刚刚写了一个基于JPA的deleteTest，接口的\n\n添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面\n\n```shell\ncd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git\nssh-keygen -t rsa -C 邮件地址\n---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -> New SSH key\n将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功\nssh -T git@github.com # 注意邮箱地址不用改\n如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：\nYou've successfully authenticated, but GitHub does not provide shell access.\n\n\n看到这个信息说明SSH已配置成功！\n此时你还需要配置：\n$ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称 $ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱\n```\n\n接口类创建的对象需要autowire注入\n\n查看Mac是x86还是arm，在终端中输入\n\n```shell\nuname -an\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg)\n\n\n\nspring中注解@Resource 与@Autowire 区别\n@Resource与@Autowired的区别?\n1.@Autowired按byType自动注入。\n\n2.@Resource默认按byName自动注入。\n\n但是@Resource有两个属性是比较重要的，分是name和type；\n\n如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;\n\n3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。\n\nPS：个人建议用@Resource，不为什么，减少与spring的耦合。\n\n**创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。**\n\nTest 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n\n再加上@Test注解，可以在不需要main函数下执行测试类\n\n创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql\n\n\n\n/Users/wuzhenren/Downloads\n\n~/Users/wuzhenren/Downloads/cmake-3.21.1.tar\n\n~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar\n\n\n\nmac的mysql下载好之后，设置环境变量\n\n```shell\ncd /usr/local/mysql/bin\nvim ~/.bash_profile\n保存\nexport PATH=$PATH:/usr/local/mysql/bin\n:wq\n随时可以跑mysql命令\n```\n\n\n\n接下来要重置密码：\n\nmysqladmin -u root -p password ____\n\n\n\n\n\nHero 环境出问题，\n\n```shell\nsudo npm install -g hexo-cli\n\n```\n\n解决。\n\n","source":"_posts/7月30日.md","raw":"---\ntitle: 7月30日\ndate: 2021-07-30 09:17:39\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/young-man-watching-the-sunrise-from-top-of-the-mountain-2210x1396.jpg # 略缩图\n---\n\n今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。\n\n\n\nJPA写个功能\n\n刚刚写了一个基于JPA的deleteTest，接口的\n\n添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面\n\n```shell\ncd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git\nssh-keygen -t rsa -C 邮件地址\n---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -> New SSH key\n将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功\nssh -T git@github.com # 注意邮箱地址不用改\n如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：\nYou've successfully authenticated, but GitHub does not provide shell access.\n\n\n看到这个信息说明SSH已配置成功！\n此时你还需要配置：\n$ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称 $ git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱\n```\n\n接口类创建的对象需要autowire注入\n\n查看Mac是x86还是arm，在终端中输入\n\n```shell\nuname -an\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg)\n\n\n\nspring中注解@Resource 与@Autowire 区别\n@Resource与@Autowired的区别?\n1.@Autowired按byType自动注入。\n\n2.@Resource默认按byName自动注入。\n\n但是@Resource有两个属性是比较重要的，分是name和type；\n\n如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;\n\n3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。\n\nPS：个人建议用@Resource，不为什么，减少与spring的耦合。\n\n**创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。**\n\nTest 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n\n再加上@Test注解，可以在不需要main函数下执行测试类\n\n创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql\n\n\n\n/Users/wuzhenren/Downloads\n\n~/Users/wuzhenren/Downloads/cmake-3.21.1.tar\n\n~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar\n\n\n\nmac的mysql下载好之后，设置环境变量\n\n```shell\ncd /usr/local/mysql/bin\nvim ~/.bash_profile\n保存\nexport PATH=$PATH:/usr/local/mysql/bin\n:wq\n随时可以跑mysql命令\n```\n\n\n\n接下来要重置密码：\n\nmysqladmin -u root -p password ____\n\n\n\n\n\nHero 环境出问题，\n\n```shell\nsudo npm install -g hexo-cli\n\n```\n\n解决。\n\n","slug":"7月30日","published":1,"updated":"2021-07-31T06:31:21.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrrl59e90003ps76gq0y76bs","content":"<p>今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。</p>\n<p>JPA写个功能</p>\n<p>刚刚写了一个基于JPA的deleteTest，接口的</p>\n<p>添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git</span><br><span class=\"line\">ssh-keygen -t rsa -C 邮件地址</span><br><span class=\"line\">---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -&gt; New SSH key</span><br><span class=\"line\">将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功</span><br><span class=\"line\">ssh -T git@github.com # 注意邮箱地址不用改</span><br><span class=\"line\">如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</span><br><span class=\"line\">You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">看到这个信息说明SSH已配置成功！</span><br><span class=\"line\">此时你还需要配置：</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git config --global user.name <span class=\"string\">&quot;liuxianan&quot;</span>// 你的github用户名，非昵称 $ git config --global user.email <span class=\"string\">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure>\n\n<p>接口类创建的对象需要autowire注入</p>\n<p>查看Mac是x86还是arm，在终端中输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -an</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg\"></p>\n<p>spring中注解@Resource 与@Autowire 区别<br>@Resource与@Autowired的区别?<br>1.@Autowired按byType自动注入。</p>\n<p>2.@Resource默认按byName自动注入。</p>\n<p>但是@Resource有两个属性是比较重要的，分是name和type；</p>\n<p>如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;</p>\n<p>3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。</p>\n<p>PS：个人建议用@Resource，不为什么，减少与spring的耦合。</p>\n<p><strong>创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。</strong></p>\n<p>Test 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</p>\n<p>再加上@Test注解，可以在不需要main函数下执行测试类</p>\n<p>创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql</p>\n<p>/Users/wuzhenren/Downloads</p>\n<p>~/Users/wuzhenren/Downloads/cmake-3.21.1.tar</p>\n<p>~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar</p>\n<p>mac的mysql下载好之后，设置环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/mysql/bin</span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\">保存</span><br><span class=\"line\">export PATH=$PATH:/usr/local/mysql/bin</span><br><span class=\"line\">:wq</span><br><span class=\"line\">随时可以跑mysql命令</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来要重置密码：</p>\n<p>mysqladmin -u root -p password ____</p>\n<p>Hero 环境出问题，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天打算debug一下，用postman模拟请求，调试一个搜索的功能，把沿路的功能怎么实现的看看。</p>\n<p>JPA写个功能</p>\n<p>刚刚写了一个基于JPA的deleteTest，接口的</p>\n<p>添加公钥的ssh命令，就说本地生成一个公钥 然后加到git里面</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.ssh #检查本季已存在的ssh秘钥，如果提示No Such file说明是第一次使用git</span><br><span class=\"line\">ssh-keygen -t rsa -C 邮件地址</span><br><span class=\"line\">---连续三次回车最终生成一个文件中用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，并打开复制里面的内容，打开你的GitHub主页，进入个人设置SSH and GPG keys -&gt; New SSH key</span><br><span class=\"line\">将刚复制的内容粘贴到key那里，title随便填，保存。测试是否成功</span><br><span class=\"line\">ssh -T git@github.com # 注意邮箱地址不用改</span><br><span class=\"line\">如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</span><br><span class=\"line\">You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">看到这个信息说明SSH已配置成功！</span><br><span class=\"line\">此时你还需要配置：</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git config --global user.name <span class=\"string\">&quot;liuxianan&quot;</span>// 你的github用户名，非昵称 $ git config --global user.email <span class=\"string\">&quot;xxx@qq.com&quot;</span>// 填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure>\n\n<p>接口类创建的对象需要autowire注入</p>\n<p>查看Mac是x86还是arm，在终端中输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -an</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04aumgwyj30gg01ojrs.jpg\"></p>\n<p>spring中注解@Resource 与@Autowire 区别<br>@Resource与@Autowired的区别?<br>1.@Autowired按byType自动注入。</p>\n<p>2.@Resource默认按byName自动注入。</p>\n<p>但是@Resource有两个属性是比较重要的，分是name和type；</p>\n<p>如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略;</p>\n<p>3.@Autowired是spring自己定义的注解，@Resource是J2EE的，由JSR-250规范定义。</p>\n<p>PS：个人建议用@Resource，不为什么，减少与spring的耦合。</p>\n<p><strong>创建了一个接口对象，就可以用所有实现了该接口函数的类对象去实例化这个对象。</strong></p>\n<p>Test 加上RunWith和@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</p>\n<p>再加上@Test注解，可以在不需要main函数下执行测试类</p>\n<p>创建Springboot项目可以用SpringInitialize 勾选springboot Web 、Jpa、Mysql</p>\n<p>/Users/wuzhenren/Downloads</p>\n<p>~/Users/wuzhenren/Downloads/cmake-3.21.1.tar</p>\n<p>~/Users/wuzhenren/Library/Caches/Homebrew/downloads/cmake-3.21.1.tar</p>\n<p>mac的mysql下载好之后，设置环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/mysql/bin</span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\">保存</span><br><span class=\"line\">export PATH=$PATH:/usr/local/mysql/bin</span><br><span class=\"line\">:wq</span><br><span class=\"line\">随时可以跑mysql命令</span><br></pre></td></tr></table></figure>\n\n\n\n<p>接下来要重置密码：</p>\n<p>mysqladmin -u root -p password ____</p>\n<p>Hero 环境出问题，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g hexo-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决。</p>\n"},{"title":"7月31号","date":"2021-07-31T01:26:11.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg","_content":"\n昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg)\n\n\n\n## 视图\n\n- 建立视图，主键 主表选择，数据库脚本，\n\n表关联，一对一关联 一对多关联。增加字段\n\n- 界面视图，\n- 智能搜索app\n- 数据库对接 mongdb\n\n## 开发手册\n\nDO / BO / DTO / VO / AO / PO / UID\n\n- DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\n\n- BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。\n- DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于**展示层与服务层之间的数据传输对象**。\n- VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。\n- \n\n\n\n### log4jdbc\n\nSpring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成\n\n**JDBC**：Java Database Connectivity， 有四种连接的方式\n\n主要用途是与数据库建立连接，发送sql语句，处理结果\n\n可以直接调用sql命令，并与其他的数据库连接API易于使用，**低级接口**\n\n公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg)\n\n\n\nlog4jdbc是一个**JDBC驱动器**，能够记录**SQL日志**和**SQL执行时间**等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。\n\n 特性\n\n- 完全支持JDBC3和JDBC4\n- 配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4\n- 自动将占位符(?)替换为实际的参数\n- 能够及时方便地显示SQL的实际执行时间\n- 显示SQL Connection的数量的信息\n- 能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作\n- 支持现有大部分JDBC驱动。\n- 能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。\n- 能够**快速标识出应用程序中执行比较慢的SQL语句**。\n- 能够生成SQL连接数信息帮助识别连接池/线程问题。\n- open source\n\n\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.4</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.googlecode.log4jdbc</groupId>\n            <artifactId>log4jdbc</artifactId>\n            <version>1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.35</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.16</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.6.0</version>\n        </dependency>\n    </dependencies>\n```\n\n## Jpa\n\njpa拥有哪些注解\n\n```java\n\t@Entity  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描\n\t@Table 声明表名字\n\t@Id \t\t指定的类的属性，用于识别一个表中的主键\n  @Transient 指定的属性 它是不持久的，即该值永远不会存储在数据库中\n  @Column\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字\n  \n    \n```\n\n\n\n### 配置\n\n#### 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n```\n\n#### 配置文件yml\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mytest\n    type: com.alibaba.druid.pool.DruidDataSource\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver //驱动\n  jpa:\n    hibernate:\n      ddl-auto: update //自动更新\n    show-sql: true  //日志中显示sql语句\n\n```\n\nHibernate是一个[开放源代码](https://baike.baidu.com/item/开放源代码/114160)的[对象关系映射](https://baike.baidu.com/item/对象关系映射/311152)框架（**不需要写SQL**），它对[JDBC](https://baike.baidu.com/item/JDBC/485214)进行了非常轻量级的对象封装，它将**POJO与数据库表建立映射关系**，是一个全自动的orm框架，**hibernate可以自动生成SQL语句**，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。\n\n既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是**我们MVC中的数据持久层->在编写程序中的DAO层...**\n\n首先，我们来回顾一下我们在DAO层写程序的历程吧：\n\n1. **在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD**\n2. **在DAO层使用原生JDBC连接数据库，实现CRUD**\n3. **嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件-->DbUtils组件**\n\n\n\n## Controller注解\n\n@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，\n\n并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。\n\n```java\n@Controller\n　　@RequestMapping(\"/user\")\n　　public class UserController{\n\n    　　@RequestMapping(\"/users\")\n    　　public String users() {\n        　　return \"users\";\n    　　}\n　　}\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg)\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg)\n\n\n\n\n\n此时请求users方法的URL方法的URL路径就是.../user/users\n\n@PreAuthorize 注解 方法前拦截判断是否有权限\n\n","source":"_posts/7月31号.md","raw":"---\ntitle: 7月31号\ndate: 2021-07-31 09:26:11\ntags: \nthumbnail: https://picjumbo.com/wp-content/uploads/woman-holding-sparklers-in-hands-2210x1526.jpg\n---\n\n昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg)\n\n\n\n## 视图\n\n- 建立视图，主键 主表选择，数据库脚本，\n\n表关联，一对一关联 一对多关联。增加字段\n\n- 界面视图，\n- 智能搜索app\n- 数据库对接 mongdb\n\n## 开发手册\n\nDO / BO / DTO / VO / AO / PO / UID\n\n- DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。\n\n- BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。\n- DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于**展示层与服务层之间的数据传输对象**。\n- VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。\n- \n\n\n\n### log4jdbc\n\nSpring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成\n\n**JDBC**：Java Database Connectivity， 有四种连接的方式\n\n主要用途是与数据库建立连接，发送sql语句，处理结果\n\n可以直接调用sql命令，并与其他的数据库连接API易于使用，**低级接口**\n\n公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg)\n\n\n\nlog4jdbc是一个**JDBC驱动器**，能够记录**SQL日志**和**SQL执行时间**等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。\n\n 特性\n\n- 完全支持JDBC3和JDBC4\n- 配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4\n- 自动将占位符(?)替换为实际的参数\n- 能够及时方便地显示SQL的实际执行时间\n- 显示SQL Connection的数量的信息\n- 能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作\n- 支持现有大部分JDBC驱动。\n- 能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。\n- 能够**快速标识出应用程序中执行比较慢的SQL语句**。\n- 能够生成SQL连接数信息帮助识别连接池/线程问题。\n- open source\n\n\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.4</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.googlecode.log4jdbc</groupId>\n            <artifactId>log4jdbc</artifactId>\n            <version>1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.35</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.16</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.6.0</version>\n        </dependency>\n    </dependencies>\n```\n\n## Jpa\n\njpa拥有哪些注解\n\n```java\n\t@Entity  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描\n\t@Table 声明表名字\n\t@Id \t\t指定的类的属性，用于识别一个表中的主键\n  @Transient 指定的属性 它是不持久的，即该值永远不会存储在数据库中\n  @Column\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字\n  \n    \n```\n\n\n\n### 配置\n\n#### 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n```\n\n#### 配置文件yml\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mytest\n    type: com.alibaba.druid.pool.DruidDataSource\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver //驱动\n  jpa:\n    hibernate:\n      ddl-auto: update //自动更新\n    show-sql: true  //日志中显示sql语句\n\n```\n\nHibernate是一个[开放源代码](https://baike.baidu.com/item/开放源代码/114160)的[对象关系映射](https://baike.baidu.com/item/对象关系映射/311152)框架（**不需要写SQL**），它对[JDBC](https://baike.baidu.com/item/JDBC/485214)进行了非常轻量级的对象封装，它将**POJO与数据库表建立映射关系**，是一个全自动的orm框架，**hibernate可以自动生成SQL语句**，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。\n\n既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是**我们MVC中的数据持久层->在编写程序中的DAO层...**\n\n首先，我们来回顾一下我们在DAO层写程序的历程吧：\n\n1. **在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD**\n2. **在DAO层使用原生JDBC连接数据库，实现CRUD**\n3. **嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件-->DbUtils组件**\n\n\n\n## Controller注解\n\n@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，\n\n并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。\n\n```java\n@Controller\n　　@RequestMapping(\"/user\")\n　　public class UserController{\n\n    　　@RequestMapping(\"/users\")\n    　　public String users() {\n        　　return \"users\";\n    　　}\n　　}\n```\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg)\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg)\n\n\n\n\n\n此时请求users方法的URL方法的URL路径就是.../user/users\n\n@PreAuthorize 注解 方法前拦截判断是否有权限\n\n","slug":"7月31号","published":1,"updated":"2021-07-31T09:48:16.686Z","_id":"ckrrl59eb0005ps762fs7bxfm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg\"></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><ul>\n<li>建立视图，主键 主表选择，数据库脚本，</li>\n</ul>\n<p>表关联，一对一关联 一对多关联。增加字段</p>\n<ul>\n<li>界面视图，</li>\n<li>智能搜索app</li>\n<li>数据库对接 mongdb</li>\n</ul>\n<h2 id=\"开发手册\"><a href=\"#开发手册\" class=\"headerlink\" title=\"开发手册\"></a>开发手册</h2><p>DO / BO / DTO / VO / AO / PO / UID</p>\n<ul>\n<li><p>DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p>\n</li>\n<li><p>BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>\n</li>\n<li><p>DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于<strong>展示层与服务层之间的数据传输对象</strong>。</p>\n</li>\n<li><p>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p>\n</li>\n<li></li>\n</ul>\n<h3 id=\"log4jdbc\"><a href=\"#log4jdbc\" class=\"headerlink\" title=\"log4jdbc\"></a>log4jdbc</h3><p>Spring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成</p>\n<p><strong>JDBC</strong>：Java Database Connectivity， 有四种连接的方式</p>\n<p>主要用途是与数据库建立连接，发送sql语句，处理结果</p>\n<p>可以直接调用sql命令，并与其他的数据库连接API易于使用，<strong>低级接口</strong></p>\n<p>公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg\"></p>\n<p>log4jdbc是一个<strong>JDBC驱动器</strong>，能够记录<strong>SQL日志</strong>和<strong>SQL执行时间</strong>等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。</p>\n<p> 特性</p>\n<ul>\n<li>完全支持JDBC3和JDBC4</li>\n<li>配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4</li>\n<li>自动将占位符(?)替换为实际的参数</li>\n<li>能够及时方便地显示SQL的实际执行时间</li>\n<li>显示SQL Connection的数量的信息</li>\n<li>能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作</li>\n<li>支持现有大部分JDBC驱动。</li>\n<li>能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。</li>\n<li>能够<strong>快速标识出应用程序中执行比较慢的SQL语句</strong>。</li>\n<li>能够生成SQL连接数信息帮助识别连接池/线程问题。</li>\n<li>open source</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.35<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.16<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Jpa\"><a href=\"#Jpa\" class=\"headerlink\" title=\"Jpa\"></a>Jpa</h2><p>jpa拥有哪些注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描</span><br><span class=\"line\"><span class=\"meta\">@Table</span> 声明表名字</span><br><span class=\"line\"><span class=\"meta\">@Id</span> \t\t指定的类的属性，用于识别一个表中的主键</span><br><span class=\"line\"> <span class=\"meta\">@Transient</span> 指定的属性 它是不持久的，即该值永远不会存储在数据库中</span><br><span class=\"line\"> <span class=\"meta\">@Column</span>\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字</span><br><span class=\"line\"> </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置文件yml\"><a href=\"#配置文件yml\" class=\"headerlink\" title=\"配置文件yml\"></a>配置文件yml</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://localhost:3306/mytest</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span> <span class=\"string\">//驱动</span></span><br><span class=\"line\">  <span class=\"attr\">jpa:</span></span><br><span class=\"line\">    <span class=\"attr\">hibernate:</span></span><br><span class=\"line\">      <span class=\"attr\">ddl-auto:</span> <span class=\"string\">update</span> <span class=\"string\">//自动更新</span></span><br><span class=\"line\">    <span class=\"attr\">show-sql:</span> <span class=\"literal\">true</span>  <span class=\"string\">//日志中显示sql语句</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Hibernate是一个<a href=\"https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160\">开放源代码</a>的<a href=\"https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/311152\">对象关系映射</a>框架（<strong>不需要写SQL</strong>），它对<a href=\"https://baike.baidu.com/item/JDBC/485214\">JDBC</a>进行了非常轻量级的对象封装，它将<strong>POJO与数据库表建立映射关系</strong>，是一个全自动的orm框架，<strong>hibernate可以自动生成SQL语句</strong>，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p>\n<p>既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是<strong>我们MVC中的数据持久层-&gt;在编写程序中的DAO层…</strong></p>\n<p>首先，我们来回顾一下我们在DAO层写程序的历程吧：</p>\n<ol>\n<li><strong>在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD</strong></li>\n<li><strong>在DAO层使用原生JDBC连接数据库，实现CRUD</strong></li>\n<li><strong>嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件–&gt;DbUtils组件</strong></li>\n</ol>\n<h2 id=\"Controller注解\"><a href=\"#Controller注解\" class=\"headerlink\" title=\"Controller注解\"></a>Controller注解</h2><p>@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，</p>\n<p>并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\">　　<span class=\"meta\">@RequestMapping(&quot;/user&quot;)</span></span><br><span class=\"line\">　　<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    　　<span class=\"meta\">@RequestMapping(&quot;/users&quot;)</span></span><br><span class=\"line\">    　　<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">users</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        　　<span class=\"keyword\">return</span> <span class=\"string\">&quot;users&quot;</span>;</span><br><span class=\"line\">    　　&#125;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg\"></p>\n<p>此时请求users方法的URL方法的URL路径就是…/user/users</p>\n<p>@PreAuthorize 注解 方法前拦截判断是否有权限</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天忙着写一整套crud业务代码了，没顾得上debug看公司业务流程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt04a5t11rj31hc0u0n4j.jpg\"></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><ul>\n<li>建立视图，主键 主表选择，数据库脚本，</li>\n</ul>\n<p>表关联，一对一关联 一对多关联。增加字段</p>\n<ul>\n<li>界面视图，</li>\n<li>智能搜索app</li>\n<li>数据库对接 mongdb</li>\n</ul>\n<h2 id=\"开发手册\"><a href=\"#开发手册\" class=\"headerlink\" title=\"开发手册\"></a>开发手册</h2><p>DO / BO / DTO / VO / AO / PO / UID</p>\n<ul>\n<li><p>DO (Domain Object): 邻域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p>\n</li>\n<li><p>BO (business object)：业务对象，从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>\n</li>\n<li><p>DTO (Data Transfer Object): 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于<strong>展示层与服务层之间的数据传输对象</strong>。</p>\n</li>\n<li><p>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p>\n</li>\n<li></li>\n</ul>\n<h3 id=\"log4jdbc\"><a href=\"#log4jdbc\" class=\"headerlink\" title=\"log4jdbc\"></a>log4jdbc</h3><p>Spring Data JPA默认采用Hibernate实现。Hibernate的showSql配置只打印SQL，但并不打印SQL参数、执行时间等信息，如果需要这些信息，可以使用第三方工具log4jdbc来完成</p>\n<p><strong>JDBC</strong>：Java Database Connectivity， 有四种连接的方式</p>\n<p>主要用途是与数据库建立连接，发送sql语句，处理结果</p>\n<p>可以直接调用sql命令，并与其他的数据库连接API易于使用，<strong>低级接口</strong></p>\n<p>公司接的大杯咖啡☕️，好评，没糖喝着喝着也习惯了<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt047si7ppj30u0140dir.jpg\"></p>\n<p>log4jdbc是一个<strong>JDBC驱动器</strong>，能够记录<strong>SQL日志</strong>和<strong>SQL执行时间</strong>等信息。log4jdbc使用SLF4J（Simple Logging Facade）作为日志系统。</p>\n<p> 特性</p>\n<ul>\n<li>完全支持JDBC3和JDBC4</li>\n<li>配置简单，一般情况下你只需要将你的DriverClass改为:net.sf.log4jdbc.DriverSpy，并在你的jdbcUrl之前拼接jdbc:log4</li>\n<li>自动将占位符(?)替换为实际的参数</li>\n<li>能够及时方便地显示SQL的实际执行时间</li>\n<li>显示SQL Connection的数量的信息</li>\n<li>能在JDK1.4+和SLF4J1.X上和大多数常见的JDBC驱动协同工作</li>\n<li>支持现有大部分JDBC驱动。</li>\n<li>能够自动把SQL变量值加到SQL输出日志中，改进易读性和方便调试。</li>\n<li>能够<strong>快速标识出应用程序中执行比较慢的SQL语句</strong>。</li>\n<li>能够生成SQL连接数信息帮助识别连接池/线程问题。</li>\n<li>open source</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.googlecode.log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.35<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.16<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Jpa\"><a href=\"#Jpa\" class=\"headerlink\" title=\"Jpa\"></a>Jpa</h2><p>jpa拥有哪些注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span>  声明类为实体或表，跟数据库是一一映射的，springboot启动的时候会扫描</span><br><span class=\"line\"><span class=\"meta\">@Table</span> 声明表名字</span><br><span class=\"line\"><span class=\"meta\">@Id</span> \t\t指定的类的属性，用于识别一个表中的主键</span><br><span class=\"line\"> <span class=\"meta\">@Transient</span> 指定的属性 它是不持久的，即该值永远不会存储在数据库中</span><br><span class=\"line\"> <span class=\"meta\">@Column</span>\t指定持久属性栏属性，用来标识实体类中属性与数据表中字段的对应关系，name=数据库中表字段的名字</span><br><span class=\"line\"> </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置文件yml\"><a href=\"#配置文件yml\" class=\"headerlink\" title=\"配置文件yml\"></a>配置文件yml</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">datasource:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">jdbc:mysql://localhost:3306/mytest</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">root</span></span><br><span class=\"line\">    <span class=\"attr\">driver-class-name:</span> <span class=\"string\">com.mysql.jdbc.Driver</span> <span class=\"string\">//驱动</span></span><br><span class=\"line\">  <span class=\"attr\">jpa:</span></span><br><span class=\"line\">    <span class=\"attr\">hibernate:</span></span><br><span class=\"line\">      <span class=\"attr\">ddl-auto:</span> <span class=\"string\">update</span> <span class=\"string\">//自动更新</span></span><br><span class=\"line\">    <span class=\"attr\">show-sql:</span> <span class=\"literal\">true</span>  <span class=\"string\">//日志中显示sql语句</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Hibernate是一个<a href=\"https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160\">开放源代码</a>的<a href=\"https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/311152\">对象关系映射</a>框架（<strong>不需要写SQL</strong>），它对<a href=\"https://baike.baidu.com/item/JDBC/485214\">JDBC</a>进行了非常轻量级的对象封装，它将<strong>POJO与数据库表建立映射关系</strong>，是一个全自动的orm框架，<strong>hibernate可以自动生成SQL语句</strong>，(我的理解是后台对数据进行操作，然后他自动写入数据库，而写入数据库是需要sql语句的，他这边是自动生成的)自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p>\n<p>既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是<strong>我们MVC中的数据持久层-&gt;在编写程序中的DAO层…</strong></p>\n<p>首先，我们来回顾一下我们在DAO层写程序的历程吧：</p>\n<ol>\n<li><strong>在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD</strong></li>\n<li><strong>在DAO层使用原生JDBC连接数据库，实现CRUD</strong></li>\n<li><strong>嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件–&gt;DbUtils组件</strong></li>\n</ol>\n<h2 id=\"Controller注解\"><a href=\"#Controller注解\" class=\"headerlink\" title=\"Controller注解\"></a>Controller注解</h2><p>@RequestMapping注解是用来映射请求的，指明处理器可以处理哪些URL请求，可以用在类和方法上，</p>\n<p>并且可以通过@PathVariable注解获取作为方法的参数，也可以上通配符筛选请求地址。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\">　　<span class=\"meta\">@RequestMapping(&quot;/user&quot;)</span></span><br><span class=\"line\">　　<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    　　<span class=\"meta\">@RequestMapping(&quot;/users&quot;)</span></span><br><span class=\"line\">    　　<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">users</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        　　<span class=\"keyword\">return</span> <span class=\"string\">&quot;users&quot;</span>;</span><br><span class=\"line\">    　　&#125;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt063tpu55j30dh078wf8.jpg\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0644n9ytj30x503r74d.jpg\"></p>\n<p>此时请求users方法的URL方法的URL路径就是…/user/users</p>\n<p>@PreAuthorize 注解 方法前拦截判断是否有权限</p>\n"},{"title":"盘点我从无到有搭建一个Springboot遇到的坑","date":"2021-07-31T08:46:33.000Z","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt0a709vq7j318z0u043r.jpg","_content":"\n\n\n以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg)\n\n\n\npost模拟写入请求：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg)\n\n\n\n## 坑盘点\n\n### 整个流程不清楚\n\n写代码就没有办法有清晰的思路，例如本次请求： http://localhost:8080/user/add\n\n### URL\n\n传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg)\n\n\n\n之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，\n\n http://localhost:8080+/ 之后，是找到了项目开始的地方，\n\n### controller\n\n去controller匹配我后面的路径\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg)\n\n\n\nhttp://localhost:8080/user/add 分发到了adduserRestful方法，这个方法需要调用服务层，\n\n### service\n\n即\n\nuserService.addUer(user)\n\n这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg)\n\n这里逐一解释那些注解，\n\n- @Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个**表在数据库中**是可以一一映射的。\n- @Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字\n- Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错\n- GeneratedValue是主键自增，括号内自增的方式也是必不可少，**如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配**！否则报错。\n- @Column就是类属性和数据库中字段相匹配，name即是数据库中的名字\n- @Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增\n\n请求体中提交的json：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg)\n\njson本质上是一个字符串，变成现成的类对象给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n需要解析出来，\n\n### domain\n\n这个过程是由user类的注解协助完成的\n\n再返回给addUserRestful，然后调用service，\n\n![image-20210731171750135](/Users/wuzhenren/myblog/source/_posts/盘点我从无到有搭建一个Springboot遇到的坑.assets/image-20210731171750135.png)\n\n\n\n@Service注解是告知，服务层在这里，\n\n 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：\n\n```xml\n<!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 -->\n<context:component-scan base-package=\"com.study.persistent\" />\n```\n\n在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，\n\n如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，\n\n类似的还包括@Component、@Repository、@Controller。\n\n```java\n@Service(\"courseDAO\")\n@Scope(\"prototype\")\npublic class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO{\n......\n}\n```\n\n 其作用就相当于在applicationContext.xml配置文件里配置如下信息：\n\n```xml\n<bean id=\"courseDAO\"\n      class=\"com.study.persistent.CourseDAOImpl\" scope=\"prototype\">\n      ......    \n</bean>\n```\n\n如果Service括号的参数不写的话，默认是跟类名字是一样的，\n\n```java\n@Service\n\npublic class UserServiceimpl implements UserService {\n```\n\n\n\n写了的话，相当于给这个类起了个别名，\n\n### 交给controlled->service\n\njson解析完成后，返回给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n\n\nservice层的方法\n\n```java\n@Override\n    @Transactional(rollbackFor = Exception.class)\n    public void addUser(User user) {\n        userApiRepository.save(user);\n    }\n```\n\n### 写入数据库\n\nuserApiRepository是继承了JPA的方法的，有save方法。\n\n```java\npublic interface UserApiRepository extends JpaRepository<User,Integer>, JpaSpecificationExecutor<User> {\n}\n```\n\n通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa\n\n最终这条记录在数据库中躺着\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg)\n\n\n\n","source":"_posts/盘点我从无到有搭建一个Springboot遇到的坑.md","raw":"---\ntitle: 盘点我从无到有搭建一个Springboot遇到的坑\ndate: 2021-07-31 16:46:33\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt0a709vq7j318z0u043r.jpg\n---\n\n\n\n以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg)\n\n\n\npost模拟写入请求：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg)\n\n\n\n## 坑盘点\n\n### 整个流程不清楚\n\n写代码就没有办法有清晰的思路，例如本次请求： http://localhost:8080/user/add\n\n### URL\n\n传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg)\n\n\n\n之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，\n\n http://localhost:8080+/ 之后，是找到了项目开始的地方，\n\n### controller\n\n去controller匹配我后面的路径\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg)\n\n\n\nhttp://localhost:8080/user/add 分发到了adduserRestful方法，这个方法需要调用服务层，\n\n### service\n\n即\n\nuserService.addUer(user)\n\n这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg)\n\n这里逐一解释那些注解，\n\n- @Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个**表在数据库中**是可以一一映射的。\n- @Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字\n- Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错\n- GeneratedValue是主键自增，括号内自增的方式也是必不可少，**如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配**！否则报错。\n- @Column就是类属性和数据库中字段相匹配，name即是数据库中的名字\n- @Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增\n\n请求体中提交的json：\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg)\n\njson本质上是一个字符串，变成现成的类对象给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n需要解析出来，\n\n### domain\n\n这个过程是由user类的注解协助完成的\n\n再返回给addUserRestful，然后调用service，\n\n![image-20210731171750135](/Users/wuzhenren/myblog/source/_posts/盘点我从无到有搭建一个Springboot遇到的坑.assets/image-20210731171750135.png)\n\n\n\n@Service注解是告知，服务层在这里，\n\n 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：\n\n```xml\n<!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 -->\n<context:component-scan base-package=\"com.study.persistent\" />\n```\n\n在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，\n\n如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，\n\n类似的还包括@Component、@Repository、@Controller。\n\n```java\n@Service(\"courseDAO\")\n@Scope(\"prototype\")\npublic class CourseDAOImpl extends HibernateDaoSupport implements CourseDAO{\n......\n}\n```\n\n 其作用就相当于在applicationContext.xml配置文件里配置如下信息：\n\n```xml\n<bean id=\"courseDAO\"\n      class=\"com.study.persistent.CourseDAOImpl\" scope=\"prototype\">\n      ......    \n</bean>\n```\n\n如果Service括号的参数不写的话，默认是跟类名字是一样的，\n\n```java\n@Service\n\npublic class UserServiceimpl implements UserService {\n```\n\n\n\n写了的话，相当于给这个类起了个别名，\n\n### 交给controlled->service\n\njson解析完成后，返回给\n\n```java\n@PostMapping(\"/add\")\n    public void addUserRestful(@RequestBody User user){userService.addUser(user);}\n```\n\n\n\nservice层的方法\n\n```java\n@Override\n    @Transactional(rollbackFor = Exception.class)\n    public void addUser(User user) {\n        userApiRepository.save(user);\n    }\n```\n\n### 写入数据库\n\nuserApiRepository是继承了JPA的方法的，有save方法。\n\n```java\npublic interface UserApiRepository extends JpaRepository<User,Integer>, JpaSpecificationExecutor<User> {\n}\n```\n\n通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa\n\n最终这条记录在数据库中躺着\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg)\n\n\n\n","slug":"盘点我从无到有搭建一个Springboot遇到的坑","published":1,"updated":"2021-07-31T09:57:17.094Z","_id":"ckrrl59ec0006ps76fdgk55fu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg\"></p>\n<p>post模拟写入请求：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg\"></p>\n<h2 id=\"坑盘点\"><a href=\"#坑盘点\" class=\"headerlink\" title=\"坑盘点\"></a>坑盘点</h2><h3 id=\"整个流程不清楚\"><a href=\"#整个流程不清楚\" class=\"headerlink\" title=\"整个流程不清楚\"></a>整个流程不清楚</h3><p>写代码就没有办法有清晰的思路，例如本次请求： <a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a></p>\n<h3 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h3><p>传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg\"></p>\n<p>之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，</p>\n<p> <a href=\"http://localhost:8080+/\">http://localhost:8080+/</a> 之后，是找到了项目开始的地方，</p>\n<h3 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h3><p>去controller匹配我后面的路径</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg\"></p>\n<p><a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a> 分发到了adduserRestful方法，这个方法需要调用服务层，</p>\n<h3 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h3><p>即</p>\n<p>userService.addUer(user)</p>\n<p>这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg\"></p>\n<p>这里逐一解释那些注解，</p>\n<ul>\n<li>@Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个<strong>表在数据库中</strong>是可以一一映射的。</li>\n<li>@Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字</li>\n<li>Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错</li>\n<li>GeneratedValue是主键自增，括号内自增的方式也是必不可少，<strong>如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配</strong>！否则报错。</li>\n<li>@Column就是类属性和数据库中字段相匹配，name即是数据库中的名字</li>\n<li>@Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增</li>\n</ul>\n<p>请求体中提交的json：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg\"></p>\n<p>json本质上是一个字符串，变成现成的类对象给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要解析出来，</p>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>这个过程是由user类的注解协助完成的</p>\n<p>再返回给addUserRestful，然后调用service，</p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E7%9B%98%E7%82%B9%E6%88%91%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AASpringboot%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.assets/image-20210731171750135.png\" alt=\"image-20210731171750135\"></p>\n<p>@Service注解是告知，服务层在这里，</p>\n<p> 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.study.persistent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，</p>\n<p>如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，</p>\n<p>类似的还包括@Component、@Repository、@Controller。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service(&quot;courseDAO&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CourseDAOImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">CourseDAO</span></span>&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 其作用就相当于在applicationContext.xml配置文件里配置如下信息：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;courseDAO&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.persistent.CourseDAOImpl&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;prototype&quot;</span>&gt;</span></span><br><span class=\"line\">      ......    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果Service括号的参数不写的话，默认是跟类名字是一样的，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceimpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>写了的话，相当于给这个类起了个别名，</p>\n<h3 id=\"交给controlled-gt-service\"><a href=\"#交给controlled-gt-service\" class=\"headerlink\" title=\"交给controlled-&gt;service\"></a>交给controlled-&gt;service</h3><p>json解析完成后，返回给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>service层的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        userApiRepository.save(user);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写入数据库\"><a href=\"#写入数据库\" class=\"headerlink\" title=\"写入数据库\"></a>写入数据库</h3><p>userApiRepository是继承了JPA的方法的，有save方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserApiRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>,<span class=\"title\">Integer</span>&gt;, <span class=\"title\">JpaSpecificationExecutor</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa</p>\n<p>最终这条记录在数据库中躺着</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前的学校的时候，搭建项目，配置环境一度让我很头疼，只能用别人写好的现成的代码，这次从项目的创建，各个分层的代码、到application.yml、数据库的连接，最终到我网址输入一条增加命令，更新到了数据库的过程</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08enthd4j30m40c3q3j.jpg\"></p>\n<p>post模拟写入请求：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08d8i4d9j31ce0pi40t.jpg\"></p>\n<h2 id=\"坑盘点\"><a href=\"#坑盘点\" class=\"headerlink\" title=\"坑盘点\"></a>坑盘点</h2><h3 id=\"整个流程不清楚\"><a href=\"#整个流程不清楚\" class=\"headerlink\" title=\"整个流程不清楚\"></a>整个流程不清楚</h3><p>写代码就没有办法有清晰的思路，例如本次请求： <a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a></p>\n<h3 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h3><p>传到服务器，会选择本地端口号，因为本地服务器可能运行了多个项目，到了8080之后，还需要选择项目名称，这里在application配置了</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08hfbbijj310y0l4aeg.jpg\"></p>\n<p>之前写配置文件的时候，context-path是需要写在servlet里面的，我没写servlet导致一直报错，</p>\n<p> <a href=\"http://localhost:8080+/\">http://localhost:8080+/</a> 之后，是找到了项目开始的地方，</p>\n<h3 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h3><p>去controller匹配我后面的路径</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08l9yooqj31ai0ka0yj.jpg\"></p>\n<p><a href=\"http://localhost:8080/user/add\">http://localhost:8080/user/add</a> 分发到了adduserRestful方法，这个方法需要调用服务层，</p>\n<h3 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h3><p>即</p>\n<p>userService.addUer(user)</p>\n<p>这里又有个坑，adduserRestful()方法里面不能直接填入User user参数，因为前端给的数据是json文件，而不是一个user类，需要@RequestBody User user把对象解析出来，这里附上User的图</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08q8l01vj31gs0u0n3g.jpg\"></p>\n<p>这里逐一解释那些注解，</p>\n<ul>\n<li>@Entity注解，在javax.persistence包中，使用@Entity注解去定义JPA中的实体，说明这个<strong>表在数据库中</strong>是可以一一映射的。</li>\n<li>@Table注解用来说明该实体类对应数据库中哪个类，name即数据库中表的名字</li>\n<li>Getter和Setter注解等价于@Data注解，相当于一种注入方法吧，GetID之类的方法即不用写了，写了好像会报错</li>\n<li>GeneratedValue是主键自增，括号内自增的方式也是必不可少，<strong>如果用了这个注解，数据库中也要选取主键并且要设置自增方法与此匹配</strong>！否则报错。</li>\n<li>@Column就是类属性和数据库中字段相匹配，name即是数据库中的名字</li>\n<li>@Id注解是说明这个属性是注解，默认从1开始，post不写这个字段都可以，会自增</li>\n</ul>\n<p>请求体中提交的json：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt08z66fkgj30yk0j40ue.jpg\"></p>\n<p>json本质上是一个字符串，变成现成的类对象给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要解析出来，</p>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>这个过程是由user类的注解协助完成的</p>\n<p>再返回给addUserRestful，然后调用service，</p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E7%9B%98%E7%82%B9%E6%88%91%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AASpringboot%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.assets/image-20210731171750135.png\" alt=\"image-20210731171750135\"></p>\n<p>@Service注解是告知，服务层在这里，</p>\n<p> 要说明@Service注解的使用，就得说一下我们经常在spring配置文件applicationContext.xml中看到如下图中的配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 采用扫描 + 注解的方式进行开发 可以提高开发效率，后期维护变的困难了，可读性变差了 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">&quot;com.study.persistent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在applicationContext.xml配置文件中加上这一行以后，将自动扫描指定路径下的包，</p>\n<p>如果一个类带了@Service注解，将自动注册到Spring容器，不需要再在applicationContext.xml配置文件中定义bean了，</p>\n<p>类似的还包括@Component、@Repository、@Controller。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service(&quot;courseDAO&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CourseDAOImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">HibernateDaoSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">CourseDAO</span></span>&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 其作用就相当于在applicationContext.xml配置文件里配置如下信息：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;courseDAO&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.study.persistent.CourseDAOImpl&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;prototype&quot;</span>&gt;</span></span><br><span class=\"line\">      ......    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果Service括号的参数不写的话，默认是跟类名字是一样的，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceimpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>写了的话，相当于给这个类起了个别名，</p>\n<h3 id=\"交给controlled-gt-service\"><a href=\"#交给controlled-gt-service\" class=\"headerlink\" title=\"交给controlled-&gt;service\"></a>交给controlled-&gt;service</h3><p>json解析完成后，返回给</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/add&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUserRestful</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span></span>&#123;userService.addUser(user);&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>service层的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        userApiRepository.save(user);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写入数据库\"><a href=\"#写入数据库\" class=\"headerlink\" title=\"写入数据库\"></a>写入数据库</h3><p>userApiRepository是继承了JPA的方法的，有save方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserApiRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>,<span class=\"title\">Integer</span>&gt;, <span class=\"title\">JpaSpecificationExecutor</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过获得的user类，JPA将数据save到数据库中，怎么实现的详情了解Jpa</p>\n<p>最终这条记录在数据库中躺着</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt09oj8gmrj30mw09p3z4.jpg\"></p>\n"},{"title":"谢希科老师数据库前沿课的论文pre","date":"2021-07-31T10:40:08.000Z","thumbnail":"https://picjumbo.com/wp-content/uploads/website-programming-code-free-photo-2210x1473.jpg","_content":"之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好\n\n## pre要求\n全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。\n\n要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。\n\nppt的讲诉，不能太长，要突出重点，\n\n讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。\n\n## 论文选题\n相比研究之前的skyline，我更希望看点对我有用的东西，\n\n所以我准备选取数据库方向的文章。\n\nSPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020\n\n离谱，wps新版的划词翻译的地方还不好找，\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg)\n\n如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。\n\n短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法\n复杂OLAP查询的快速n元连接查询处理方法","source":"_posts/谢希科老师数据库前沿课的论文pre.md","raw":"---\ntitle: 谢希科老师数据库前沿课的论文pre\ndate: 2021-07-31 18:40:08\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/website-programming-code-free-photo-2210x1473.jpg\n---\n之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好\n\n## pre要求\n全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。\n\n要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。\n\nppt的讲诉，不能太长，要突出重点，\n\n讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。\n\n## 论文选题\n相比研究之前的skyline，我更希望看点对我有用的东西，\n\n所以我准备选取数据库方向的文章。\n\nSPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020\n\n离谱，wps新版的划词翻译的地方还不好找，\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg)\n\n如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。\n\n短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法\n复杂OLAP查询的快速n元连接查询处理方法","slug":"谢希科老师数据库前沿课的论文pre","published":1,"updated":"2021-07-31T11:07:00.798Z","_id":"ckrrnflas0000dr76gqb37nrj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好</p>\n<h2 id=\"pre要求\"><a href=\"#pre要求\" class=\"headerlink\" title=\"pre要求\"></a>pre要求</h2><p>全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。</p>\n<p>要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。</p>\n<p>ppt的讲诉，不能太长，要突出重点，</p>\n<p>讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。</p>\n<h2 id=\"论文选题\"><a href=\"#论文选题\" class=\"headerlink\" title=\"论文选题\"></a>论文选题</h2><p>相比研究之前的skyline，我更希望看点对我有用的东西，</p>\n<p>所以我准备选取数据库方向的文章。</p>\n<p>SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020</p>\n<p>离谱，wps新版的划词翻译的地方还不好找，<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg\"></p>\n<p>如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。</p>\n<p>短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法<br>复杂OLAP查询的快速n元连接查询处理方法</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前做了一次，被骂的狗血淋头，没想到谢老师的要求这么高，也没想到科软的hxd们这么卷。。。都准备的这么好</p>\n<h2 id=\"pre要求\"><a href=\"#pre要求\" class=\"headerlink\" title=\"pre要求\"></a>pre要求</h2><p>全英文讲诉，不能粘贴论文的文章，之前已经被骂过一次。</p>\n<p>要求理解论文的主要思想，不要怀疑老师不懂，老师都是有研究过这些论文的。</p>\n<p>ppt的讲诉，不能太长，要突出重点，</p>\n<p>讲诉的时候，要随时应对老师的提问，提问包含概念的理解，重要公式要求出现中ppt中。</p>\n<h2 id=\"论文选题\"><a href=\"#论文选题\" class=\"headerlink\" title=\"论文选题\"></a>论文选题</h2><p>相比研究之前的skyline，我更希望看点对我有用的东西，</p>\n<p>所以我准备选取数据库方向的文章。</p>\n<p>SPRINTER: A Fast n-ary Join Query Processing Method for Complex OLAP Queries. Yoon-Min Nam, Donghyoung Han, Min-Soo Kim. SIGMOD 2020</p>\n<p>离谱，wps新版的划词翻译的地方还不好找，<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0c3yhb81j32380h8n0g.jpg\"></p>\n<p>如果不登陆的话，功能都是灰色的，微信扫描之后功能就亮了。</p>\n<p>短跑器：一种针对复杂OLAP查询的快速n元连接查询处理方法<br>复杂OLAP查询的快速n元连接查询处理方法</p>\n"},{"layout":"sprinter：快速","title":"快速n元连接查询处理","date":"2021-07-31T11:50:46.000Z","type":"ustc","thumbnail":"https://picjumbo.com/wp-content/uploads/working-on-a-laptop-from-a-car-2210x1473.jpg","_content":"# SPRINTER：快速 n 元连接查询处理\n\n复杂 OLAP 查询的方法\n\n## 摘要\n\n​\tOLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。\n​\t在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。\n\n## 关键字\n\n​\tn连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理\n\n## **INTRODUCTION**\n\n​\t有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个\n这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。\n\n​\tOLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。\n\n​\t现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以\n\n​\t由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。\n\n​\t在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。\n\n​\t一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型启发式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。\n\n​\t我们的主要贡献总结如下：\n• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。\n• 我们提出了成本模型和查询优化n路连接树的方法。\n• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。\n• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。\n• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。\n\n本文的其余部分组织如下。\n\n在**第2.2节中**，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在**第3节中**，我们将描述本文的一个激励例子。\n\n在**Secti 在4**上，我们提出了n个连接树的查询规划方法。\n\n在**第5节中**，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m\n\n第**6节中的odel**。\n\n**第7节**介绍了实验评价的结果。\n\n最后，我们在**第8节中**讨论相关的工作，\n\n并在**第9节中**总结本文。\n\n## **PRELIMINARIES**\n\n### **Sorting algorithms**\n\n在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。\n\n表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。\n\n**Table 1:**在SPRINTER中使用的并行排序算法和技术。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg)\n\n​\t大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg)\n\n​\t\t图1：异构排序[15]的时间轴。\n\n### 2.2最坏情况下的最优连接算法\n\n​\t在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。\n\n​\t图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。\n\n​\t当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。\n\n![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图2：部落连接[13]的示例。\n\n## **3 动机**\n\n​\t在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图3：激励性查询的连接图。\n\n​\t图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。\n\n​\t图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。\n\n​\tOmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.\n\n​\t短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。\n\n​\t图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。\n\n## 4查询规划方法\n\n​\t在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图4：针对激励性查询的查询计划。\n\n### 4.1单个n个连接运算符的查询\n\n​\t对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。\n\n定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).\n\n​\t在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。\n\n​\t定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。\n\n​\t在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，д(e1)= FKKFKandд(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。\n\n​\t在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。\n\n​\t如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图5：激励性查询的分解。\n\n​\t算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg)\n\n​\t图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg)\n\n图6：针对激励性查询的查询计划。\n\n### 4.2多个n个连接运算符的查询\n\n​\t在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg)\n\n### 4.3搜索空间\n\n​\t我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg)\n\n​\t如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n​\t在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。\n\n## 5n-ARY JOIN处理方法\n\n​\t在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：估计连接变量的每个全局顺序的成本。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n  对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在aive方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)<Teval(Sj)(i<j)。步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。步骤5 根据全局顺序对每个结果进行rts，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)>TSort(Si)或Teval(Si)<Tsort(Si)。\n\n​\t在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n​\t\t\t\t\t图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。\n\n​\t时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n\n​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)>Tsort(Si)，还是Teval，都没有改变 (Si)<Tsort(Si)。\n\n​\t我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。\n\n \t即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)>Tsort(Si)还是Teval(Si)<TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n\n### 5.1全球订单的确定\n\n​\t一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e启发式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg)\n\n​\t算法3展示了我们的启发式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。\n\n![image-20210731201800921](/Users/wuzhenren/myblog/source/_posts/元连接查询处理.assets/image-20210731201800921.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图8：TPC-DSQ17的核心子图。\n\n### 5.2排序策略\n\n​\t在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图9：排序算法的选择策略。\n\n​\t如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。\n\n​\t但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。\n\n​\t由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。\n\n### 5.3合并加入排序关系\n\n​\t对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。\n\n​\t人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg)\n\n​\t\t\t\t\t\t\t\t\t图10：图8中的核心子图的合并连接示例。\n\n\n\n​\t\t\t\t\t\t\t\t\t\t表2：符号汇总表。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg)\n\n## 6个关于查询优化的成本模型\n\n​\t使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)<成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。\n\n### 6.1基础系统的成本模型\n\n​\t我们认为查询计划 Pold 由 M M 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).\n\n​\t![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg)\n\n​\t在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j>i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.\n\n### 6.2SPRINTER的成本模型\n\n​\t一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。\n\n​\t因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg)\n\n​\tEq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg)\n\n​\t如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg)\n\n Eq. 9,术语(1+loд（![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg))表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.\n\n## 7 实验评价\n\n​\t在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。\n\n### 7.1 实验设置\n\n​\t查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。\n\n​\t为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。\n\n​\t环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。\n\n系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。\n\n表3：**系统比较汇总**。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg)\n\n​\t对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。\n\n​\t我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用\n用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统\n利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。\n\n### 7.2 性能比较\n\n​\t图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。\n\n​\t与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。\n\nSPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg)\n\n​\t\t\t\t\t\t图11：使用TPC-DS基准查询(SF=100)的性能比较。\n\n​\t对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。\n\n​\tOmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。\n\n​\t相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。\n\n### 7.3 SPRINTER特征\n\n​\t成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t图12：成本模型的验证。\n\n​\t图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。\n\n​\t全局变量阶启发式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了启发式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的启发式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的启发式算法很简单，但很有效。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg)\n\n​\t\t\t\t\t\t\t图13：不同全局变量顺序的结果。\n\n​\t\t\t\t\t\t\t图14：性能分解的结果。\n\n​\t性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。\n\n​\t在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。\n\n​\t排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg)\n\n图15：排序策略的验证。\n\n## 8 相关工作\n\n​\t多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。\n\n​\t[2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。\n\n​\tWCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。\n\n​\tDunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。\n\n​\t对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。\n\n​\tOLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。\n\n## 9 结论\n\n​\t本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和启发式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。\n\n\n\n## **ACKNOWLEDGMENTS**\n\n​\t这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。\n","source":"_posts/元连接查询处理.md","raw":"---\nlayout: sprinter：快速\ntitle: 快速n元连接查询处理\ndate: 2021-07-31 19:50:46\ntype: \"ustc\"\ncategories:\n    - ustc\ntags:\nthumbnail: https://picjumbo.com/wp-content/uploads/working-on-a-laptop-from-a-car-2210x1473.jpg\n---\n# SPRINTER：快速 n 元连接查询处理\n\n复杂 OLAP 查询的方法\n\n## 摘要\n\n​\tOLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。\n​\t在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。\n\n## 关键字\n\n​\tn连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理\n\n## **INTRODUCTION**\n\n​\t有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个\n这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。\n\n​\tOLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。\n\n​\t现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以\n\n​\t由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。\n\n​\t在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。\n\n​\t一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型启发式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。\n\n​\t我们的主要贡献总结如下：\n• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。\n• 我们提出了成本模型和查询优化n路连接树的方法。\n• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。\n• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。\n• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。\n\n本文的其余部分组织如下。\n\n在**第2.2节中**，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在**第3节中**，我们将描述本文的一个激励例子。\n\n在**Secti 在4**上，我们提出了n个连接树的查询规划方法。\n\n在**第5节中**，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m\n\n第**6节中的odel**。\n\n**第7节**介绍了实验评价的结果。\n\n最后，我们在**第8节中**讨论相关的工作，\n\n并在**第9节中**总结本文。\n\n## **PRELIMINARIES**\n\n### **Sorting algorithms**\n\n在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。\n\n表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。\n\n**Table 1:**在SPRINTER中使用的并行排序算法和技术。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg)\n\n​\t大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg)\n\n​\t\t图1：异构排序[15]的时间轴。\n\n### 2.2最坏情况下的最优连接算法\n\n​\t在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。\n\n​\t图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。\n\n​\t当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。\n\n![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图2：部落连接[13]的示例。\n\n## **3 动机**\n\n​\t在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图3：激励性查询的连接图。\n\n​\t图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。\n\n​\t图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。\n\n​\tOmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.\n\n​\t短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。\n\n​\t图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。\n\n## 4查询规划方法\n\n​\t在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图4：针对激励性查询的查询计划。\n\n### 4.1单个n个连接运算符的查询\n\n​\t对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。\n\n定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).\n\n​\t在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。\n\n​\t定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。\n\n​\t在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，д(e1)= FKKFKandд(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。\n\n​\t在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。\n\n​\t如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t图5：激励性查询的分解。\n\n​\t算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg)\n\n​\t图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg)\n\n图6：针对激励性查询的查询计划。\n\n### 4.2多个n个连接运算符的查询\n\n​\t在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg)\n\n### 4.3搜索空间\n\n​\t我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg)\n\n​\t如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg)\n\n​\t在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。\n\n## 5n-ARY JOIN处理方法\n\n​\t在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。\n\n- 步骤1：逐个评估{S1、·、·、Sn}。\n- 步骤2：计算{S1、·、··、Sn}结果的必要统计数据。\n- 步骤3：估计连接变量的每个全局顺序的成本。 \n- 步骤4：选择最佳的全局变量顺序。\n- 步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。\n- 第6步：在n个已排序的关系上合并连接。\n\n  对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在aive方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)<Teval(Sj)(i<j)。步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。步骤5 根据全局顺序对每个结果进行rts，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)>TSort(Si)或Teval(Si)<Tsort(Si)。\n\n​\t在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg)\n\n​\t\t\t\t\t图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。\n\n​\t时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。\n\n- 步骤1：估计连接变量的每个全局顺序的成本。\n- 步骤2：选择最佳的全局变量顺序。\n- 步骤3：对结果进行重叠排序。\n- 步骤 4: 在n个已排序的关系上合并连接。\n\n​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)>Tsort(Si)，还是Teval，都没有改变 (Si)<Tsort(Si)。\n\n​\t我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。\n\n \t即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)>Tsort(Si)还是Teval(Si)<TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n\n### 5.1全球订单的确定\n\n​\t一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e启发式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg)\n\n​\t算法3展示了我们的启发式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。\n\n![image-20210731201800921](/Users/wuzhenren/myblog/source/_posts/元连接查询处理.assets/image-20210731201800921.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图8：TPC-DSQ17的核心子图。\n\n### 5.2排序策略\n\n​\t在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 \n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t图9：排序算法的选择策略。\n\n​\t如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。\n\n​\t但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。\n\n​\t由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。\n\n### 5.3合并加入排序关系\n\n​\t对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。\n\n​\t人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg)\n\n​\t\t\t\t\t\t\t\t\t图10：图8中的核心子图的合并连接示例。\n\n\n\n​\t\t\t\t\t\t\t\t\t\t表2：符号汇总表。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg)\n\n## 6个关于查询优化的成本模型\n\n​\t使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)<成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。\n\n### 6.1基础系统的成本模型\n\n​\t我们认为查询计划 Pold 由 M M 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).\n\n​\t![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg)\n\n​\t在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j>i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.\n\n### 6.2SPRINTER的成本模型\n\n​\t一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。\n\n​\t因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg)\n\n​\tEq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg)\n\n​\t如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg)\n\n Eq. 9,术语(1+loд（![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg))表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.\n\n## 7 实验评价\n\n​\t在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。\n\n### 7.1 实验设置\n\n​\t查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。\n\n​\t为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。\n\n​\t环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。\n\n系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。\n\n表3：**系统比较汇总**。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg)\n\n​\t对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。\n\n​\t我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用\n用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统\n利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。\n\n### 7.2 性能比较\n\n​\t图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。\n\n​\t与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。\n\nSPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg)\n\n​\t\t\t\t\t\t图11：使用TPC-DS基准查询(SF=100)的性能比较。\n\n​\t对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。\n\n​\tOmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。\n\n​\t相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。\n\n### 7.3 SPRINTER特征\n\n​\t成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t图12：成本模型的验证。\n\n​\t图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。\n\n​\t全局变量阶启发式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了启发式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的启发式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的启发式算法很简单，但很有效。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg)\n\n​\t\t\t\t\t\t\t图13：不同全局变量顺序的结果。\n\n​\t\t\t\t\t\t\t图14：性能分解的结果。\n\n​\t性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。\n\n​\t在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。\n\n​\t排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg)\n\n图15：排序策略的验证。\n\n## 8 相关工作\n\n​\t多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。\n\n​\t[2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。\n\n​\tWCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。\n\n​\tDunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。\n\n​\t对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。\n\n​\tOLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。\n\n## 9 结论\n\n​\t本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和启发式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。\n\n\n\n## **ACKNOWLEDGMENTS**\n\n​\t这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。\n","slug":"元连接查询处理","published":1,"updated":"2021-08-01T04:31:17.234Z","_id":"ckrrpvg2g0000wc762o87afmh","comments":1,"photos":[],"link":"","content":"<h1 id=\"SPRINTER：快速-n-元连接查询处理\"><a href=\"#SPRINTER：快速-n-元连接查询处理\" class=\"headerlink\" title=\"SPRINTER：快速 n 元连接查询处理\"></a>SPRINTER：快速 n 元连接查询处理</h1><p>复杂 OLAP 查询的方法</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>​    OLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。<br>​    在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。</p>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><p>​    n连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理</p>\n<h2 id=\"INTRODUCTION\"><a href=\"#INTRODUCTION\" class=\"headerlink\" title=\"INTRODUCTION\"></a><strong>INTRODUCTION</strong></h2><p>​    有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个<br>这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。</p>\n<p>​    OLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。</p>\n<p>​    现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以</p>\n<p>​    由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。</p>\n<p>​    在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。</p>\n<p>​    一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型启发式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。</p>\n<p>​    我们的主要贡献总结如下：<br>• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。<br>• 我们提出了成本模型和查询优化n路连接树的方法。<br>• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。<br>• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。<br>• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。</p>\n<p>本文的其余部分组织如下。</p>\n<p>在<strong>第2.2节中</strong>，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在<strong>第3节中</strong>，我们将描述本文的一个激励例子。</p>\n<p>在<strong>Secti 在4</strong>上，我们提出了n个连接树的查询规划方法。</p>\n<p>在<strong>第5节中</strong>，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m</p>\n<p>第<strong>6节中的odel</strong>。</p>\n<p><strong>第7节</strong>介绍了实验评价的结果。</p>\n<p>最后，我们在<strong>第8节中</strong>讨论相关的工作，</p>\n<p>并在<strong>第9节中</strong>总结本文。</p>\n<h2 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a><strong>PRELIMINARIES</strong></h2><h3 id=\"Sorting-algorithms\"><a href=\"#Sorting-algorithms\" class=\"headerlink\" title=\"Sorting algorithms\"></a><strong>Sorting algorithms</strong></h3><p>在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。</p>\n<p>表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。</p>\n<p>**Table 1:**在SPRINTER中使用的并行排序算法和技术。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg\"></p>\n<p>​    大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg\"></p>\n<p>​        图1：异构排序[15]的时间轴。</p>\n<h3 id=\"2-2最坏情况下的最优连接算法\"><a href=\"#2-2最坏情况下的最优连接算法\" class=\"headerlink\" title=\"2.2最坏情况下的最优连接算法\"></a>2.2最坏情况下的最优连接算法</h3><p>​    在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。</p>\n<p>​    图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。</p>\n<p>​    当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。</p>\n<p>![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)</p>\n<p>​                                                图2：部落连接[13]的示例。</p>\n<h2 id=\"3-动机\"><a href=\"#3-动机\" class=\"headerlink\" title=\"3 动机\"></a><strong>3 动机</strong></h2><p>​    在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg\"></p>\n<p>​                                            图3：激励性查询的连接图。</p>\n<p>​    图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。</p>\n<p>​    图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。</p>\n<p>​    OmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.</p>\n<p>​    短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。</p>\n<p>​    图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。</p>\n<h2 id=\"4查询规划方法\"><a href=\"#4查询规划方法\" class=\"headerlink\" title=\"4查询规划方法\"></a>4查询规划方法</h2><p>​    在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p>​                                                图4：针对激励性查询的查询计划。</p>\n<h3 id=\"4-1单个n个连接运算符的查询\"><a href=\"#4-1单个n个连接运算符的查询\" class=\"headerlink\" title=\"4.1单个n个连接运算符的查询\"></a>4.1单个n个连接运算符的查询</h3><p>​    对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。</p>\n<p>定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).</p>\n<p>​    在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。</p>\n<p>​    定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。</p>\n<p>​    在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，д(e1)= FKKFKandд(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。</p>\n<p>​    在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。</p>\n<p>​    如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>​                                            图5：激励性查询的分解。</p>\n<p>​    算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg\"></p>\n<p>​    图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg\"></p>\n<p>图6：针对激励性查询的查询计划。</p>\n<h3 id=\"4-2多个n个连接运算符的查询\"><a href=\"#4-2多个n个连接运算符的查询\" class=\"headerlink\" title=\"4.2多个n个连接运算符的查询\"></a>4.2多个n个连接运算符的查询</h3><p>​    在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg\"></p>\n<h3 id=\"4-3搜索空间\"><a href=\"#4-3搜索空间\" class=\"headerlink\" title=\"4.3搜索空间\"></a>4.3搜索空间</h3><p>​    我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg\"></p>\n<p>​    如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>​    在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。</p>\n<h2 id=\"5n-ARY-JOIN处理方法\"><a href=\"#5n-ARY-JOIN处理方法\" class=\"headerlink\" title=\"5n-ARY JOIN处理方法\"></a>5n-ARY JOIN处理方法</h2><p>​    在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。</p>\n<ul>\n<li><p>步骤1：逐个评估{S1、·、·、Sn}。</p>\n</li>\n<li><p>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</p>\n</li>\n<li><p>步骤3：估计连接变量的每个全局顺序的成本。 </p>\n</li>\n<li><p>步骤4：选择最佳的全局变量顺序。</p>\n</li>\n<li><p>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</p>\n</li>\n<li><p>第6步：在n个已排序的关系上合并连接。</p>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在aive方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)&lt;Teval(Sj)(i&lt;j)。步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。步骤5 根据全局顺序对每个结果进行rts，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)&gt;TSort(Si)或Teval(Si)&lt;Tsort(Si)。</p>\n</li>\n</ul>\n<p>​    在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<p>​                    图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。</p>\n<p>​    时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。</li>\n</ul>\n<p>​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)&gt;Tsort(Si)，还是Teval，都没有改变 (Si)&lt;Tsort(Si)。</p>\n<p>​    我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。</p>\n<pre><code> 即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)&gt;Tsort(Si)还是Teval(Si)&lt;TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n</code></pre>\n<h3 id=\"5-1全球订单的确定\"><a href=\"#5-1全球订单的确定\" class=\"headerlink\" title=\"5.1全球订单的确定\"></a>5.1全球订单的确定</h3><p>​    一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e启发式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg\"></p>\n<p>​    算法3展示了我们的启发式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。</p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E5%85%83%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86.assets/image-20210731201800921.png\" alt=\"image-20210731201800921\"></p>\n<p>​                                            图8：TPC-DSQ17的核心子图。</p>\n<h3 id=\"5-2排序策略\"><a href=\"#5-2排序策略\" class=\"headerlink\" title=\"5.2排序策略\"></a>5.2排序策略</h3><p>​    在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg\"></p>\n<p>​                                                图9：排序算法的选择策略。</p>\n<p>​    如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。</p>\n<p>​    但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。</p>\n<p>​    由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。</p>\n<h3 id=\"5-3合并加入排序关系\"><a href=\"#5-3合并加入排序关系\" class=\"headerlink\" title=\"5.3合并加入排序关系\"></a>5.3合并加入排序关系</h3><p>​    对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。</p>\n<p>​    人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg\"></p>\n<p>​                                    图10：图8中的核心子图的合并连接示例。</p>\n<p>​                                        表2：符号汇总表。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg\"></p>\n<h2 id=\"6个关于查询优化的成本模型\"><a href=\"#6个关于查询优化的成本模型\" class=\"headerlink\" title=\"6个关于查询优化的成本模型\"></a>6个关于查询优化的成本模型</h2><p>​    使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)&lt;成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。</p>\n<h3 id=\"6-1基础系统的成本模型\"><a href=\"#6-1基础系统的成本模型\" class=\"headerlink\" title=\"6.1基础系统的成本模型\"></a>6.1基础系统的成本模型</h3><p>​    我们认为查询计划 Pold 由 M M 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).</p>\n<p>​    <img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg\"></p>\n<p>​    在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j&gt;i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.</p>\n<h3 id=\"6-2SPRINTER的成本模型\"><a href=\"#6-2SPRINTER的成本模型\" class=\"headerlink\" title=\"6.2SPRINTER的成本模型\"></a>6.2SPRINTER的成本模型</h3><p>​    一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。</p>\n<p>​    因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg\"></p>\n<p>​    Eq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg\"></p>\n<p>​    如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg\"></p>\n<p> Eq. 9,术语(1+loд（<img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg\">)表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.</p>\n<h2 id=\"7-实验评价\"><a href=\"#7-实验评价\" class=\"headerlink\" title=\"7 实验评价\"></a>7 实验评价</h2><p>​    在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。</p>\n<h3 id=\"7-1-实验设置\"><a href=\"#7-1-实验设置\" class=\"headerlink\" title=\"7.1 实验设置\"></a>7.1 实验设置</h3><p>​    查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。</p>\n<p>​    为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。</p>\n<p>​    环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。</p>\n<p>系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。</p>\n<p>表3：<strong>系统比较汇总</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg\"></p>\n<p>​    对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。</p>\n<p>​    我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用<br>用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统<br>利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。</p>\n<h3 id=\"7-2-性能比较\"><a href=\"#7-2-性能比较\" class=\"headerlink\" title=\"7.2 性能比较\"></a>7.2 性能比较</h3><p>​    图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。</p>\n<p>​    与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。</p>\n<p>SPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg\"></p>\n<p>​                        图11：使用TPC-DS基准查询(SF=100)的性能比较。</p>\n<p>​    对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。</p>\n<p>​    OmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。</p>\n<p>​    相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。</p>\n<h3 id=\"7-3-SPRINTER特征\"><a href=\"#7-3-SPRINTER特征\" class=\"headerlink\" title=\"7.3 SPRINTER特征\"></a>7.3 SPRINTER特征</h3><p>​    成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg\"></p>\n<p>​                                                    图12：成本模型的验证。</p>\n<p>​    图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。</p>\n<p>​    全局变量阶启发式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了启发式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的启发式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的启发式算法很简单，但很有效。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg\"></p>\n<p>​                            图13：不同全局变量顺序的结果。</p>\n<p>​                            图14：性能分解的结果。</p>\n<p>​    性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。</p>\n<p>​    在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。</p>\n<p>​    排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg\"></p>\n<p>图15：排序策略的验证。</p>\n<h2 id=\"8-相关工作\"><a href=\"#8-相关工作\" class=\"headerlink\" title=\"8 相关工作\"></a>8 相关工作</h2><p>​    多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。</p>\n<p>​    [2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。</p>\n<p>​    WCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。</p>\n<p>​    DunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。</p>\n<p>​    对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。</p>\n<p>​    OLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。</p>\n<h2 id=\"9-结论\"><a href=\"#9-结论\" class=\"headerlink\" title=\"9 结论\"></a>9 结论</h2><p>​    本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和启发式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。</p>\n<h2 id=\"ACKNOWLEDGMENTS\"><a href=\"#ACKNOWLEDGMENTS\" class=\"headerlink\" title=\"ACKNOWLEDGMENTS\"></a><strong>ACKNOWLEDGMENTS</strong></h2><p>​    这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SPRINTER：快速-n-元连接查询处理\"><a href=\"#SPRINTER：快速-n-元连接查询处理\" class=\"headerlink\" title=\"SPRINTER：快速 n 元连接查询处理\"></a>SPRINTER：快速 n 元连接查询处理</h1><p>复杂 OLAP 查询的方法</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>​    OLAP查询处理的概念现在被广泛使用被各种应用所采用。复数包含非唯一键（称为FK-FK 连接）在这些应用程序中增加。然而现有的内存 OLAP 系统往往不处理这种高效的复杂查询，因为它们会产生大量的中间结果或招致大量的探测成本。<br>​    在本文中，我们提出了一种有效的查询规划方法用于复杂的 OLAP 查询。它基于成本模型生成包含 n 元连接运算符的查询计划。该计划确实不生成处理 FK-FK 连接的中间结果并显着降低探头成本。我们还提出了一个n元连接运算符的有效处理方法。我们通过集成我们的系统来实现原型系统 SPRINTER将建议的方法转化为开源的内存中 OLAP系统。通过使用 TPC-DS 基准的实验，我们已经证明，对于复杂查询，SPRINTER 的性能优于最先进的 OLAP 系统。</p>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><p>​    n连接运算符，查询规划，查询优化，FKFK连接，复杂OLAP查询处理，协同处理</p>\n<h2 id=\"INTRODUCTION\"><a href=\"#INTRODUCTION\" class=\"headerlink\" title=\"INTRODUCTION\"></a><strong>INTRODUCTION</strong></h2><p>​    有许多用于大规模数据分析的内存中 OLAP 查询处理系统，例如 Quick step [34]、MemSQL [11]、MonetDB [9]、Hyrise [16]、Ora cle [23] 、DB2 [6]、SQL Server [24]、SAP HANA [41]、Peloton [28]、OmniSci [33]、CoGaDB [10]、Kinetica [21] 和豹猫 [17]。 这些系统主要专注于有效处理传统的星形/雪花连接查询，这些查询包含一个主键之间的一些连接操作表和另一个表的外键 [45, 50]。 中的一个<br>这些系统中查询优化的目标是减少由连接引起的处理中间结果的成本查询计划中的操作 [40, 45]。 为实现目标，现有系统利用了各种技术，例如中间结果的流水线[28, 50]。</p>\n<p>​    OLAP查询处理的概念现在正被广泛应用于各种应用中，包括图形分析[1,13]、人工智能[22][20,26]和生物信息学[20,26]。作为应用程序 如果会变得越来越复杂，这些应用程序中的查询工作负载往往会变得越来越复杂。特别是，包含一对外部操作之间的连接操作的查询的数量 唯一的)键，而不是传统的一对主键和外键在应用程序中增加。本文将这种连接操作表示为FK-FK连接。一个FK-FK连接通常会产生一个lar 由于重复的连接键值而导致的连接结果数。如果查询包含两个事实表之间的FK-FK连接操作(s)，则由于hu，高效处理查询将变得更加困难 中间结果的通用量。这种复杂的查询通常发生在具有包含多个星形或雪花模式[3]的暴风雪模式的数据库上。例如，TPC-DS 基准测试使用一个暴风雪模式，在TPC-DS基准测试中总共99个查询中的26个（即26.2%的查询）包含一个或多个FK-FK连接操作[30]。</p>\n<p>​    现有的OLAP系统往往不能有效地处理包含FK-FK连接操作的复杂查询。它们通常会生成一个左深的连接树，并在一个实时操作员中处理该计划 方式，哪里可以</p>\n<p>​    由于查询中FK-FK连接（或非键连接）操作符的下一个操作符无法处理的中间结果太大，因此会显著降级，或处理本身可能会失败 计划[47]。流水线技术通过在一组由其余关系构建的哈希表中查找探测关系的每个元组来计算连接树中的一系列多个连接运算符 [27,50]。它可能对PK-FK连接的查询有效，但对于事实表中包含FK-FK连接的复杂查询可能无效，因为存在以下两个问题：许多关键比较 以及大量的内存使用量。首先，探测关系中每个元组的连接键值需要与哈希表中的所有重复键值相匹配。可能会有很多比赛到期 对于FK-FK连接操作，这可以根据连接键值的重复程度成比例地大大降低查询性能。其次，保留一组由非专业人员构建的所有哈列表 主存中的关系需要大量内存，特别是当表数量增加时。由于上述两个问题，性能可能会显著下降，或者 当我们对包含FK-FK连接的查询使用管道技术时，处理本身可能会失败。</p>\n<p>​    在本文中，我们提出了一种有效的查询处理方法，用于包含FK-FK连接的复杂OLAP查询。SPRINTER背后的直觉是，一个n-ary连接操作数的查询计划 与一系列二进制连接运算符之一相比，or可以减少中间结果的数量，而且多路连接处理[44]并不总是这样，但对于处理t可以非常有效 他查询计划。多路连接处理已用于分布式查询处理[2,13,49]和图形模式查询处理[31,44]，但几乎没有在内存中的OLAP系统中使用 由于哈希连接在内存内处理环境[5,39]中通常优于排序合并连接，并且OLAP查询是不同于图形模式查询的特别查询和无环查询。我们提出了一个查询计划 可以生成包含n-ary连接运算符的查询计划，而不是只有一系列二进制连接运算符的传统计划的查询方法。</p>\n<p>​    一般来说，生成一个具有n-ary连接运算符(称为n-ary连接树)的查询计划是很简单的，因为查询计划的搜索空间比只考虑bina时变得更大 ry加入操作员。我们提出的查询规划方法基于成本模型启发式和递归地搜索一个良好的查询计划。我们提出了所使用的成本模型和一种查询优化方法 t允许查询规划方法只有在与传统的二进制左深连接树相比有益时才生成n-ary连接树。然后，我们解释了单向连接处理方法 r是一个基于最坏情况最优连接算法的n个连接算子。我们实现了我们所有的方法成为一个开源的现代内存OLAP处理系统，OmniSci[33]，跨所有相关的层和模块，包括查询计划生成器和物理连接操作符。通过出口 在使用TPC-DS基准测试进行的化学实验中，我们已经证明了SPRINTER在处理速度和数据方面都显著优于最先进的OLAP查询处理系统 可以处理的没有内存的大小。</p>\n<p>​    我们的主要贡献总结如下：<br>• 我们提出了一种查询规划方法，可以生成复杂 OLAP 查询的 n 元连接树包含FK-FK 加入。<br>• 我们提出了成本模型和查询优化n路连接树的方法。<br>• 我们提出了一种 n 元的 n 路处理方法基于最坏情况最优的连接运算符加入算法。<br>• 我们在所有相关层和基于开源 OLAP 系统的基础上实施原型系统包括查询计划生成器和物理连接运算符。<br>• 在大量实验中，我们证明 SPRINTER 的性能明显优于最先进的基于 CPU 的协同处理 OLAP处理系统。</p>\n<p>本文的其余部分组织如下。</p>\n<p>在<strong>第2.2节中</strong>，我们提出了一个在SPRINTER中使用的最坏情况下的最优连接算法。在<strong>第3节中</strong>，我们将描述本文的一个激励例子。</p>\n<p>在<strong>Secti 在4</strong>上，我们提出了n个连接树的查询规划方法。</p>\n<p>在<strong>第5节中</strong>，我们提出了一种自动连接处理方法和优化方法，以提高查询性能。我们建议将成本为m</p>\n<p>第<strong>6节中的odel</strong>。</p>\n<p><strong>第7节</strong>介绍了实验评价的结果。</p>\n<p>最后，我们在<strong>第8节中</strong>讨论相关的工作，</p>\n<p>并在<strong>第9节中</strong>总结本文。</p>\n<h2 id=\"PRELIMINARIES\"><a href=\"#PRELIMINARIES\" class=\"headerlink\" title=\"PRELIMINARIES\"></a><strong>PRELIMINARIES</strong></h2><h3 id=\"Sorting-algorithms\"><a href=\"#Sorting-algorithms\" class=\"headerlink\" title=\"Sorting algorithms\"></a><strong>Sorting algorithms</strong></h3><p>在本节中，我们将在表1中总结SPRINTER中现有的并行排序算法和技术。虽然本文的核心贡献是查询的优化 包含使用n-ary连接操作符的FK-FK连接，当n-ary连接操作符的输入大小非常大时，使用GPU进行排序可以进一步提高查询性能。因此，SPRINTER使用d 不同的排序算法和技术取决于要排序的表的基数，排序列的数量，和GPU内存的容量，在GPU排序。</p>\n<p>表1中基于比较的算法意味着，它们需要在排序的关键值（如快速排序、合并排序、气泡排序）和基于非比较的算法之间进行比较 n，它们不需要这样的比较来进行排序（例如，radix排序）。对于一个给定的N个元组值的输入数组，每个元组值由k个列组成，我们知道的速度的极限 基于比较的算法为O（N.loдN），而基于非比较的算法为O（k.N）。因此，如果k很小，后者通常比前者快。</p>\n<p>**Table 1:**在SPRINTER中使用的并行排序算法和技术。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dspdpglj30f306eaam.jpg\"></p>\n<p>​    大多数GPU排序算法只能对GPU内存中的数据进行排序。然而，要排序的输入阵组可以远远大于OLAP系统中的GPU内存容量。在那个cas e，SPRINTER使用异构排序[15]，有效地利用CPU和GPU。图1显示了输入数组X的异构排序的时间轴，其中我们假设X太大，t o适合GPU内存，因此，我们需要将其分成六个子数组{X1、·、·、X6}。虽然异构排序在CPU上可以在CPU和GPU上使用不同的算法，但我们在GPU上使用radix排序 和在CPU上的合并排序，因为该组合通常显示出最好的性能。异构排序使用多个GPU流，以隐藏主存和GPU模因之间的数据拷贝成本 y尽可能通过重叠三种低级GPU操作，H2D拷贝、排序和D2H拷贝。它在wenev时立即使用CPU对主存中一些已排序的子阵列执行合并排序 他们是可用的。我们假设Xˆ是全局排序的数组，并初始化为一个空数组。图1中的红色框显示了使用CPU的即时合并排序，其中merдe({Xi，Xj})perf 将一组已排序的块{Xi，Xj}合并到Xˆ中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dsi3vfvj30io05kaai.jpg\"></p>\n<p>​        图1：异构排序[15]的时间轴。</p>\n<h3 id=\"2-2最坏情况下的最优连接算法\"><a href=\"#2-2最坏情况下的最优连接算法\" class=\"headerlink\" title=\"2.2最坏情况下的最优连接算法\"></a>2.2最坏情况下的最优连接算法</h3><p>​    在本节中，我们将描述SPRINTER用于处理n-ary连接运算符的最坏情况下的最优连接算法。最坏情况下的最优连接算法[13,44]主要是支撑的 通过避免生成中间结果，用以有效地处理图形模式查询（例如，三角形查询）。一些算法[1,31,44]需要对输入关系和存储进行预处理 ng预处理作为数据结构的结果，如B+-tree，而其他[13,47]只是使用二进制搜索排序关系并执行连接。我们使用th e后一种算法，特别是部落连接(TJ)[13]。</p>\n<p>​    图2说明了三角形查询Q（x、y、z）：-R（x、y）、S、（y、z）、T（x、z）的处理，其中R、S和T为边缘关系。最坏情况下的最优连接算法通常使用一个修复程序 ed对所有连接变量的全局排序。我们假设图2中的全局变量的顺序是x≺和≺z。TJ算法按(≺，y)排序，按x≺排序，按(y，z)排序，按y≺排序 z，并根据顺序x≺z排序(x，z)，进行预处理。然后，TJ首先扫描第一个连接变量x(即R和T)上的所有关系，然后作为合并连接进行，直到找到a 该变量的匹配值，例如，x=1。然后，它简单地递归地计算残余的queryQ‘(y，z)=Rx=1(y)、S(y，z)、Tx=1(z)，其中残余的关系Rx=1和Tx=1实际上是子arr 通过调整R和T的起始和端点获得R和T的方法和x=1。在递归调用期间，它将扫描下一个连接变量y上的所有关系，直到找到匹配的值y= 3.然后，它通过扫描z来递归地再次进行，最后输出（1,3,4）。</p>\n<p>​    当在数组或子数组中寻找一个特定的值时(例如，在S中寻找y=3)时，TJ使用二进制搜索，因此，单个搜索的成本是O(loдN)。然而，TJ的主要成本是补屑素 g输入关系的成本[13]。如果一个查询有L个连接变量，则可能的全局变量顺序的数量为L！。虽然TJ在任何变量排序下是最坏情况最优的，但这种“最坏情况”p 实际上，由于每个变量顺序的搜索成本不同，可能远非最优，因此，TJ估计每个可能订单的连接处理成本，并选择最好的订单。</p>\n<p>![image-20210731194600082](/Users/wuzhenren/Library/Application Support/typora-user-images/image-20210731194600082.png)</p>\n<p>​                                                图2：部落连接[13]的示例。</p>\n<h2 id=\"3-动机\"><a href=\"#3-动机\" class=\"headerlink\" title=\"3 动机\"></a><strong>3 动机</strong></h2><p>​    在本节中，我们将介绍一个激励性的查询，它显示了现有的OLAP查询处理系统的缺点。该查询是TPC-DS基准数据库[30]上的一个查询，广泛用于t 测试OLAP系统[18]的查询性能。虽然该查询包含包括聚合在内的各种操作，但我们将在本节中重点关注连接操作。图3显示了的连接图 该查询包含蓝色矩形的三个事实表{SS、SR、CS}和绿色矩形的三维表{D、I、C}。为了简单起见，我们只使用关系名称的缩写 在本文中。在图中，我们描述了连接图的每条边上的连接条件。蓝线有2个FK-FK连接操作，绿线有5个PK-FK连接操作。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ds6012fj30j806iwey.jpg\"></p>\n<p>​                                            图3：激励性查询的连接图。</p>\n<p>​    图4显示了由Syssem-X、OmniSci[33]和我们的SPRINTER生成的查询计划及其性能。系统-x是一份功能齐全的最先进的商业化备忘录 ry数据库系统，支持索引驱动的查询执行和查询优化技术，如开花过滤器和自适应连接。它支持许多查询处理技术，如 索引驱动的查询执行、bloom过滤器和自适应连接。在图4(a)中，它为查询计划生成一个左深连接树，并以操作员一次操作的方式执行该计划。C1、C2和C3 是相同的关系，即关系C，但在查询处理过程中作为不同的关系来处理，这在OLAP处理系统中很常见。除了系统-x之外，还有许多系统包括 DingMonetDB[9]、CoGaDB[10]、Kinetica[21]和快速步骤[34]生成与图4(a)中几乎相同的查询计划，并以一次操作符的方式执行它。</p>\n<p>​    图4(a)中的计划在最后一个连接之前生成22.3亿(B)中间元组作为左操作数，并以CS的1.44亿(M)元组作为右操作数。然后，它构建了散列t 能够探测144M元组，并探测2.23B中间元组。因为连接操作是FK-FK连接，并且在哈希表中有许多重复的键值，所以num 在探测连接过程中，哈希表中的关键值被访问，我们称之为探测成本，这是巨大的，特别是160.9B倍。</p>\n<p>​    OmniSci[33]是一个开源的协同处理数据库系统，其中协同处理意味着同时利用cpu和gpu进行查询处理。在图4(b)中，它生成了一个左深jo的查询计划 如图4(a)所示，但以非阻塞和流水线的方式执行计划，它不会生成和存储供连接的中间结果。详细地说，它评估一系列所有连接操作 通过对关系SS的SR、CS、I、D、D、C1、C2、C3}顺序构建的7个散列表，依次探测连接树中的错误。在中，SS和SR之间的第一个连接 图4(b)对29M元组SR的每个SS元组进行探针，探针成本为4.1B。然后，第二个连接探测每个元组通过了针对散列的第一个连接 1.44M元组的CS表，探针成本为20.7 B. 我们可以类似地计算每个连接的探针成本，总探针成本为25.8 B.</p>\n<p>​    短跑器是我们提出的方法跨所有相关层和模块无缝集成到OmniSci中的原型系统。我们选择OmniSci作为SPRINTER的基础系统，因为它是o 没有最先进的开源现代数据库系统。虽然我们提出SPRINTER使用OmniSci作为基础系统，但SPRINTER原则上可以使用任何数据库系统作为基础系统。在Fi中 Gure4(c)，SPRINTER生成一个查询计划，由多个白色的二进制连接操作符和一个红色的n-ary连接运算符组成。它分别执行三个连接子树，即S1={SS、C1、D， I}、S2={SR、C2}和S3={CS、C3}，以像OmniSci这样的流水线方式，然后，以一次操作符的方式执行无连接操作符，这将在第5节中描述。当我们计算时 S1、S2、S3的探针总成本仅为758M。此外，当我们计算在三个连接子树的结果中处理n-ary连接的总成本时，它变为312M.O 总之，SPRINTER的总处理成本约为1.07B，比其他两个系统的总处理成本要小得多。</p>\n<p>​    图4(d)显示了上述三个系统对TPC-DSSF=100数据库的查询性能。性能结果表明，OmniSci通过消除la，提高了系统x的性能 通过管道得到Rge中间结果，SPRINTER通过将单个大连接树分割成多个较小的连接子树并执行n个连接来提高OmniSci的性能 他是连接子树的结果。我们将解释一个比第6节中的图更精确的成本模型。</p>\n<h2 id=\"4查询规划方法\"><a href=\"#4查询规划方法\" class=\"headerlink\" title=\"4查询规划方法\"></a>4查询规划方法</h2><p>​    在本节中，我们首先将在第4.1节中介绍用于生成包含单个n-ary连接操作符的查询计划的查询规划方法。然后，我们将该方法推广到更复杂的查询中 这样它就可以生成一个在4.2节中包含多个n-ary连接的操作符。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0drbd5cpj30jp0h3760.jpg\"></p>\n<p>​                                                图4：针对激励性查询的查询计划。</p>\n<h3 id=\"4-1单个n个连接运算符的查询\"><a href=\"#4-1单个n个连接运算符的查询\" class=\"headerlink\" title=\"4.1单个n个连接运算符的查询\"></a>4.1单个n个连接运算符的查询</h3><p>​    对于查询规划，我们考虑一个来自给定查询Q的连接图，它在定义4.1中定义。</p>\n<p>定义4.1。（连接图）查询Q的连接图G=(V、E、f(v∈V)、д(e∈E)、h(e∈E))是一个无向多重图。顶点v∈V表示Q中连接的关系，边=(X，Y) ∈E是两个端表X和Y之间的连接操作，特别是X[i]和Y[j]之间的连接操作，其中i∈X和j∈Y。有三个标记功能f(v)、д(e)和h(e)。函数f(v)返回 关系v的类型，即事实或维数，函数д(e）连接操作的类型，即PK-FK或FK-FK-FK，以及函数h(e)等连接谓词e，即h(e)=(X[i]、Y[j] ).</p>\n<p>​    在本节中，我们考虑一个连接图G只包含通过FK-FK连接操作边缘连接的顶点子图的情况。我们将这样一个子图表示为核心子图 并在定义4.2中定义它。</p>\n<p>​    定义4.2。（核心子图）连接图G的核心子图，即核心=(Vc，Ec)⊆G，是其中任何两个顶点X和Ys.t的连接分量。X∈Vc和Y∈Vc通过as连接 Ex，y EC S.T。 D（e∈ex，y）=fk-fk，f(x)=f act and f(y)=f act。</p>\n<p>​    在图3中，一个子图{SS，SR，CS}是一个核心子图，因为所有的顶点都是事实表，一对顶点SSSSR通过FK-FK边连接，另一对顶点SRRCS也是 通过FK-FK边缘连接。子图{SS、SR、CS}是图3中连接图中通过FKFK边连接的最大子图。如果一对顶点SSSSR有两个边{e1，e2}s.t.，д(e1)= FKKFKandд(e2)=PKKFK，只有e1属于核心子图{SS，SR，CS}。</p>\n<p>​    在大多数情况下，系统可以基于元数据和统计数据找到一个核心子图，如引用约束、表基数和列的不同值的数量。以防一个系统 m对它们的了解有限，查找它们的技术，包括自动外键检测[12,48]，将有助于找到一个核心子图。</p>\n<p>​    如果一个连接图G只有一个核心子图核心，那么我们可以将G分解为核心子图核心和一组彼此在边不相交的非核心子图。在这里， 核心或非核心的任意两个子图都可以在两个子图之间有一个或多个公共顶点。图5显示了图3中连接图的一种可能的分解，其中有 一个单核子图核心={e4、e5}和三个非核子图G1={e3、e6、e7}、G2={e2}和G3={e1}。一般来说，一个连接图有很多可能的分解。我们表示se 可能的分解的t。例如，我们可以将连接图分解为单个核子图核心={e4、e5}和单个非核子图G1={e1、e2、e3、e6、e7}。然后，我们就可以使用r 将上述两种分解方法分别表示为D1={核心、G1、G2、G3}和D2={core、G1}。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dqng0raj30ik06d0t4.jpg\"></p>\n<p>​                                            图5：激励性查询的分解。</p>\n<p>​    算法1提供了仅包含单个核心子图的查询的基本查询规划方法。这种方法背后的直觉是使一个核心子图成为一个查询计划和mak的根节点 用非核心子图表示查询计划中的根节点的子节点。它从连接图G（行2）中找到可能的分解{Di}，从每个分解Di中生成一个查询计划Pi 3-9)，然后选择其中成本最低的最佳计划P∗（第11行）。我们将在第6节中介绍一个计划的成本模型。当从非核心子图制作连接子树Sj时 ，通常有很多可能的连接子树。然而，我们只考虑为一个非核心子图生成一个左深二进制连接子树，这可以显著减少 查询计划的搜索空间。将核心子图作为查询计划的根也是减少查询计划搜索空间的启发式方法。启发式方法背后的直觉是 通过在查询计划的最后一步处理事实表上的FK-FK连接，从而减少从非核心子图中的连接操作生成的中间结果量。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dx85c34j30k60fl0tz.jpg\"></p>\n<p>​    图6显示了由上述两个分解的D1={core、G1、G2、G3}和D2={core、G1}生成的两个可能的查询计划树。图6中的每个二进制连接运算符都对应于一条绿色的边 在图5中。相比之下，图6中的每个根n-连接运算符对应于图5中的一组蓝色边{e4，e5}。我们注意到，核心或非核心子图之间共享的关系出现了mu 查询计划中的重复次。例如，C在图6(a)中出现了三次，因为它在图5中的三个子图{G1、G2、G3}之间共享。当比较图6中的两个查询计划时，我们可以说 计划P1通常成本低于计划P2，因为P1再扫描一个维度表C两次，而P2再扫描两个事实SR和CS一次。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dxpwk50j30hn093dgo.jpg\"></p>\n<p>图6：针对激励性查询的查询计划。</p>\n<h3 id=\"4-2多个n个连接运算符的查询\"><a href=\"#4-2多个n个连接运算符的查询\" class=\"headerlink\" title=\"4.2多个n个连接运算符的查询\"></a>4.2多个n个连接运算符的查询</h3><p>​    在本节中，我们将解释当一个查询中有多个核心子图时的查询规划方法。我们将核心子图的数量表示为Ncore。针对这种qu的一种朴素的查询规划方法 ery是将连接图中的一个特定的核心视为连接图中的唯一的核心，并将第4.1节中解释的方法应用于连接图。一种更好的规划方法是推广方法 将算法1递归地应用于所有非核心子图。对于广义版本，我们只需要进行修改算法1中的第6行。详细地说，我们称为算法1中第6行的以下算法2，通过考虑Gj为算法2的输入，并考虑算法2的输出P∗为Sj。在奥尔戈里斯市 m2，第1行为Gj生成一个传统的查询计划Pold（例如，左深连接树），这是由基础系统的查询规划方法(例如，SPRINTER的OmniSci)完成的。IfGj没有核心的s 然后，算法2返回常规的查询计划作为输出。如果Gj有一个或多个核心子图，则第3行将生成一个查询计划Pnew，其中有一个n-ary连接运算符作为Gj，w的根节点 hich是由算法1完成的。然后，第4行估计Pold成本和PNew成本，这将在第6节中详细解释。在比较了两种成本后，只有计划的成本较低 作为输出返回。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dz09duyj30jb0c6my7.jpg\"></p>\n<h3 id=\"4-3搜索空间\"><a href=\"#4-3搜索空间\" class=\"headerlink\" title=\"4.3搜索空间\"></a>4.3搜索空间</h3><p>​    我们可以用我们的方法计算一个查询的可能查询计划的数量。一般来说，在连接图G中有Ncore(G)核心子图，分解的数量取决于哪个c 矿石子图被选为一个根节点。我们将将核心子图Ci作为根节点时的分解数表示为Ndcmp(Ci)。如果算法1中的第6行总是使用传统的计划 对于一个子图，每个分解将生成单个查询计划。因此，我们可以计算具有由一个朴素m生成的单个n-ary连接运算符（作为一个根节点）的可能计划的数量 如E式。1.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0dzmeix9j30gp03ejra.jpg\"></p>\n<p>​    如果算法1中的第6行使用算法2，则每个分解都可以生成多个查询计划。对于一个特定的分解Dj(1≤j≤Ndcmp(Ci))，我们假设存在Nsubд(Dj)非核心子网格 hs。例如，在图6中，Nsubд(D1)=3和Nsubд(D2)=1。对于每个子图Gk，都存在Nrecur(Gk)查询计划。因此，我们可以计算出该基因产生的可能计划的数量 已排序方法，最多可以有Ncore(G)n-ary连接运算符，如Eq。2.</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e0e5j73j30ic03bwej.jpg\"></p>\n<p>​    在图6(a)中，可以生成3！=6查询计划取决于连接子树的顺序。在式式中。2，我们不考虑连接子树之间的顺序，因为总处理时间 连接子树是相同的，不管顺序如何。我们将在第5节中详细解释它。因此，我们可以在算法1中第9行连接子树。</p>\n<h2 id=\"5n-ARY-JOIN处理方法\"><a href=\"#5n-ARY-JOIN处理方法\" class=\"headerlink\" title=\"5n-ARY JOIN处理方法\"></a>5n-ARY JOIN处理方法</h2><p>​    在本节中，我们将介绍SPRINTER的n连接处理方法。我们将执行一种处理具有一组子连接子树的n个连接运算符的朴素方法 g请执行以下六个步骤。</p>\n<ul>\n<li><p>步骤1：逐个评估{S1、·、·、Sn}。</p>\n</li>\n<li><p>步骤2：计算{S1、·、··、Sn}结果的必要统计数据。</p>\n</li>\n<li><p>步骤3：估计连接变量的每个全局顺序的成本。 </p>\n</li>\n<li><p>步骤4：选择最佳的全局变量顺序。</p>\n</li>\n<li><p>步骤5：按全局顺序对{S1、·、·、Sn}的结果进行排序。</p>\n</li>\n<li><p>第6步：在n个已排序的关系上合并连接。</p>\n<p>对于一个n-ary连接操作符，子节点的可能顺序数变为n！在原则上。我们假设n个连接运算符的子级从左到右计算。对于n 在aive方法中，无论处理子节点的顺序如何，处理n-ary连接运算符的所用时间都变得相同。图7(a)显示了一个用于评估三个连接子的示例时间线 根据上述六个步骤。如果n-ary连接运算子具有关系，而不是将连接子树作为其子树，例如，图6(b)中的SR2和二硫化碳，我们考虑rela t值分别为S2和S3。我们将将Si计算为Teval(Si)的经过时间，以及对其结果进行排序的经过时间表示为Tsort(Si)。我们假设Teval(Si)=Tsort(Si)(1≤i≤3) 为了简单起见，Teval(Si)&lt;Teval(Sj)(i&lt;j)。步骤2-4在图7(a)中的时间t1时完成，它确定了连接列之间的一定全局应用TJ算法的顺序。步骤5 根据全局顺序对每个结果进行rts，步骤6在时间t2时使用第2节2.2中所述的TJ算法完成。我们可以知道，在图中，总经过的时间不会改变 即使Ure7(a)，即使{S1、S2、S3}的评估顺序发生了改变，或者即使是Teval(Si)&gt;TSort(Si)或Teval(Si)&lt;Tsort(Si)。</p>\n</li>\n</ul>\n<p>​    在朴素方法中，Teval(Si)和Tsort(Si)由于存在一种同步障碍而不能重叠</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e2iux1lj30ix0fjdgo.jpg\"></p>\n<p>​                    图7：图6(a)中三个连接子树{S1、S2、S3}的评估时间线。</p>\n<p>​    时间t1，因此，即使我们利用GPU进行排序步骤，也很难大大减少总运行的时间。因此，我们使用一种改进的方法来处理一个n-ary连接算子，它由o f请执行以下四个步骤。</p>\n<ul>\n<li>步骤1：估计连接变量的每个全局顺序的成本。</li>\n<li>步骤2：选择最佳的全局变量顺序。</li>\n<li>步骤3：对结果进行重叠排序。</li>\n<li>步骤 4: 在n个已排序的关系上合并连接。</li>\n</ul>\n<p>​    图7(b)显示了修改后的方法的时间线。在步骤1-2中，它首先确定全局变量的顺序，而不计算{S1、···、Sn}的结果的统计数据 t1)。我们将在第5.1节中详细解释如何确定SPRINTER的整体顺序。然后，在步骤3中，它重叠了使用CPU评估Si，并使用GPU(i，j)对Sj的结果进行排序。在t中 他的方法是，无论{S1、S2、S3}的处理顺序如何，图7(b)中的总经过的时间仍然没有改变，而且，无论是Teval(Si)&gt;Tsort(Si)，还是Teval，都没有改变 (Si)&lt;Tsort(Si)。</p>\n<p>​    我们可以进一步减少如图7(b)所示的总运行时间。SPRINTER可以利用流水线技术来评估每个子连接子树，因为它的基础系统，即OmniSci，是一个 基于流水线技术。由于SPRINTER可以同时使用CPU和GPU，并且同时使用流水线技术，评估Si和排序Sj的结果可以重叠w 即使我=j。图7(c)显示了同时使用CPU和GPU并启用流水线技术时的时间线。我们假设S1的中间结果的大小， S2和S3分别是在GPU中一次可以处理的数据大小的1倍、2倍和3倍。图中红色虚线表示主机（即主存）到设备（即GPU内存）的拷贝，记为H2D 复制。 对于 S2 和 S3，部分中间结果是通过流水线技术收集和块复制到 GPU 内存进行排序。</p>\n<pre><code> 即使我们同时使用CPU和GPU，也使用流水线技术，总运行时间不会根据子级的处理顺序而改变。我们考虑Teval(Si)+光标 t(Si)作为儿童Si的成本。图7(c)显示了评估低成本子节点优先(LCF)的策略，而图7(d)显示了评估高成本子节点优先（HCF的策略 )。我们可以看到这两种策略都同时完成了。无论Teval(Si)&gt;Tsort(Si)还是Teval(Si)&lt;TSort(Si)，这种趋势都保持不变。因此，我们使用任何固定的策略 y（例如HCF）用于对n连接运算子的子级排序。\n</code></pre>\n<h3 id=\"5-1全球订单的确定\"><a href=\"#5-1全球订单的确定\" class=\"headerlink\" title=\"5.1全球订单的确定\"></a>5.1全球订单的确定</h3><p>​    一般来说，在合理短的时间内精确计算每个全局连接变量顺序的成本是一个非常具有挑战性的问题。现有的最坏情况最优连接算法也是我们的 e启发式算法实际上是为了确定了图模式查询的全局顺序[1,13,44]。本文还提出了一种启发式算法来确定一个相当好的全局算法 对于OLAP查询的可变顺序快速，我们将在未来的工作中进一步改进。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0e86b0wmj30ir0d4q48.jpg\"></p>\n<p>​    算法3展示了我们的启发式算法。给定一个核心子图，它找到所有的连接变量，并为每个连接变量准备一个三重态w，|Ew|，Cw，其中w是一个连接变量，|Ew|，n 连接条件的对数，即具有w的关系的基数之和。例如，图8显示了TPC-DSQ17的一个核心子图，它有三个连接变量，项目、cust和票据。 对于项目，|Estem|=2，和Citem=||CS||+||SR||+||SS||。然后，该算法按(|Ew|，Cw)的降序对三联体列表进行排序。在这里，如果一个连接变量 w1 可能与另一个连接变量 w2 在 (|Ew |,Cw ) 方面联系在一起，则其中一个可以在全局变量顺序中排在另一个之前。 例如，item ≺ cust ≺ ticket 和cust ≺ item ≺ ticket 都是允许的。 直观地，算法选择具有更多连接条件和可能有更多元组作为更高优先级处理的连接变量，以减少对排序关系进行二分搜索的总量。 我们将在第 7.3 节中展示这种方法的影响。</p>\n<p><img src=\"/Users/wuzhenren/myblog/source/_posts/%E5%85%83%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86.assets/image-20210731201800921.png\" alt=\"image-20210731201800921\"></p>\n<p>​                                            图8：TPC-DSQ17的核心子图。</p>\n<h3 id=\"5-2排序策略\"><a href=\"#5-2排序策略\" class=\"headerlink\" title=\"5.2排序策略\"></a>5.2排序策略</h3><p>​    在本节中，我们将介绍我们为每个子节点连接子树的结果选择特定排序算法的策略。图9显示了考虑到以下三个因素的策略：avai GPU的不能力，要排序的数据的大小和排序列的数量。首先，如果GPU不可用，SPRINTER使用CPU排序，特别是一个基于非比较的算法，如果num 排序列的b只是一个，但在其他方面是基于比较的算法，如2.1节所述。其次，如果要排序的数据可以适应GPU内存，SPRINTER使用一个非比较基础 d或基于比较的GPU排序算法，具体取决于排序列的数量。第三，如果要排序的数据不能适合GPU内存，我们需要仔细选择一个排序算法 GPU排序缺乏良好实现的问题。据我们所知，GPU[7]的一个基于比较的算法的实现速度仅比CPU[37]的实现算法略快。 </p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0echpj2vj30gl08mq3s.jpg\"></p>\n<p>​                                                图9：排序算法的选择策略。</p>\n<p>​    如果要排序的关系有多个排序列，并且大于GPU内存，典型的方法将将关系划分为子数组，使用基于比较的算法对每个子数列进行排序 m，并使用CPU合并子阵列。</p>\n<p>​    但是，合并已排序子数组的成本可能非常大，因为随着排序列的索引增加（例如，第 3、第 4 位），每个已排序子数组中的列值都是重复的，并且没有按照特定排序列进行排序。 排序使用GPU和使用CPU合并实际上比排序慢在很多情况下使用 CPU，因此，我们使用 CPU 排序红线框中的情况，如果基于比较的 GPU 排序算法的性能为后来改进。 如果一个关系只有一个排序列，我们只在 2.1 节中使用异构排序，因为那里是基于非比较的非常快速的实现GPU算法，合并子数组的代价不是这么大。 我们将展示每个案例的实验评估在第 7 节的图 9 中。</p>\n<p>​    由于SPRINTER像其他现代OLAP系统一样使用柱列布局，它为每个Si的连接列阵组和1≤i≤)维护元组ID向量(tidVic)，其中使用前者 用于排序每个Si和连接{Si}，后者用于元组重建。在单个GPU中可以一次排序的最大元组数取决于排序算法的实现 使用ithm。例如，当我们对Si具有一个4字节连接列和4字节元组ID的NVIDIAGTX1080ti的结果进行排序时，我们可以使用大约14亿和7亿元组进行排序 分别为就地和不到位的分类。</p>\n<h3 id=\"5-3合并加入排序关系\"><a href=\"#5-3合并加入排序关系\" class=\"headerlink\" title=\"5.3合并加入排序关系\"></a>5.3合并加入排序关系</h3><p>​    对于具有连接子树的任意连接操作子{S1、···、Sn}，由于我们有n个排序结果{Sˆ1、·、·、Sˆn}，通过对每个连接子树的结果进行排序，我们可以很容易地执行合并连接 gTJ算法。图10(a)显示了图8中核心子图的三元连接运算符的合并连接示例。为了简单起见，我们将列项、cust和票单表示为i、c和 t，分别。我们假设全局顺序是≺≺。SPRINTER扫描第一个连接变量i上的{CSˆ，SRˆ，SSˆ}，并假设当前的指针是i=2（蓝色箭头）。然后，它执行一个电阻 ual查询Q‘(c、t)=CSˆi=2(c)、SRˆi=2(c、t)、SSˆi=2(c、t)递归地在第二个连接变量c上，可以找到至少一个匹配，即c=4（绿色箭头）。因此，它执行一个更窄的resi 双queryQ‘’(t)=CSˆi=2、c=4（·）、SRˆi=2、c=4(t)、SSˆi=2、c=4(t)递归。残差查询Q‘’(t)找到两个匹配的元组{（2,4,1)，(2,4,1）}。同样地，它还可以找到另外四个匹配的t 通过在CSˆ中移动绿色指针，（2,4,1）的组。这样，我们就可以处理一个具有许多FK-FK连接的核心子图，而不产生大量的中间结果。</p>\n<p>​    人们可以考虑另一种合并连接方法，它只通过i对CS、SR和SS进行排序，从而降低了排序成本。然而，它可能会显著增加合并连接的成本，从而降低整体成本 性能。图 10(b) 显示了这样一个示例，其中 c 列中的值未排序，我们假设 CS 和 SR 与图 10(a) 相同。 当执行残差查询 Q′(c,t) = CSˆ i=2(c), SRˆ i=2(c,t), SSˆ i=2(c,t)时，我们必须扫描残差关系 SSˆ i =2 在 c 列上按顺序进行，而不是进行二分查找。 因此，根据所有连接变量对核心子图中的所有关系进行排序很重要。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eh3ij05j30jc09s0tm.jpg\"></p>\n<p>​                                    图10：图8中的核心子图的合并连接示例。</p>\n<p>​                                        表2：符号汇总表。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ehyjzybj30ik09rabd.jpg\"></p>\n<h2 id=\"6个关于查询优化的成本模型\"><a href=\"#6个关于查询优化的成本模型\" class=\"headerlink\" title=\"6个关于查询优化的成本模型\"></a>6个关于查询优化的成本模型</h2><p>​    使用n-ary连接运算符的查询处理可能并不总是比仅使用二进制连接运算符的传统查询处理方法获得更好的性能。因此，我们使SPRINTER成为一名将军 e只有在成本模型有利时才包含n个连接算符的查询计划。给定一个查询Q，算法2考虑了原始计划Pold和新计划Pnew。因此，我们需要 建立成本模型成本(PNew)和成本(Pold)，以确定成本(PNew)&lt;成本(Pold)。特别地，我们建立了关于基本系统的成本的成本模型(Pold) （即，OmniSci）。我们将在查询处理过程中访问的元组（或散希表中的元素）的数量作为成本的度量。表2总结了本节中使用的符号。</p>\n<h3 id=\"6-1基础系统的成本模型\"><a href=\"#6-1基础系统的成本模型\" class=\"headerlink\" title=\"6.1基础系统的成本模型\"></a>6.1基础系统的成本模型</h3><p>​    我们认为查询计划 Pold 由 M M 1 个二元连接运算符组成，用于 M 个关系。 每个输入关系 Ri 可能有自己的一组过滤谓词 pi，我们在将谓词应用于关系 (1 ≤ i ≤ M) 后考虑结果关系 Fi。我们考虑PK-FK连接或FK-FK连接的每个二进制连接运算符都使用主内存哈希连接算法进行计算，该算法不仅在OmniSci[33]中很常见，而且在其他内存查询中也很常见 处理系统[5,8,19,28,50]。我们假设查询处理探测最左关系的每个元组，即F1与由其余关系{Fi|2≤构建的散列表集相比 i≤M}以流水线的方式。情商。3显示了Pold的成本函数，其中构建(Fi)是构建哈希表的成本函数(Eq。4)和探测(F1)探测元组的成本函数 F1（Eq。5).</p>\n<p>​    <img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0em547udj30gx06bmxd.jpg\"></p>\n<p>​    在式式中。4、κ是一个常数值，表示在构建相应哈希表的关系Fi上的完整扫描数。我们使用κ=2，因为我们的基础系统使用了高级处理的通用技术 连接键[19]的直方图，这需要对关系进行两次完整扫描。值取决于所使用的基本系统。在式式中。5，我们认为术语Ifj|1当j&gt;i时变成1。用于 例如，由于术语Iij=3(即|=1=1，|1探测|2的成本成为||F1||×dup2。然而，当j≤i(例如，Ii=4j=3f2)时，这个术语就会变成本身。没有基因的丢失 相反，我们可以假设F1的每个元组与F2散希表中的dup2元素进行比较，而不管散希表的类型如何（例如，开放寻址、单独的链接）。探测a 针对F2，我们可以假设总共有一个||F1||·F2元组存活下来，并对F3进行探测。也就是说，将每个||F1||·f2元组与f3散列表中的dup3元素进行了平均比较。 对F3进行探测后，共有||F1|的|·f2·F3元组存活，每个元组与F4散希表中的dup4元素进行比较。这样，我们就可以聚合e的数量 在管道中的散列表中访问的clives。5.</p>\n<h3 id=\"6-2SPRINTER的成本模型\"><a href=\"#6-2SPRINTER的成本模型\" class=\"headerlink\" title=\"6.2SPRINTER的成本模型\"></a>6.2SPRINTER的成本模型</h3><p>​    一般来说，查询计划Pnew由M个关系的n-ary和二进制连接运算符组成。我们假设Pnew中至少有一个n个连接运算符，否则不需要生成Pnew。在p 根据第4节中的查询规划方法，Pnew有一个n-ary连接运算符作为根。我们将n-ary连接算子表示为O，并假设O有连接子树作为其子树 {Si|1≤i≤n}。我们注意到，如果一个连接子树Si也有一个或多个n-ary连接运算符，那么由于第4节中的查询规划方法，它也有该运算子作为根。</p>\n<p>​    因此，我们可以递归地定义 Pnew 的成本函数，如Eq.6，其中cost（Si）变成了等式。 3 如果 Si 没有 n 元连接运算符并成为Eq.6 否则。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0eqnrgsqj30f902egli.jpg\"></p>\n<p>​    Eq.7表示n-ary连接处理的成本，其中包括n个连接子树结果的排序成本和使用TJ算法的连接成本。SPRINTER使用不同的排序算法 算法根据排序输入，即排序列的数量和表的大小，我们省略了这些算法的成本分析，因为它们在精简中已经众所周知了特性。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0es2hnx8j30f302r747.jpg\"></p>\n<p>​    如果w1≺w2≺···≺wL被确定为n个连接操作器O的全局变量顺序，Eq。8显示了合并n个排序关系{Sˆi|1≤i≤n}的TJ算法的成本。我们表示的是 与特定连接变量a(w)相关的关系数。例如，图8中的u（项目）=2、andu（票）=1。我们可以考虑在所有关系之间具有最小基数的关系 与连接变量w相关的（1)、(1）、S(u(w))，其基数表示为Nwmin。同样，我们可以考虑w具有最大基数的关系，并表示其基数 作为Nwmax。然后，单个连接变量w的TJ算法的代价变成了Eq。9，这在[44]中也进行了总结。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0esnu7v4j30fq02sglh.jpg\"></p>\n<p> Eq. 9,术语(1+loд（<img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ewem954j306901cmwz.jpg\">)表示对下一个键值的二进制搜索的摊销成本。由于TJ根据全局变量的顺序连续搜索关系，因此，总数 TJ的成本变成了Eq.8.</p>\n<h2 id=\"7-实验评价\"><a href=\"#7-实验评价\" class=\"headerlink\" title=\"7 实验评价\"></a>7 实验评价</h2><p>​    在本节中，我们将给出两类实验结果。首先，我们将短跑器与现有的OLAP查询处理系统所经过的复杂OLAP查询时间i进行比较 nTPC-DS基准。其次，我们展示了SPRINTER的特点。详细地，我们通过实证验证了第5节中描述的排序算法的选择策略，该策略提出了成本模型 以及排序算法的性能。</p>\n<h3 id=\"7-1-实验设置\"><a href=\"#7-1-实验设置\" class=\"headerlink\" title=\"7.1 实验设置\"></a>7.1 实验设置</h3><p>​    查询和数据集：在 TPC-DS 基准测试中，共有 26 个 TPC-DS 查询至少有一个 FK-FK 连接 [30]。在这些查询中，我们发现只有 11 个查询可以在 比较所有 OLAP 系统，并且至少有一个存在解析错误的 OLAP 系统不支持剩余的查询。 因此，我们使用 11 个查询来比较系统。 我们注意到，对于没有 FK-FK 连接的查询（例如，99 - 26 = 73 个 TPC-DS 查询），SPRINTER 显示出与基本系统（例如 OmniSci）相同的性能，因为 SPRINTER 使用相同的查询计划 此类查询的基本系统。</p>\n<p>​    为了评估SPRINTER的特点，我们通常使用合成查询，这些查询是通过修改第3节中的激励查询而生成的，并在TPC-DS数据库上评估它们。对于数据集 ，我们使用了从SF=100 (100 GB)到SF=400 (400 GB)的TPC-DS数据库，这是以往研究中广泛使用的规模。</p>\n<p>​    环境：我们在一台机器上进行所有实验，配备了两台英特尔Xeonen10核cpu，512GB主存和一个11GB的NVIDIAGTX1080TiGPU。操作数 使用的名词名词系统是CentOS7.5。</p>\n<p>系统比较：与短跑系统相比，OLAP系统分为两种类型：基于cpu的系统(如Syssem-x)和协同处理系统(如OmniSci)。所有的系统都是基于 柱状存储布局。我们注意到，每个系统都被设置为尽可能多地同时使用主存和GPU设备内存（仅用于共同处理系统）。表3总结了其中的功能 在实验中使用的系统。</p>\n<p>表3：<strong>系统比较汇总</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f3q6554j30g50bfgmg.jpg\"></p>\n<p>​    对于基于cpu的系统，System-Y是最先进的商业化的OLAP数据库系统之一，支持索引驱动的查询执行和查询优化技术，如bloomf 过滤器的散列连接和基于成本的查询规划器，这类似于System-X。但是，它生成了一个二进制灌木树的查询计划，这是与System-x的主要区别之一。此外，Sys tem-Y以流水线的方式处理查询计划，并支持查询执行的协变性。我们使用最新版本的系统x和系统y进行实验。</p>\n<p>​    我们也比较SPRINTER 与著名的矢量化引擎 Mon etDB [9] (v11.31.13) 和 Actian Vector [51] (v5.1)，其中前者使用一次操作员模型，但后者使用<br>用于查询评估的流水线模型。 对于协处理System-Z 是最先进的商业化系统<br>利用 GPU 的 OLAP 数据库系统，我们使用其最新的发布用于实验。 我们还使用两个开源协同处理系统进行评估，OmniSci [33] (v4.5.0) 和CoGaDB [10] (v0.4.2)。 我们表示 SPRINTER 的版本仅使用 CPU 作为 SPRINTER(C) 和 SPRINTER 之一使用 CPU 和 GPU 作为 SPRINTER(G)。 由于SPRINTER在一次操作符中执行 n 元连接操作符尽管它以流水线方式执行每个连接子树以这种方式，我们将其查询评估模型描述为一次操作符和流水线的组合。</p>\n<h3 id=\"7-2-性能比较\"><a href=\"#7-2-性能比较\" class=\"headerlink\" title=\"7.2 性能比较\"></a>7.2 性能比较</h3><p>​    图11显示了SPRINTER(C)和SPRINTER(G)与第7.1节中描述的现有OLAP系统的比较结果。在图中，操作。m。是指由于故障而导致的查询评估失败 内存。T.O.表示超时（超过1800秒）。M.E.是指由于分割故障和分配不良等主存相关错误而导致的查询评估失败。y轴是对数比例尺 e图。我们使用一个SF=100的数据集，因为一个更大的数据集会产生大量的o.o.o.m。在许多系统中。对于每个系统和每个查询，我们运行五次查询以预热系统并报告bes 未经过时间。</p>\n<p>​    与基于cPU的系统的比较：图11(a)显示了与基于cPU的系统的比较结果。我们首先注意到，只有SPRINTER成功地执行了所有11个查询，但其他系统f 在至少一个查询中出错。从大量的中间结果或电信号从大量的探针成本，在第3节中解释。此外，SPRINTER(C)和SPRINTER(G)均超过 错误格式比较测试的大多数查询的所有系统，这是由于它们不同的查询计划和不同的连接处理。对于所有系统组合通常执行的查询 即Q37、Q64和Q95，SPRINTER在系统中表现最好。特别是，对于Q64，SPRINTER(G)与Syssem-Y、System-X、MonetDB和Actia相比，提高了性能 n向量分别为6.6、7.4、20.1和5.1倍。</p>\n<p>SPRINTER(C)和SPRINTER(G)之间的性能差距并不大，因为数据大小相对较小(SF=100)。我们注意到，当前的SPRINTER没有使用先进的查询优化技术 系统x和系统y使用的niques，因为它的基础系统，OmniSci，还不支持它们。因此，将优化技术应用于O上，可以进一步提高SPRINTER的性能 mniSci或SPRINTER。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0f956c1nj30w50jltcj.jpg\"></p>\n<p>​                        图11：使用TPC-DS基准查询(SF=100)的性能比较。</p>\n<p>​    对所有测试的查询进行比较。与基于cpu的系统相比，现有的协同处理系统在处理sam时有更多的故障，通常性能更差 e查询。这是因为协同处理系统通常不使用先进的查询优化技术，而且还不够成熟，无法利用GPU来有效地处理复杂的查询。 例如，OmniSci在图4中优于System-X，因为激励查询的关系具有高fi值（即接近1）。然而，图11中的TPC-DS查询通常fi较低 值（即，接近0），因此，配备支持索引驱动的查询执行和查询优化技术的System-X优于OmniSci。</p>\n<p>​    OmniSci只能执行两个查询，Q37和Q97，尽管使用OmniSci作为基础系统的SPRINTER可以执行所有11个查询。OmniSci和CoGaDB首先尝试使用GPU执行给定的查询。 但是，如果尝试失败，OmniSci和CoGaDB将使用CPU和主内存执行查询。这种两步方法增加了执行查询所需的数据无法匹配时的运行时间 在GPU内存中。此外，OmniSci以流水线的方式执行查询，而CoGaDB则以任意操作员的方式执行查询。因此，CoGaDB往往由于运行运行而失败。从大的中间结果a d缺乏查询优化技术。对于OmniSci，即使在使用主内存执行查询时，如果查询变得更加复杂，它也往往会错误地估计所需的内存量， 因此，左较深的连接树变得越来越深。因此，OmniSci往往由于错误内存分配的m.E.或FK-FK连接的大量探测成本而失败。</p>\n<p>​    相比之下，SPRINTER虽然是基于OmniSci的，但没有失败，查询性能显着提升。 SPRINTER生成的查询计划中的左深连接子树比OmniSci的连接树小很多，同时， 几乎没有用于构建哈希表的事实表，如第 3 节所示。 OmniSci 可以充分评估这种小而简单的连接子树，而不会导致 ME 的失败此外，SPRINTER 的探测成本远小于 的 OmniSci 由于 n-ary join 处理，所以没有 T.O. 对于 Q37 和 Q97，SPRINTER(G) 与 OmniSci 相比，性能分别提高了 88.8 倍和 1.5 倍。</p>\n<h3 id=\"7-3-SPRINTER特征\"><a href=\"#7-3-SPRINTER特征\" class=\"headerlink\" title=\"7.3 SPRINTER特征\"></a>7.3 SPRINTER特征</h3><p>​    成本模型的验证：我们对第6节中的成本模型进行了经验验证。在算法2中，我们决定是否使用传统的左深连接树的计划（表示为左深）或更多 基于成本模型的无连接操作（表示为无连接操作）的总体计划。因此，成本模型尽可能地与实际性能相一致是非常重要的。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fcj652ij30gg07gt9d.jpg\"></p>\n<p>​                                                    图12：成本模型的验证。</p>\n<p>​    图12显示了基于成本模型的估计和在查询空间中的实际性能结果。对于查询空间，我们将图3中的激励查询的（1）修改为数字o fFK-FK连接、（2）过滤选择性(即fi)和（3）在散列表中具有相同键的元素的平均数量(即dupi)。激励查询中FK-FK连接的数量为两个 （图12(a)），通过cust列连接（连接）一个新的事实表CR与CS和C，该数字变成3（图12(b)）。我们在y轴上的选择性fi在0.0001和1.0之间变化 通过调整c的fi。我们还在x轴上改变dupi，通过不同的连接列将C替换为不同的维度表，如CD、CA、I和HD，从而改变dupi。例如，如果我们使用CD而不是C和joinCD 通过cdemo列的事实表，{dupi}大约变成6(dupi=6)。在这种情况下，我们通过调整CD的fi来改变y轴上的选择性fi。类似地，我们设置了dupi= 11使用C，dupi=19使用CA，dupi=44使用I，dupi=126使用HD。图12显示了结果，其中红色单元格表示左深平面比n型灌木丛获得更好的性能 平面图，蓝色单元格表示相反的情况。在图中，在大多数单元格的估计和实际结果方面都优于左深部计划 查询空间。我们注意到，该估计通常与实际结果一致（90%匹配）。</p>\n<p>​    全局变量阶启发式算法的验证：我们使用三个TPC-DS查询Q17、Q25和Q29(SF=100)验证了启发式算法在算法3中的有效性。在的 图13左表，Ew和Cw是算法3中使用的统计数据，Rank是按(|Ew|，Cw)对变量进行排序时的排序。所有三个qu的核心子图 经过测试的Q17、Q25和Q29由三个连接变量C、I和T组成。存在3！这三个变量的=6个顺序，图13中的右图显示了s的查询处理时间 ix对这三个查询的不同顺序。根据我们的启发式算法，I≺C≺T和C≺I≺T的性能应该最好，而T≺I≺C和T≺C≺I的性能最差。此前 预测的结果与图中的实际结果一致。这意味着我们选择良好的全局变量顺序的启发式算法很简单，但很有效。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0fdlyfqwj30kr0jadhp.jpg\"></p>\n<p>​                            图13：不同全局变量顺序的结果。</p>\n<p>​                            图14：性能分解的结果。</p>\n<p>​    性能细分：图14显示了使用三个TPC-DS查询Q17、Q25和Q29对SPRINTER的微观评估结果。基于三种主要技术，有五种可能的配置 提出：名词连接处理（简称，名词），在算法3中选择一个全局变量顺序。O.)并将Teval与Tsort重叠(很快，O.E.)。在图14中，没有输出选项平均值 s随机选择一个全局变量顺序，而不使用算法3。没有O.E.选项意味着评估连接子树，然后对其结果进行排序，如图7所示。在图中，第五条，即， 没有N-ary、没有V.O.和没有O.E.，显示了基础系统的性能，即OmniSci。</p>\n<p>​    在图中，N-ary选项提高了Q17和Q25的查询性能。第四条(即N-ary，但没有V.O和没有O.E)比第五条表现得更差的原因 e系统)是由于随机选择的全局变量顺序较差。结果表明，不仅n-ary查询处理，而且选择一个良好的全局变量顺序是重要的 f性能。在第二（即V.O，但没有O.E）和第三（即O.E，但没有V.O）条之间，第二条比第三条提高性能更显著 （即，没有输出和无输出）。结果意味着选择一个良好的全局变量顺序比与Tsort重叠Teval更重要。总的来说，只有没有O.E的N-ary和V.O选项才能超过其性能 m是所有已测试的查询的基本系统。优化选项只是进一步提高了性能。</p>\n<p>​    排序性能：我们通过经验验证了选择连接算法的策略。图15显示了表1中排序算法的性能评价。当对Fi中的单个列进行排序时 Gure15(a)，cpu半径比cpu合并快，gpu半径比gpu合并快，如图9所示。当对图15(b)中的多列进行排序时，gpu合并仅比mergecpu合并稍快，如5.2节所示。当对大于G的单列关系进行排序时 图15(c)中的PU内存，异构排序比cpu半径快得多。总的来说，实验结果验证了图9中的策略。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt0ffn2ms2j30hf0d4q4b.jpg\"></p>\n<p>图15：排序策略的验证。</p>\n<h2 id=\"8-相关工作\"><a href=\"#8-相关工作\" class=\"headerlink\" title=\"8 相关工作\"></a>8 相关工作</h2><p>​    多路连接处理：最近，人们提出了最坏情况最优(WCO)连接算法来评估图模式查询[31,44]中发生的多路连接。它们在理论上提供了一个紧密的结构 通过执行多排序关系之间的一种集交集，以多路连接结果的坏大小进行约束。其中一些是[1,31,44]需要构建一个大规模的inde x表示加入前的全局变量顺序。它们对于在少量关系上有一些全局变量顺序的图模式查询很有用。然而，将它们应用于广告-中却具有挑战性 特殊的OLAP查询，因为每个OLAP查询在大量关系上都有许多可能的全局变量顺序。</p>\n<p>​    [2,13,49]的一些研究讨论了分布式环境上的多路连接处理。他们的优化目标是通过重新分配多个连接关系的组合来最小化通信成本 r，而不是一次变换连接操作的一对输入关系。</p>\n<p>​    WCO连接算法的查询计划：DunceCap[36,43]专注于为WCO连接算法生成超树查询计划。它利用了inp的最小超树宽度之间的连接 ut查询和查询结果的大小。在这里，宽度表示一个给定的查询与无环查询[32]的距离或相应的超图[38]的循环程度。具有mi的计划树 最小宽度保证了最小的最坏情况下的输出大小，因此，它的查询性能与宽度[4]成正比，这被称为agm绑定。</p>\n<p>​    DunceCap 对于图数据集上的循环查询（例如三角形查询）很有用，因为它利用超图来捕获查询中存在的循环。 然而，它不适用于 OLAP 查询，因为它们通常是非循环的。 例如，第 3 节中的激励查询在相应的超图中没有循环，因为 C1、C2 和 C3 在超图中被视为不同的关系。 中没有循环查询TPC-DS 基准测试。</p>\n<p>​    对于此类非循环查询，超树宽度的概念无法提供确定最佳查询计划的洞察力。 此外，过滤谓词对大事实表可能会显着减少连接结果的大小，因此可能远离最坏情况的界限。</p>\n<p>​    OLAP查询的协处理方法：近年来，数据库社区[14,15,17,35,42]已经积极研究了OLAP查询处理的协处理方法。它们可以按int类型进行分类 o两组：（1)加速数据库内核[15,42]和(2）端到端查询评估引擎[14,17,35]。协同处理方法的主要问题是GPU内存的限制，这可能会 由于主存和设备内存[14]之间频繁的数据传输而导致较高的I/O开销，或在运行时由于内存不足而导致故障。</p>\n<h2 id=\"9-结论\"><a href=\"#9-结论\" class=\"headerlink\" title=\"9 结论\"></a>9 结论</h2><p>​    本文提出了一种针对具有FK-FK连接的复杂OLAP查询的快速n-ary连接查询处理方法。它会生成一个包含n-ary连接运算符的查询计划，如果它优于 基于我们的成本模型的传统的左深二进制连接树。该计划可以通过将事实表格上的FK-FK连接放入一个n-ary连接操作符中，从而显著降低探测成本。我们也有p 提出了一种基于TJ算法和启发式算法选择良好的全局变量阶的有效的n元连接处理方法。我们已经实现了原型系统短跑机t 我们提出的方法被集成到开源的内存OLAP系统OmniSci系统中，横跨所有相关的层和模块中。通过使用TPC-DS基准测试的实验，我们已经证明了 即使没有使用GPU排序，SPRINTER的性能也优于最先进的OLAP系统，尽管它的基础系统OmniSci达到了它们中第二差的性能。</p>\n<h2 id=\"ACKNOWLEDGMENTS\"><a href=\"#ACKNOWLEDGMENTS\" class=\"headerlink\" title=\"ACKNOWLEDGMENTS\"></a><strong>ACKNOWLEDGMENTS</strong></h2><p>​    这项研究得到了韩国政府(MSIT)资助的韩国国家研究基金会(NRF)的资助。2018R1A5A1060031)，国家特区基础科学研究项目 韩国科学基金会(NRF)由科学、信息和未来规划部资助。2017R1E1A1A01077630)，和信息通信技术规划评估研究所(IITP)gra 由韩国政府资助(MSIT)资助。2019-0-01267，基于gpu的超快多类型图形数据库引擎SW)。</p>\n"},{"title":"周末的上海-前置摄像头给自己理个发","date":"2021-08-01T03:06:58.000Z","type":"个人生活","thumbnail":"https://tva1.sinaimg.cn/large/008i3skNgy1gt14d2z4q0j31900u0tb5.jpg","_content":"\n我强烈支持理发店的tony老师应该先考个证才能上岗，一点审美都没有。\n\n去年也就是2020年我留的是板寸，已经快忘记自己寸头的样子了。那时候刚研一，脸圆圆的，顶着个寸头见新同学哈哈哈哈，\n\n后来今年也见是21张龙问我，怎么你头发这么多了，班级轰趴的时候还一起合影了哈哈哈。。我说不是头发多，是我头发长长了，\n\n我比较喜欢这种风格的发型，\n\n由于本人不是很好看，所以照片是不可能放在朋友圈的，影响圈容圈貌哈哈哈\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt13x56y2sj30xg0u00wj.jpg)\n\n\n\n、镜子不好操作，用Mac还行\n\n现在实习公司里都是男的多，有时候还是没注意自己的形象，\n\n单身久了，有时候确实顾不上，长得不算好看的人，不积极努力去寻找能接受这样的自己的人，是不可能摆脱单身的，尤其是男的23333\n\n不过我这个人有个好处是，不知道为啥我很喜欢自己的样子，而有一些长得很好看的男的，还是经常对自己长相不满意，我觉得duck不必了\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt13ywrnfcj30xg0u0dk0.jpg)\n\n\n\n\n\n大功告成\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt13xa92ulj30xg0u078a.jpg)\n\n\n\n去公司应该头发不会翘起一小撮了\n\n","source":"_posts/周末的上海-前置摄像头给自己理个发.md","raw":"---\ntitle: 周末的上海-前置摄像头给自己理个发\ndate: 2021-08-01 11:06:58\ntype: \"个人生活\"\ncategories: \n    - 个人生活\ntags:\nthumbnail: https://tva1.sinaimg.cn/large/008i3skNgy1gt14d2z4q0j31900u0tb5.jpg\n---\n\n我强烈支持理发店的tony老师应该先考个证才能上岗，一点审美都没有。\n\n去年也就是2020年我留的是板寸，已经快忘记自己寸头的样子了。那时候刚研一，脸圆圆的，顶着个寸头见新同学哈哈哈哈，\n\n后来今年也见是21张龙问我，怎么你头发这么多了，班级轰趴的时候还一起合影了哈哈哈。。我说不是头发多，是我头发长长了，\n\n我比较喜欢这种风格的发型，\n\n由于本人不是很好看，所以照片是不可能放在朋友圈的，影响圈容圈貌哈哈哈\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt13x56y2sj30xg0u00wj.jpg)\n\n\n\n、镜子不好操作，用Mac还行\n\n现在实习公司里都是男的多，有时候还是没注意自己的形象，\n\n单身久了，有时候确实顾不上，长得不算好看的人，不积极努力去寻找能接受这样的自己的人，是不可能摆脱单身的，尤其是男的23333\n\n不过我这个人有个好处是，不知道为啥我很喜欢自己的样子，而有一些长得很好看的男的，还是经常对自己长相不满意，我觉得duck不必了\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt13ywrnfcj30xg0u0dk0.jpg)\n\n\n\n\n\n大功告成\n\n\n\n![](https://tva1.sinaimg.cn/large/008i3skNgy1gt13xa92ulj30xg0u078a.jpg)\n\n\n\n去公司应该头发不会翘起一小撮了\n\n","slug":"周末的上海-前置摄像头给自己理个发","published":1,"updated":"2021-08-01T04:29:14.360Z","_id":"ckrsnj9tj0000u4f120d8bqp8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我强烈支持理发店的tony老师应该先考个证才能上岗，一点审美都没有。</p>\n<p>去年也就是2020年我留的是板寸，已经快忘记自己寸头的样子了。那时候刚研一，脸圆圆的，顶着个寸头见新同学哈哈哈哈，</p>\n<p>后来今年也见是21张龙问我，怎么你头发这么多了，班级轰趴的时候还一起合影了哈哈哈。。我说不是头发多，是我头发长长了，</p>\n<p>我比较喜欢这种风格的发型，</p>\n<p>由于本人不是很好看，所以照片是不可能放在朋友圈的，影响圈容圈貌哈哈哈</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt13x56y2sj30xg0u00wj.jpg\"></p>\n<p>、镜子不好操作，用Mac还行</p>\n<p>现在实习公司里都是男的多，有时候还是没注意自己的形象，</p>\n<p>单身久了，有时候确实顾不上，长得不算好看的人，不积极努力去寻找能接受这样的自己的人，是不可能摆脱单身的，尤其是男的23333</p>\n<p>不过我这个人有个好处是，不知道为啥我很喜欢自己的样子，而有一些长得很好看的男的，还是经常对自己长相不满意，我觉得duck不必了</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt13ywrnfcj30xg0u0dk0.jpg\"></p>\n<p>大功告成</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt13xa92ulj30xg0u078a.jpg\"></p>\n<p>去公司应该头发不会翘起一小撮了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我强烈支持理发店的tony老师应该先考个证才能上岗，一点审美都没有。</p>\n<p>去年也就是2020年我留的是板寸，已经快忘记自己寸头的样子了。那时候刚研一，脸圆圆的，顶着个寸头见新同学哈哈哈哈，</p>\n<p>后来今年也见是21张龙问我，怎么你头发这么多了，班级轰趴的时候还一起合影了哈哈哈。。我说不是头发多，是我头发长长了，</p>\n<p>我比较喜欢这种风格的发型，</p>\n<p>由于本人不是很好看，所以照片是不可能放在朋友圈的，影响圈容圈貌哈哈哈</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt13x56y2sj30xg0u00wj.jpg\"></p>\n<p>、镜子不好操作，用Mac还行</p>\n<p>现在实习公司里都是男的多，有时候还是没注意自己的形象，</p>\n<p>单身久了，有时候确实顾不上，长得不算好看的人，不积极努力去寻找能接受这样的自己的人，是不可能摆脱单身的，尤其是男的23333</p>\n<p>不过我这个人有个好处是，不知道为啥我很喜欢自己的样子，而有一些长得很好看的男的，还是经常对自己长相不满意，我觉得duck不必了</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt13ywrnfcj30xg0u0dk0.jpg\"></p>\n<p>大功告成</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gt13xa92ulj30xg0u078a.jpg\"></p>\n<p>去公司应该头发不会翘起一小撮了</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckrsnj9tj0000u4f120d8bqp8","category_id":"ckrspfcpp0000a8f16hk13iai","_id":"ckrspfcpt0001a8f10ztyddrg"},{"post_id":"ckrrpvg2g0000wc762o87afmh","category_id":"ckrsphvzw0000baf18s0peet6","_id":"ckrsphw000001baf16hf6ahws"}],"PostTag":[],"Tag":[]}}