MySQL严格的数据结构约束，严格的事务标准，牺牲了很多性能。可以进行复杂的语义查询。包括连接、函数计算

但是Innodb对磁盘占用却很高，应该是对事务控制多了很多需要记录的日志。

在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。

redo log
redo log和undo log都属于InnoDB的事务日志。下面先聊一下redo log存在的背景。

InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。

为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：

当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；

当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。

redo log也需要在事务提交时将日志写入磁盘，写redo log是追加操作，属于顺序IO。

隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）

间隙锁，where id > 10 and id < 15

==========

MongoDB作为一个数据库产品, 是拥有源数据管理能力的

关系型数据库和文档型数据库都使用了 DDL 和 DML 的概念。然而，在关系数据库中，DDL 和 DML 的定义很重要。

MySQL 凭借数据表使数据类型系统化，使数据中各自的值都能充分查询并且容易搜索，所以使用 MySQL 意味着数据库结构是稳定不变的。

但是，对于非结构化的数据，它就不适合。MySQL 最大的优点（也可以说是缺点）在于需要事先定义数据结构，这就避免了很多技术债务。

但是，在某些情况下，数据太复杂，就难以设计一套合适的模式。

反之，MongoDB 的数据模式的扩展性较强，不像 MySQL 那样关注数据结构。虽然这似乎是一个很大的缺点，

但这种一致性实际上是 MySQL 最大的优势，因为它确保了数据的结构化，维持了数据的清洁性。

mongoDB的性能是十分优秀的，千万级别的文档对象，对有索引ID的访问与mysql不相上下，而对没有索引ID的访问，mongoDB的访问性能则是全面胜出

mongoDB会将系统内存作为缓存，这也是mongoDB查询速度比mysql快的原因之一。

mongoDB官方自带一个分布式文件系统，可以很方便的部署至服务器机群上。且mongoDB有一个Shard的概念，

数据库的平均插入速率：MongoDB不指定_id插入 >MySQL不指定主键插入 > MySQL指定主键插入 > MongoDB指定_id插入

Elasticsearch作为一个搜索引擎, 定位是提供数据检索服务, 

也就是说我只管查, 不管写 _, 

Elasticsearch的Mapping不可变也是为此服务的, 

带来的代价就是es不适合作为数据管理者, 

es可以从其他数据源同步数据过来提供查询, 

但是不适合自己对数据进行存储和管理

es更侧重数据的查询, 各种复杂的花式查询支持的很好, 相比来说 MongoDB的查询能力就显得比较平庸了

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h415hvcjaej20o70gqwg2.jpg)

由此可见, 对于个人, 如果你有一批数据要看, 但是不经常进行修改, 

这个时候毫无疑问可以用es, 但是如果你还打算继续修改数据, 

最好就是使用MongoDB，但其实对大多数人公司来讲，这两者的数据管理能力并没有多大的影响

MongoDB和ElasticSearch都支持全文索引, 虽然MongoDB的全文索引效果完全无法跟es相比(es毕竟是专业的搜索引擎产品, 

着重提供数据的检索支持, 这方面吊打MongoDB也是可以理解的)

MongoDB虽然在支持的部分查询功能上稍微弱于es, 但是在大部分场景下性能方面完爆es, 不管是读性能, 还是写性能

es的写入延迟默认为1s, 这个虽然是写入延迟的范畴, 但是毫无疑问是一大缺点, 

虽然可以配置为更短的时间, 但是这样就要牺牲一定的数据吞吐量, 会造成更频繁的磁盘刷新操作

两者都通过分片支持水平扩展, 同时都通过副本来支持高可用(HA)

分片就是一个数据集的数据分为多份, 同时分布在多个节点上存储和管理, 

主流分片方式有两种: hash分片和range分片, 两种分片方式各有优势, 适合不同的场景

es使用Restful来提供统一的操作接口, 屏蔽了各种语言之间的障碍, 但是同样带来了表达能力和性能的损失

**MongoDB则使用TCP, 降低了序列化和网络这一层的性能损耗**, 并最大程度保留了接口的内容表达能力, 但是相对的使用起来就不如http那么的方便

## 适用场景
两者其实在很多使用场景上有重合之处, 是可以互相替代, 比如日志收集

MongoDB适合
- 对服务可用性和一致性有高要求
- 无schema的数据存储 + 需要索引数据
- 高读写性能要求, 数据使用场景简单的海量数据场景
- 有热点数据, 有数据分片需求的数据存储
- 日志, html, 爬虫数据等半结构化或图片，视频等非结构化数据的存储
- 有js使用经验的人员(MongoDB内置操作语言为js)

Elasticsearch适合
- 已经有其他系统负责数据管理
- 对复杂场景下的查询需求，对查询性能有要求, 对写入及时性要求不高的场景
- 监控信息/日志信息检索
- 小团队但是有多语言服务，es拥有restful接口，用起来最方便











