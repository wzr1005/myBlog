
# 微服务 Spring cloud Alibaba

## 微服务优点

抽取公共代码为服务层，增强代码复用性

缺点： 调用关系复杂，维护困难  比如调试的时候没那么方便，需要写好单测

用户服务、商品服务、订单服务、个人中心服务、前台页面系统

## 微服务拆解原则
业务边界、

扩展性、复用性、高性能、高可用、安全性、异构性

领域驱动设计(Domain Driven Desing,简称DDD)，

功能模块设计需要划分清楚业务边界，主要的主要设计方法为DDD（Domain Driven Desing），根据扩展性、复用性、高可用性以及异构性等主要参考原则，将本平台划分为影视资源模块、评价模块、推荐模块三个部分。

其中影视资源模块包含搜索、详情页几个子模块。基础功能包含关键词搜索、

核心域、通用域、支撑域

- 核心域 搜索微服务、相关推荐微服务、个性化推荐微服务
- 支撑域 评价体系微服务、看单微服务、
- 通用域 用户微服务、权限微服务、

## SOA架构
引入服务治理中心，维护复杂的调用关系。

服务有依赖性，可能会因为一个服务导致多个系统不可用。

## 微服务的原子化拆分
相比SOA，优点
- 服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展
- 微服务之间利于restful等轻量级http协议相互调用

## 微服务遇到的问题
1. 这么多小服务，该如何管理 （服务治理，注册中心
2. 这么多小服务，这么调用（restful，rpc
3. 这么多小服务，客户端怎么来访问 （网关
4. 这么多小服务，如果出现问题了，那么作为服务自身来讲，应该如何处理？ （容错
5. 这么多小服务，如果中间哪个环节出问题了，该如何排查 （链路追踪

## 微服务特性
### 服务治理
服务的自动化管理，其核心是服务的自动注册与发现

服务注册：服务实例将自身服务信息注册到注册中心。

服务发现：服务实例通过注册中心，

服务剔除

### 服务调用

在微服务架构中，通常存在多个服务之间的远程调用的需求，目前主流的远程调用技术有基于HTTP的RESTFUL接口，以及基于TCP的RPC协议。

- REST
  这是一种HTTP调用的格式，梗标准、更通用，无论哪种语言都支持http
- RPC

一种进程间通信方式，允许像调用本地服务一样调用远程服务。RPC框架的主要目标就是让远程服务调用更简单透明。

RPC框架负责屏蔽底层的传输方式，序列化方法和通信细节。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可。

并不需要关系底层通信细节和调用过程。（基于socket）

常用的通信协议 

RMI 、 Httpinvoker 、 Hessian 、 Burlap 、 Web service

grpc适用于短连接，多频次，长连接可以直接使用http1.1
RMI 基于java bean，
- 性能
- 


  | 比较项    | RESTful    | RPC    |
  | ---- | ---- | ---- |
  |    通信协议  | HTTP     |   一般基于tcp   |
  |性能|略低|较高|
|灵活度|高|低|
|应用|微服务架构|SOA架构|


### 服务网关

不同的微服务一般会有不同的网络地址，API网关映射

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h3jepx23rpj20ok0fwgnd.jpg)

鉴权、限流可以放在API网关

### 服务容错
1. 不被外界环境影响
2. 不被上游请求压垮
3. 不被下游响应拖垮

### 主要功能

- 服务限流降级 Spring cloud、gateway、zuul、dubbo、MQ限流降低功能的介入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metrics监控
- 服务注册与发现：适配Spring cloud服务注册与发现标准，默认集成了ribbon的支持
- 分布式配置管理：支持分布式系统中心的外部化配置，配置更改时自动刷新
- 消息驱动能力 Spring Cloud Stream为微服务应用构建消息驱动能力
- 分布式事务 使用@GlobalTransaction注解，高效并且对业务零侵入 解决分布式事务问题
- 阿里云对象存储：阿里云提供的
- 分布式任务调度，

### 组件

- Sentinel 服务容错。把流量作为切入点，从流量控制、 熔断降级、系统负载白虎等多维度保护服务的稳定性
- Nacos，一个更易于构建云原生的动态服务发现，配置管理和服务管理平台
- RocktMQ，一款开源的分布式消息系统， 类似Kafka
- Dubbo，Apache Dubbo是一款高性能RPC框架
- Seata 阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 



### 调用微服务，问题
1. 一旦服务提供者的uri信息变化了，我们就不得不去修改服务调用者的java代码
2. 一旦无法提供者做了集群，服务调用者一方无法实现负载均衡的去调用
3. 一旦微服务变得越来越多，如何来管理这个服务清单就成了问题

#### 引入服务治理者
服务治理是微服务架构中最核心的模块，用于实现各个微服务的**自动化注册与发现**

- 服务注册：在服务治理框架中，都会构建一个注册中心，每个服务单元向注册中心登记自己提供服务的详细信息，并在注册中心形成一张服务清单，服务注册中心需要以心跳的方式去监测清单中的服务是否可用。。如果不可用，需要在服务清单中剔除不可用的服务
- 服务发现：服务调用方向服务注册中心咨询服务，并获取所有服务的实例清单，是心啊对具体服务实例的访问。

##### 常见的注册中心
- zookeeper
  zookeeper是一个分布式服务框架，是apache Hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题。如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。
- Eureka是springcloud Netflix中的重要组件，主要作用就是做服务注册和发现。但是现在已经闭源。
- Consul Consul是基于go语言开发的开源根据，主要面向分布式、服务化的系统提供服务注册，服务发现和配置管理的功能。Consul的功能都很使用，其中包括：服务注册/发现、健康检查、key/value存储、多数据中心和分布式一致性保证等特性。Consul本身只是一个二进制的可执行文件，所以按照和部署都非常简单，只需要从官方下载后，在执行对应的启动脚本即可。
- Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。它是Spring cloud Alibaba组件之一，负责服务注册发现和服务配置，可以这样认为 nacos=eureka+config。

##### Nacos简介
Nacos致力于帮助您发现、配置和管理微服务。nacos提供来一组简单易用的特性集，帮助快速实现动态服务发现、服务配置、服务元数据以及流量管理。

从上面的介绍就可以看出nacos的作用就是一个注册中心用来管理注册上来的各个微服务。

服务端下载
>https://github.com/alibaba/nacos/releases

客户端：

依赖
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-nacos-discovery</artifactId>
</dependency>
```
> 主类上添加@EnableDiscoverClient注解

一个Application运行两个实例，idea很方便的方式

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h3h0qfey8gj21bm0oy78w.jpg)

多模块启动，有些模块多服务访问不了，原因

**启动类的路径，确定能扫描到其他的包，如启动类的包在com.wzr.yi**

其他模块的包必须在com.wzr.yi。路径后面

启动类所在的pom.xml必须要有其他模块的依赖。

找不到或无法加载主类 启动类的首字母改成大写。

availableProcessors is already set to [8], rejecting [8]

原因是因为启动服务时elasticsearch连接与redis共用了netty连接，从而导致了冲突，从报错也能看出来已经告知已被占用。

>System.setProperty("es.set.netty.runtime.available.processors", "false");

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h3liuy5x5oj21gy0hodhg.jpg)

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h3lkqsm43ej210806vjuc.jpg)

1. restTemplate 代码可读性不好，
2. 编程风格不统一

nacos自带动态刷新。不用重启微服务就能使配置生效

#### 基于feign实现服务调用

feign是Springcloud提供的一个声明式的伪http客户端，它使得调用远程服务就像是调用本地服务易用简单，只需要创建一个接口并添加一个注解即可

Nacos很好的兼容了feign，feign默认集成了ribbon，所以在Nacos夏使用feign默认就实现了负载均衡的效果。

1. 加入feign的依赖
2. 在主类上添加feign的注解
3. 创建一个service，并使用feign实现微服务调用
4. 修改controller代码，并启动验证

feign解决

#### sentinel服务容错

tomcat一般支持200-400个线程，超过400个线程，大量的请求就会阻塞，线程无法释放。

##### 服务雪崩

服务与服务之间的依赖性，故障会传播，会对整个系统造成瘫痪。

#### 微服务分布式事务

跨资源分布式场景：不同的参与者需要同时更新删除不同服务器或数据库的几张表

事务参与者ABC AB提交成功，事务协调器宕机，这时候是没办法做事务回滚的操作了。，两阶段提交也可能会造成数据库的死锁。

因此事实上两阶段XA提交用的并不是很普遍。

解决方法可以用事务补偿，事务补偿的基础，幂等性。、

事务A订单提交 -> 事务B库存扣减

如果订单提交出现了问题error，那么就调用库存增加的逆操作。

基于base理论的最终一致性，强调最终一致性，用消息中间件配合完成。消息中间件有重试的机制。

二阶段提交+消息中间件（重试机制）达到最终一致性。如果多次重试错误，那可能是本身功能就有问题了。

- 二阶段提交：

协调者向所有参与者发送 REQUEST-TO-PREPARE 消息

协调者先收集所有服务节点，**达到precommit状态**。然后提交事务

一旦参与者发送了prepare消息，那么它在收到协调者最终决定（commit和abort）之前，它都无法提交或回滚。

如果此时协调者宕机了，那么所有参与者都会陷入阻塞状态，只有等到协调者恢复，事务才能继续进行

为了解决阻塞的问题，引入了三阶段提交。


- 三阶段提交：

协调者cancommit，达到PREPARED状态。参与者执行事务准备，并将undo信息和redo写入日志

当参与者收到REQUEST-TO-PREPARE 消息后, 它向协调者发送PREPARED或者 

NO消息， 表示事务是否准备好；如果发送的是NO， 那么事务要回滚；

协调者再向参与者发送 PRE-COMMIT的确认。

参与者向协调者发送PRE-COMMIT DONE消息确认; 如果它收到ABORT消息, 回复DONE确认。

3PC中，协调者只有确保所有参与者都从PREPARED状态到达PRE-COMMIT状态后才会发送COMMIT消息。如果协调者宕机了。这时事务参与者的状态可能有4种：

ABORTED，PREPARED，PRE-COMMIT， COMMITTED

参与者会选出一个新的协调者，协调者会询问所有参与者的状态，分为以下几种情形：

1.存在参与者在COMMITTED状态，协调者向所有参与者发送COMMIT，提交事务；

2.存在参与者在ABORTED状态， 协调者向所有参与者发送ABORT，回滚事务；

3.所有参与者都在PREPARED状态，协调者向所有参与者发送ABORT，回滚事务；

4.存在一些参与者在PRE-COMMIT状态，其它参与者在PREPARED状态，

协调者向处在PREPARED状态的参与者发送PRE-COMMIT消息，继续按照上面描述的5)，6)推进事务。

5) 协调者收集到所有参与者对PRE-COMMIT的确认（PRE-COMMIT DONE）消息后，协调者向所有参与者发送COMMIT；

6) 参与者已经进入PRE-COMMIT状态，并收到了COMMIT消息，参与者提交事务并回复COMMIT DONE确认。




##### 第一阶段 cancommit
决定是否可以进入预提交的状态，协调者等待参与者条件是超过半数投赞成票


##### 第二阶段 precommit 


如果任何一个参与者投了反对票或者超时，协调者就会执行事务的中断

中断事务： 协调者向所有参与者发送abort请求，参与者收到或者超时未收到都执行事务的中断

##### docommit阶段
该阶段进行真正的事务提交，也可以分为以下两种情况。

执行提交，发送提交请求，协调接收到参与者发送的ACK响应，那么他将从预提交状态进入提交状态

### 一致性hash算法

哈希环，ABC三台主机发送映射到哈希环上，哈希值前后不变

当新增一台主机后，只会使得一部分主机失效

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h3vx9xff8dj20f907mq35.jpg)

缺点：缓存可能会出现不均匀的情况，只有主机足够多，才能均匀的打在缓存上。

具体的方式可以增加一些虚拟节点，比如服务器A，虚拟成A1 A2 A3 减少哈希环不均匀的影响

### 常见的容错方案
要防止雪崩的扩散，我们就要做好服务的容错。容错说白了就是保护自己不被猪队友拖垮的一些措施，即解耦合。

以下思路都可以在sentinel控制台上配置。

**常见的容错思路**：

- 隔离
- 超时
- 限流
- 熔断
- 降级

#### 隔离
它是将系统按照一定的原则规划为若干个服务模块，各个模块之间相互独立，无强依赖。当有故障发生时，

能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其他模块，不影响整体的系统服务。

常见的隔离方式有：

- 线程池隔离
- 信号量隔离

##### 线程池隔离
A服务有三个方法，a、b、c

每个方法分配线程池pool-a pool-b poolc，这样某个方法挂了，其他线程池的方法还可用

#### 超时
在上游服务调用下游服务的时候，设置一个最大响应时间，如果超过这个时间，下游未作出反应，

就断开请求，释放掉线程

优点：

#### 限流
限流就是限制系统的输入和输出流量已达到保护系统的目的。为了保证系统的稳固运行，一旦达到的需要限制的阈值，

就需要限制流量并采取少量措施以完成限制流量的目的。

#### 熔断
在互联网系统中，当下游服务因访问压力过大而响应变慢或失效，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用

这种牺牲局部、保全整体的措施就叫做熔断。一段时间后会尝试。判断熔断的条件有时间限制，成功率

服务熔断一般有三种状态：
- 熔断关闭状态 服务没有故障，熔断器所处的状态，对调用不做任何限制
- 熔断开启状态 后续对该服务借口对调用不再经过网络，直接执行本地对fallback方法，直接拒绝
- 半熔断状态 尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到语气，则说明服务已恢复，进入熔断关闭状态。如果成功率依旧很低，则重新进入熔断关闭状态。

#### 降级
降级其实就是为服务提供一个托底方案，本质目的是牺牲一些功能，保证整个系统的正常允许。

一旦某个服务无法正常调用，就使用托底方案。

#### 常见的服务容错组件

- Hystrix
  Hystrix是由Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止及联失败。
- Sentinel 哨兵
  sentinel是阿里巴巴开源的一款断路器实现，本身在阿里内部已经被大规模采用，非常稳定。

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h3yrd1xaj3j20z40r641w.jpg)

#### 什么是sentinel
sentinel分布式系统的流量防卫兵，阿里巴巴开源的一套用于服务容错的综合性解决方案。它以流量为切入点，从流量控制、熔断降级、系统负载保护等多个唯独来保护服务的稳定性。

sentinel具有以下特征

- 丰富的应用场景。秒杀、消息雪峰、集群流量控制
- 监控的实时监控。
- 开箱即用。与其他开源框架/库的整合模块，例如Spring cloud、dubbo、grpc的整合。只需要引入相应的依赖并进行简单的配置即可快速介入sentinel

核心库（java客户端），不依赖任何框架，独立运行java运行时环境。

sentinel服务是懒加载的，第一次调用该微服务会在控制台中对该服务进行注册，

sentinel在service层加注解

sentinel流控模式：直接流控、关联流控（涉及到的资源达到阈值）、链路流控（很少用）

降级策略：
- RT：
- 平均响应时间 
- 异常比例

降级窗口时间，触发降级后一段时间后恢复正常

比如访问我的首页，如果访问量过高，服务可以少请求一些数据库，减少单词开销。能保持正常访问就可以

@SentinelResource（"资源名称"）
热点的流控的规则可以精细化到参数的类型、参数的值，

返回异常判断是什么异常，可以写个异常类 实现 对应的标准异常类

if(e instanceof FlowException){
log.error("流量异常") 

## Gateway简介
- nginx + lua
使用nginx反向代理和负载均衡，可实现对api服务器对负载均衡以及高可用

lua是一种脚本语言，可以来编写一些简单对逻辑，nginx支持lua脚本，写一些鉴权对业务逻辑等。

- kong 
基于nginx—+lua开发，性能高，稳定，有多个可用等插件，限流鉴权等待，可以开箱即用。

问题，只支持http协议；二次开发，自由扩展困难；提供管理API，却饭灵活等管控、配置方式。

- Zuul
Netflix 开源的网关，功能丰富，使用java开发，易于二次开发。

问题：缺乏管控，未开源，依赖组件较多；处理http请求依赖的是web容器，性能不如nginx。在web容器层的做的工作。

- Spring cloud gateway
Spring公司为了替换zuul而开发的网关服务，将在下面具体介绍。

Spring Cloud Gateway是Spring公司基于Spring5.0 Spring boot2.0和project Reator等技术开发的网关，

它旨在为微服务架构提供一种简单有效的统一的API路由管理方式。它的目标是替代Netflix Zuul，

其不仅提供统一的路由方式，并且基于Filter链的方式提供来网关基本的功能。例如：安全、监控/指控和限流。


优点：

- 性能强劲：是第一代网关Zuul的1.6倍
- 功能强大：内置来很多实用的功能，例如转发、监控、限流等
- 设计优雅：容易扩展

缺点

- 其实依赖Netty与WebFlux，不是传统等Servlet编程模型，学习成本高
- 不能将其部署在tomcat、jetty等servlet容器里，只能打成jar包执行
- 需要spring boot2.0以上才支持

```yml
gateway:
  rooutes: # 路由数组 /路由 就是指当请求满足什么样的条件的时候转发到哪个服务器上
    id: # 当前路由发的标识，要求唯一
    uri: localhost:8081# 请求最终要被转发到的地址
    order: # 路由的优先级，数字越小代表路由的优先级越高
    predicates: # 断言
      path=/product-serv/** # 当请求露肩满足path指定的规则时，此路由信息才会正常转发 [数组]
    filters: # 过滤器，对请求做一些处理
      StripPrefix=1 #请求转发之前把1strip掉。
      
```






