1. crontab -l //列出某个用户的cron服务的详细内容 

   ```shell
   0 4 * * * scp -r ~/Documents root@101.43.102.16:/home/zhenrenwu/backup
   # 每天四点运行
   0 */2 * * * # 每两个小时执行一次
   ```

   

BDB整个系统在设计时就完全摒弃了随机写，除了操作日志总是顺序追加写入到SATA盘上，剩余所有的写请求都是对响应时间要求不是很高的批量顺序写，SSD盘可以轻松应对，而大量查询请求的随机读，则发挥了SSD良好的随机读的特性。摒弃随机写，采用批量的顺序写，也使得固态硬盘的使用寿命不再成为问题，主流SSD盘使用MLC SSD芯片，而MLC号称可以支持擦鞋1万次（SLC可以擦除10万次，但因成本高而较少被使用），即使按照保守的2500次擦写次数计算，而且每天做一次全盘擦写，其使用寿命也能达到2500/365=6.8年。



微博私信需要跟外部门对接，不同系统间的处理耗时和速度不一样，可以通过队列进行缓冲；群聊是耗时操作，消息发到群后，可以通过异步队列来异步完成消息的扩散写等等。



[redhat](https://so.csdn.net/so/search?q=redhat&spm=1001.2101.3001.7020)和Ubuntu上的bin能通用吗？答：如果架构不同的cpu编译出的操作系统中的bin，很多时候会不能跨平台通用的，如64位cpu上编译的redhat系统中的bin，放在32位的Ubuntu中就不能运行。在硬件相同，os也相同的情况下，就需要比较.so动态库文件、启动文件是否相同，如果三者都一致，我们可以判断这类文件通常是可以跨平台运行的。



```
因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么。所以Java可以跨平台。
因为它有虚拟机（JVM），JAVA程序不是直接在电脑上运行的，是在虚拟机上进行的，每个系统平台都是有自己的虚拟机（JVM），所以JAVA语言能跨平台。 
java代码不是直接运行在CPU（用cpu的指令集）上，而是运行在java虚机（简称JVM)上的。   
  java是先把java文件编译成二进制字节码的class文件，jvm就解释执行class文件。   
  就是因为java是运行在jvm上的，所以它的代码就能不经修改，就能在不同平台的jvm上运行(在UNIX用UNIX的jvm,在linux上用linux的jvm，在windows上用windows的jvm）   
▪Java的跨平台原理:
       java源文件(.java)要先编译成字节码文件(.class)，然后字节码文件再通过java虚拟机(JVM)解释成具体平台上的机器指令 (机器码) 在平台上运行。编译生成的字节码文件可以在多种平台上不加修改地运行(但与任何平台无关),通过java虚拟机在平台运行（一次编译，到处运行）。
java虚拟机与平台相关，不同的平台需要不同的java虚拟机，但它们都提供了相同的接口。
▪与C语言跨平台原理的不同之处:
          JAVA是一次编译，到处运行，C语言是多次编译，到出运行
          C语言从源代码到可执行文件需要经过以下步骤: C语言源代码->预处理->汇编->翻译->链接->计算机执行
```

# C语言 程序的编译主要过程

**编译环境                            运行环境**

**源文件（.c文件） —————————可执行文件（.exe文件）——————— 计算结果**

## 一、编译环境：

编译环境下编译器与链接器发挥各自的作用，其各自的主要操作如下

**编译器：** Linux 环境下 （文件格式转变）

### 1. [预编译](https://so.csdn.net/so/search?q=预编译&spm=1001.2101.3001.7020) （处理文本） test.c——>test.i

① 包含的[头文件](https://so.csdn.net/so/search?q=头文件&spm=1001.2101.3001.7020)

② 删除注释（使用空格替代）

③ 替换#define 中的内容

### 2. 编译 （把C语言代码转变成汇编代码） test.i——>test.s

① 语法分析

② 词法分析

③ 语义分析

④ 符号汇总 （符号包括 函数名）

### 3. 汇编 （把汇编代码转换成二进制指令） test.s——>test.o

①形成符号表

（如 main ox 0010

​     ADD ox 0200）

**链接器：** test.s——>test.exe

1.合并段表

2.符号表的合并与重定义

## 二、运行环境：

1.先将程序植入内存中（一般由操作系统完成）

2. 程序的执行开始，接着调用main函数

3.. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回 地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程 一直保留他们的值。

4. 终止程序。正常终止main函数；也有可能是意外终止。


concurrenthashmap如果允许有空值，那么多线程情况下在判空的时候就会有歧义，到底是真的空还是插入过空值

又因为，concurrentHashMap.containsKey(key) 方法调用的是get方法，如果返回的是null就就返回false，不是null就返回true，如果concurrentHashMap 的value能存储null的话，例如put(1,null),那么containsKey(1)理论上应该是true吧，但是根据源码来看，get(1)是null， null != null 是false，应该返回false,所以说value不能为null。

public boolean containsKey(Object key) {
        return get(key) != null;
    }

无法分辨是key没找到的null还是有key值为null，这在多线程里面是模糊不清的

不能确定是不是有其他线程写入了null的key还是没有key



grep -l -r -n "JAVA_HOME" ~



split -b 200m tupu_schema_70w.txt tupu-70w-part -d

将文件拆分，-b限制大小